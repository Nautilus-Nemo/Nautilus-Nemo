<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nautilu_Nemo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://log.xiaohaoming.com/"/>
  <updated>2018-10-27T11:42:25.075Z</updated>
  <id>http://log.xiaohaoming.com/</id>
  
  <author>
    <name>XIAOHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速排序</title>
    <link href="http://log.xiaohaoming.com//2018/10/algorithm-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"/>
    <id>http://log.xiaohaoming.com//2018/10/algorithm-快速排序.html</id>
    <published>2018-10-27T11:42:25.075Z</published>
    <updated>2018-10-27T11:42:25.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="什么是快速排序？"><a href="#什么是快速排序？" class="headerlink" title="什么是快速排序？"></a>什么是快速排序？</h4><p>快速排序<code>Quicksort</code>又称划分交换排序<code>partition-exchange sort.</code>。是对冒泡排序的一种改进；是一种不稳定排序<a href="在待排序的记录系列中，存在多个具有相同的关键字的记录，若经过排序记录相对次序保持不变，则称这种排序算法时稳定的，否则称为不稳定的">^1</a>。</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过一趟快速排序。排序的数据分割成独立的两部分，选定一个基准<code>provit</code>，一般选择数组首元素。通过排序，基准值被交换到这样一个数组位置。其中一部分的所有数据都比基准小，另外一部分的所有数据都比基准大。这样就可以看作已经排序好基准<a href="排序好数组元素的一个值">^3</a>。然后再按此方法对两部分在进行快速排序，整个过程可以递归进行，以此达到整个数据成为有序序列</p><ul><li><p>阈值问题<a href="阈的意思是界限，故阈值又叫临界值，是指一个效应能够产生的最低值或最高值">^2</a>：递归基 <code>left&gt;=right</code> 一趟快速排序分割数据长度<em>相对于数组</em><u>至少两个元素</u>。</p><p><a href="https://zh.wikipedia.org/wiki/快速排序" target="_blank" rel="noopener">详情</a></p></li></ul><h4 id="C版本"><a href="#C版本" class="headerlink" title="C版本"></a>C版本</h4><p><code>原地排序</code></p><p><a href="https://zh.wikipedia.org/wiki/快速排序" target="_blank" rel="noopener">非原地排序详情</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> sour[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x,<span class="keyword">int</span> *y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">quickSort(a,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i]);</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> sour[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=left;</span><br><span class="line"><span class="keyword">int</span> j=right<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> provit=sour[right];</span><br><span class="line"><span class="keyword">if</span>(left&gt;=right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(sour[i]&lt;provit&amp;&amp;i&lt;j)</span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(sour[j]&gt;=provit&amp;&amp;i&lt;j)</span><br><span class="line">&#123;</span><br><span class="line">--j;</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;sour[i],&amp;sour[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sour[i]&gt;=provit)</span><br><span class="line"><span class="comment">//为什么写&amp;provit不行？写&amp;sour[right]可以</span></span><br><span class="line"><span class="comment">//忘了&amp;provit不再数组之中，交换没用</span></span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;sour[i],&amp;sour[right]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i++; <span class="comment">//当需排序的数组已经是有序的时候，会出现i==right-1，且sour[i]&lt;provit,此时provit为中间值</span></span><br><span class="line"><span class="keyword">if</span>(i)  <span class="comment">//i==左边界（第一躺排序为i==0）时可以不再需要递归排序左边</span></span><br><span class="line">&#123;</span><br><span class="line">quickSort(sour,left,i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">quickSort(sour,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x,<span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tem=*x;</span><br><span class="line">*x=*y;</span><br><span class="line">*y=tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java版本"><a href="#java版本" class="headerlink" title="java版本"></a>java版本</h4><p><code>原地排序</code></p><p><a href="">详情</a> <code>algorithm-&gt; AlgorithmquickSort</code></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h5 id="常规计算"><a href="#常规计算" class="headerlink" title="常规计算"></a>常规计算</h5><p>我们不难观察到分区运算，数组的元素都会在每次循环中走访一次，使用<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a" alt="{\displaystyle O(n)}">的时间。</p><p>在最好的情况下，每次我们运行一次分区，我们会把一个数列分为两个几近相等的分段。这个意思就是每次递归处理一般大小的数列。因此，在到达大小为一的数列前，我们只要做<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/317ab5292da7c7935aec01a570461fe0613b21d5" alt="\log n"> 次嵌套的调用。但是在同一层次结构的两个程序调用中，不会处理原来数列的相同部分。因此，调用每一层结构总共需要<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a" alt="{\displaystyle O(n)}"> 的时间。结果是这个算法仅需要<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1" alt="{\displaystyle O(n\log n)}"> 的时间。</p><h5 id="递归计算"><a href="#递归计算" class="headerlink" title="递归计算"></a>递归计算</h5><p>设立<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0be5a46684e1279c27414b285fa995f30407d002" alt="{\displaystyle T(n)}"> 递归关系式<a href="排序大小为*n*的数组所需要的时间">^4</a></p><ul><li>在最好的情况下，因为一个单独的快速排序调用牵涉<em>O(n)</em>的工作，加上对<em>n/2</em>大小数列的两个数列的递归调用，这个关系是：</li></ul><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1998b8b2f798bc4a5115ae51a3db2e38cae82416" alt="{\displaystyle T(n)=O(n)+2T(n/2)}">  </p><p>解决这种关系式类型的标准<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95" target="_blank" rel="noopener">数学归纳法</a>技巧告诉我们</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9c138b54d2af63770ea4347bf2a9aa62f469db5" alt="{\displaystyle T(n)=O(n\log n)}">。 </p><ul><li>在最坏的情况是，两子数列拥有大各为O<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/92d98b82a3778f043108d4e20960a9193df57cbf" alt="1"> 和O<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fbd0b0f32b28f51962943ee9ede4fb34198a2521" alt="{\displaystyle n-1}">，且调用树（call tree）变成为一个<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" alt="n">个嵌套（nested）调用的线性连串（chain）。第<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" alt="i"> 次调用作了 <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0f7d6b1a0d3b42c5152740ac77e65a319f289c22" alt="{\displaystyle O(n-i)}">的工作量，且<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7fc41592878f1bc3566b9a749ffbf5743b0ab126" alt="\sum _{i=0}^{n}(n-i)=O(n^{2})">递归关系式为：</li></ul><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/11b7fe1a2ecfdad192e9d9625f41072571af645c" alt="{\displaystyle T(n)=O(n)+T(1)+T(n-1)=O(n)+T(n-1)}"></p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8526253f8646d3899c4b3f99b6b1c1d3d911a33c" alt="{\displaystyle T(n)=O(n^{2})}"> </p><h5 id="平均复杂度"><a href="#平均复杂度" class="headerlink" title="平均复杂度"></a>平均复杂度</h5><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/080cf0926b920274d591f53311ea7f0278daf5b4" alt="C(n)=n-1+{\frac {1}{n}}\sum _{i=0}^{n-1}(C(i)+C(n-i-1))=2n\ln n=1.39n\log _{2}n"> </p><p> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fbd0b0f32b28f51962943ee9ede4fb34198a2521" alt="{\displaystyle n-1}">是分区所使用的比较次数。因为基准值是相当均匀地落在排列好的数列次序之任何地方<code>概率相同</code>，总和就是所有可能分区的平均。 </p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#%E7%A9%BA%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6" target="_blank" rel="noopener">详情</a></p><p>参考引用：</p><ul><li><a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842</a>?</li><li><a href="https://zh.wikipedia.org/wiki/快速排序" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/快速排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h3&gt;&lt;h4 id=&quot;什么是快速排序？&quot;&gt;&lt;a href=&quot;#什么是快速排序？&quot; class=&quot;headerlink&quot; title=&quot;什
      
    
    </summary>
    
      <category term="algorithm" scheme="http://log.xiaohaoming.com/categories/algorithm/"/>
    
    
      <category term="quickSort" scheme="http://log.xiaohaoming.com/tags/quickSort/"/>
    
      <category term="algorithm" scheme="http://log.xiaohaoming.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>matlab函数记录</title>
    <link href="http://log.xiaohaoming.com//2018/10/extension-Matlab%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%E8%AE%B0%E5%BD%95.html"/>
    <id>http://log.xiaohaoming.com//2018/10/extension-Matlab函数功能记录.html</id>
    <published>2018-10-10T05:46:41.467Z</published>
    <updated>2018-10-10T05:46:41.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Matlab函数功能记录"><a href="#Matlab函数功能记录" class="headerlink" title="Matlab函数功能记录"></a>Matlab函数功能记录</h2><h3 id="int"><a href="#int" class="headerlink" title="int"></a><a href="https://ww2.mathworks.cn/help/symbolic/int.html?s_tid=doc_ta" target="_blank" rel="noopener">int</a></h3><p>Definite and indefinite integrals</p><p>有限和无限积分</p><ul><li><p><strong>Syntax</strong></p><ul><li>int(expr,var)</li><li>int(expr,var,a,b)</li><li>int(_,Name,Value)</li></ul></li><li><p><strong>Description</strong></p><ul><li><p>int(expr,var) -compute the indefinite integral of expr with respect to the symbolic scalar variable var.</p><p>int(expr,var) -计算使用期待符号标量变量var的expr的无限积分</p></li><li><p>int(expr,var,a,b) -computes the definite integral of expr with respect to var from a to b. If you do not specific it, int use the default variable determined by symvar. If expr is a constant, then the default variable is x.</p><p>int(expr,var,a,b) -计算使用期待从a到b的var的expr有限的积分</p></li><li><p>int(_,Name,Value)</p></li></ul></li><li><p><strong>Input Arguments</strong></p><ul><li><p>expr - Integrand 积分</p><p>symbolic expression | symbolic function | symbolic vector | symbolic matrix | symbolic number</p></li><li><p>var  Integration variable 积分变量</p><p>symbolic variable </p></li><li><p>a - Lower bound </p><p>number | symbolic number | symbolic variable | symbolic expression | symbolic function</p></li><li><p>b - Upper bound</p><p>number | symbolic number | symbolic variable | symbolic expression | symbolic function</p></li></ul></li><li><p><strong>Name-Value Pair Arguments</strong></p></li></ul><h3 id="plotfit"><a href="#plotfit" class="headerlink" title="plotfit"></a><a href="https://ww2.mathworks.cn/help/nnet/ref/plotfit.html?searchHighlight=plotfit&amp;s_tid=doc_srchtitle" target="_blank" rel="noopener">plotfit</a></h3><ul><li><p><strong>Syntax</strong></p><p>plotfit(net,inputs,targets)</p><p>plotfit(targets1,inouts1,’name’,…)</p></li><li><p><strong>Description</strong></p><p>plotfit(net,input,targets)画贯穿范围inputs inputs和画target targets和关联inputs的值的output data point的神经网络输出函数。Error bar将会展示介于outputs和targets不同</p><p>The plot 出现仅是在神经网络用于第一次input</p><p>如果神经网络有超过一次的输出，仅是第一次output/targets 出现<br><code>plotfit(targets1,inputs1,&#39;name1&#39;,...)</code> displays a series of plots.</p></li></ul><h3 id="lsqcurvefit"><a href="#lsqcurvefit" class="headerlink" title="lsqcurvefit"></a><a href="https://ww2.mathworks.cn/help/optim/ug/lsqcurvefit.html?s_tid=doc_ta#d119e74978" target="_blank" rel="noopener">lsqcurvefit</a></h3><p>解决非线性曲线拟合问题使用最小二乘法</p><h3 id="fzero"><a href="#fzero" class="headerlink" title="fzero"></a><a href="https://ww2.mathworks.cn/help/matlab/ref/fzero.html?lang=en#btoc6lj-18" target="_blank" rel="noopener">fzero</a></h3><p>求解非线性函数根</p><p>查找线性函数求解根或者其他相关函数，请在命令行输入 help fzero</p><ul><li>Description</li></ul><p>x = fzero(fun,x0)<br>tries to find a point x where fun(x) = 0. This solution is where fun(x) changes sign—fzero cannot find a root of a function such as x^2.<br>尝试发现一个fun(x)=0的x值.解决方案是通过fun(x)在两点x值不同符号慢慢逼近fun(x)=0，所以不能发现像x^2这样函数的根</p><p>x = fzero(fun,x0,options)<br>uses options to modify the solution process.</p><p>x = fzero(problem)<br>solves a root-finding problem specified by problem.</p><p>[x,fval,exitflag,output] = fzero(___)<br>returns fun(x) in the fval output, exitflag encoding the reason fzero stopped, and an output structure containing information on the solution process.</p><p>输入参数说明：<br>fun :函数句柄<br>例：’sin’<br>​       @myFunction<br>​       @(x)(x-a)^5<br>x0:1：区间（这个包含根的x的区间，即输入区间端点的x值必须fun(x)值符号不同）2：实数 较接近根的值<br>例：3<br>例：[2,17]</p><h3 id="randn"><a href="#randn" class="headerlink" title="randn"></a>randn</h3><p>*【未看】2：randn - Normally distributed pseudorandom numbers(正态分布伪随机数)<br> 这个函数返回一个被标准正态分布绘制的伪随机标量<br>​    r = randn(n)<br>​    r = randn(sz1,…,szN)<br>​    r = randn(sz)<br>​    r = randn(classname)<br>​    r = randn(n,classname)<br>​    r = randn(sz1,…,szN,classname)<br>​    r = randn(sz,classname)<br>​    r = randn(‘like’,p)<br>​    r = randn(n,’like’,p)<br>​    r = randn(sz1,…,szN,’like’,p)<br>​    r = randn(sz,’like’,p)</p><h3 id="orth-Orthonormal-basis-for-range-of-matrix（矩阵值域的正交基）"><a href="#orth-Orthonormal-basis-for-range-of-matrix（矩阵值域的正交基）" class="headerlink" title="orth - Orthonormal basis for range of matrix（矩阵值域的正交基）"></a>orth - Orthonormal basis for range of matrix（矩阵值域的正交基）</h3><p>   Q = orth(A)<br>   这个函数返回A矩阵的值域正交基<br>   注释：矩阵与其本身的转置矩阵乘积为E</p><h3 id="logspace-Generate-logarithmically-spaced-vertors-生成对数间隔向量"><a href="#logspace-Generate-logarithmically-spaced-vertors-生成对数间隔向量" class="headerlink" title="logspace - Generate logarithmically spaced vertors  生成对数间隔向量"></a>logspace - Generate logarithmically spaced vertors  生成对数间隔向量</h3><p>​    y = logspace(a,b)<br>​    y = logspace(a,b,n)<br>​    y = logspace(a,pi)<br>   这个函数生成介于10^a和10^b的50个对数间隔点行向量 y。</p><h3 id="diag-Get-diagonal-elements-or-create-diagonal-matrix-获取对角线元素或创建对角矩阵"><a href="#diag-Get-diagonal-elements-or-create-diagonal-matrix-获取对角线元素或创建对角矩阵" class="headerlink" title="diag -Get diagonal elements or create diagonal matrix 获取对角线元素或创建对角矩阵"></a>diag -Get diagonal elements or create diagonal matrix 获取对角线元素或创建对角矩阵</h3><p>   这个函数返回矢量v元素在main(k=0)对角的对角矩阵方阵</p><h3 id="inv-Matrix-inverse-逆矩阵"><a href="#inv-Matrix-inverse-逆矩阵" class="headerlink" title="inv Matrix inverse(逆矩阵)"></a>inv Matrix inverse(逆矩阵)</h3><p>​       Y = inv(x)<br>​    一般极少使用，一个不恰当的使用是求线性方程Ax=b,一种解决方案是x=inv(A)*b,从执行时间和数值精确点，应该使用矩阵除法操作符 x=A\b</p><h3 id="dsolve-Ordinary-differential-equation-and-system-solver"><a href="#dsolve-Ordinary-differential-equation-and-system-solver" class="headerlink" title="dsolve -Ordinary differential equation and system solver"></a>dsolve -<a href="https://ww2.mathworks.cn/help/symbolic/dsolve.html?searchHighlight=dsolve&amp;s_tid=doc_srchtitle" target="_blank" rel="noopener">Ordinary differential equation and system solver</a></h3><p>​       解常微分方程和系统求解器<br>​       S = dsolve(eqn)<br>​       S = dsolve(eqn,cond)<br>​       S = dsolve(eqn,cond,Name,Value)<br>​       [y1,…,yN] = dsolve(___)<br>​      note: Character vector inputs will be removed in a future release. Instead, use syms to declare variables and<br>​      replace inputs such as dsolve(‘Dy = y’) with syms y(t); dsolve(diff(y,t) == y).</p><h3 id="plot-2-D-line-plot"><a href="#plot-2-D-line-plot" class="headerlink" title="plot - 2-D line plot"></a>plot - <a href="https://ww2.mathworks.cn/help/matlab/ref/plot.html?lang=en#btzitot-ax" target="_blank" rel="noopener">2-D line plot</a></h3><p>plot(X,Y)<br>plot(X,Y,LineSpec)<br>plot(X1,Y1,…,Xn,Yn)<br>plot(X1,Y1,LineSpec1,…,Xn,Yn,LineSpecn)<br>plot(Y)<br>plot(Y,LineSpec)<br>plot(<strong><em>,Name,Value)<br>plot(ax,</em></strong>)<br>h = plot(___)</p><p>plot(X,Y)<br>creates a 2-D line plot of the data in Y versus the corresponding values in X.<br>使用数据Y相对符合值X创造一个2-D线性图</p><ul><li>X Data Types: single | double | int8 | int16 | int32 | int64 | uint8 | uint16 | uint32 | uint64 | categorical | datetime | duration</li><li>Y Data Types: single | double | int8 | int16 | int32 | int64 | uint8 | uint16 | uint32 | uint64 | categorical | datetime | duration</li></ul><p>plot(X,Y,LineSpec)<br>plot(X,Y,LineSpec) sets the line style, marker symbol, and color.<br>画plot(X,Y,LineSpec)设置线风格，标记符号和原色</p><ul><li>LineSpec — Line style, marker, and color</li></ul><p>character vector | string</p><p>plot(___,Name,Value)<br>specified line properties using one or more name,value pair arguments.For a list of properties,see Line Properties(<a href="https://ww2.mathworks.cn/help/matlab/ref/" target="_blank" rel="noopener">https://ww2.mathworks.cn/help/matlab/ref/</a><br>matlab.graphics.chart.primitive.line-properties.html?lang=en).Use this option with any of the input argument combinations in the previous syntaxes.Name-value<br>pair apply to all the lines plotted.<br>使用一个或者多个name,value对属性来指定line properties.使用这些选项可以和在上面语法中任意输入参数结合.Name-Value对应用于所有画线。</p><p>plot(ax,___)<br>creates the line in the axes specified by ax instead of in the current axes(gca).The option ax can precede andy of the input argument combinations in<br>the previous syntaxes<br>在AX指定的轴中创建行，而不是在当前轴（GCA）中创建。选项AX可以先于前一个语法中的任何输入参数组合。</p><h3 id="magic-Magic-square"><a href="#magic-Magic-square" class="headerlink" title="magic - Magic square"></a>magic - Magic square</h3><p> This MATLAB function returns an n-by-n matrix construced from the integers 1 through n^2<br>with row and column sums.<br>这个函数将会返回一个从整数1至n^2的行和列的和都相等的n阶矩阵  </p><h3 id="fplot"><a href="#fplot" class="headerlink" title="fplot"></a><a href="https://ww2.mathworks.cn/help/matlab/ref/fplot.html?lang=en" target="_blank" rel="noopener">fplot</a></h3><p>Plot expression or function<br>画函数或者表达式<br>区别于plot</p><ul><li>Syntax</li></ul><p>fplot(f) 默认的函数范围为[-5 5]<br>fplot(f,xinterval)<br>fplot(funx,funy)<br>fplot(funx,funy,tinterval)<br>fplot(<strong><em>,LineSpec)<br>fplot(</em></strong>,Name,Value)<br>fplot(ax,<strong><em>)<br>fp = fplot(</em></strong>)<br>[x,y] = fplot(）</p><ul><li>Input Argutments</li></ul><p>f – Function to plot<br>function handle 函数句柄<br>函数将要画的，以命名的或者匿名的函数句柄来指定<br>指定函数的组成 y = f(x).这个函数期待一个矢量输入参数和返回一个相同的大小的矢量输出参数。使用数组操作符代替矩阵操作符。例如，使用.<em>(times) 代替</em>(mtimes)</p><h3 id="compan-Companion-Matrix-伴随矩阵"><a href="#compan-Companion-Matrix-伴随矩阵" class="headerlink" title="compan - Companion Matrix 伴随矩阵"></a>compan - Companion Matrix 伴随矩阵</h3><ul><li>Syntax - 语法</li></ul><p>A = compan(u)</p><ul><li>Description - 描述</li></ul><p>A = compan(u) returns the corresponding matrixs these first row is -u(2:n)/u(1),where u is a vector of ploynomial coefficients.The eigenvalues of compan(u)<br>are the roots of the ploynomial</p><ul><li>A = compan(u) 返回第一行是 -u(2:n)/u(1)的符合矩阵，其中u是一个多项式系数矢量。eig( compan(u) )特征值是多项式的根 </li></ul><h3 id="surf-3-D-影表面画图-未看"><a href="#surf-3-D-影表面画图-未看" class="headerlink" title="surf - 3-D 影表面画图 -未看"></a>surf - 3-D 影表面画图 -未看</h3><ul><li><p><strong>description</strong></p><p>这个函数功能根据z矩阵【m,n】=size(z)，使用x = 1:n和y = 1:m创造一个 three-dimensional shaded surface</p></li><li><p><strong>Syntax</strong></p><p>​    surf(Z)<br>​    surf(Z,C)<br>​    surf(X,Y,Z)<br>​    surf(X,Y,Z,C)<br>​    surf(…,’PropertyName’,PropertyValue)<br>​    surf(axes_handles,…)<br>​    h = surf(…)</p></li><li><p><strong>Example</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="number">1</span>:<span class="number">0.3</span>:<span class="number">5</span>)';   <span class="comment">% ’属于转置</span></span><br><span class="line">y = x';</span><br><span class="line">V = <span class="built_in">cos</span>(x) * <span class="built_in">sin</span>(y);</span><br><span class="line">n = <span class="built_in">length</span>(x);</span><br><span class="line">surf(<span class="number">1</span>:n,<span class="number">1</span>:n,V)   <span class="comment">% surf(X,Y,Z)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ppval-计算分段多项式"><a href="#ppval-计算分段多项式" class="headerlink" title="ppval - 计算分段多项式"></a>ppval - 计算分段多项式</h3><ul><li><p><strong>Syntax</strong></p><p>v = ppval(pp,xq) </p></li><li><p><strong>Describle</strong></p><p><code>v = ppval(pp,xq)</code> 在查询点 <code>xq</code> 处计算分段多项式 <code>pp</code>。 </p></li><li><p><strong>example</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">breaks = [<span class="number">0</span> <span class="number">4</span> <span class="number">10</span> <span class="number">15</span>];  <span class="comment">%断点 区间分别为 [0,4] [4,10] [10,15]</span></span><br><span class="line">coefs = [<span class="number">0</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">1</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">53</span>; <span class="number">-1</span> <span class="number">6</span> <span class="number">1</span> <span class="number">4</span> <span class="number">77</span>]; <span class="comment">%对应多项式系数 5列:代表最高次数为5 </span></span><br><span class="line">pp = mkpp(breaks,coefs); <span class="comment">%创建分段多项式</span></span><br><span class="line">xq = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">15</span>;</span><br><span class="line">plot(xq,ppval(pp,xq))  <span class="comment">%计算多项式值和画函数</span></span><br><span class="line">line([<span class="number">4</span> <span class="number">4</span>],ylim,<span class="string">'LineStyle'</span>,<span class="string">'--'</span>,<span class="string">'Color'</span>,<span class="string">'k'</span>)</span><br><span class="line">line([<span class="number">10</span> <span class="number">10</span>],ylim,<span class="string">'LineStyle'</span>,<span class="string">'--'</span>,<span class="string">'Color'</span>,<span class="string">'k'</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="diff-微分符号函数或者函数"><a href="#diff-微分符号函数或者函数" class="headerlink" title="diff - 微分符号函数或者函数"></a>diff - 微分符号函数或者函数</h3><ul><li><p><strong>Syntax</strong> - <strong>Describle</strong></p><p><code>diff(F)</code>微分F被symvar(F,1)决定的期待变量</p><p><code>diff(F,var)</code> 微分F通过求导var变量</p><p><code>diff(F,n)</code> 计算n次导通过对symvar决定的变量</p><p><code>diff(F,var,n)</code></p><p><code>diff(F,var1,...,varN)</code> </p></li><li><p><strong>Input Argument</strong></p><p><strong>F</strong> –表达式或者函数将要被微分的</p><p>symbolic expression | symbolic function | symbolic vector | symbolic matrix</p></li><li><p><strong>Example</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ res ]</span> = <span class="title">Test_Interpolation</span><span class="params">(  )</span></span></span><br><span class="line"><span class="comment">%Describe  Find the derivative of the function sin(x^2).</span></span><br><span class="line"><span class="comment">%Syntax diff(F)</span></span><br><span class="line">syms f(x);   <span class="comment">%定义一个函数变量</span></span><br><span class="line">f(x) = <span class="built_in">sin</span>(x^<span class="number">2</span>);  <span class="comment">%symbolic function</span></span><br><span class="line"><span class="comment">%res = diff('sin(x^2)',x); symbolic expression</span></span><br><span class="line">res = diff(f,x);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ res ]</span> = <span class="title">Test_Interpolation</span><span class="params">(  )</span></span></span><br><span class="line"><span class="comment">%Describe  Differentiation with Respect to Particular Variable</span></span><br><span class="line"><span class="comment">%Syntax diff(F,var)</span></span><br><span class="line">sym x t;</span><br><span class="line"><span class="comment">%symvar(t,1) %默认变量为x,你可以通过这个函数决定默认变量</span></span><br><span class="line"><span class="comment">%也可以通过设置var</span></span><br><span class="line">res = diff(<span class="built_in">sin</span>(x * t^<span class="number">2</span>),t); <span class="comment">%符号函数</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ res ]</span> = <span class="title">Test_Interpolation</span><span class="params">(  )</span></span></span><br><span class="line"><span class="comment">%Describe Higher-Order Derivatives of Univariate(单一的) Expression</span></span><br><span class="line"><span class="comment">%高阶求导</span></span><br><span class="line"><span class="comment">%Syntax diff(F,n)</span></span><br><span class="line">syms t;</span><br><span class="line">res = diff(t^<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ res ]</span> = <span class="title">Test_Interpolation</span><span class="params">(  )</span></span></span><br><span class="line"><span class="comment">%Describe Mixed Derivatives</span></span><br><span class="line"><span class="comment">%Syntax diff(F,var1,...,varN) </span></span><br><span class="line">syms x y;</span><br><span class="line">res = diff(x * <span class="built_in">sin</span>(x * y),x,y); <span class="comment">%先对x求导在对y求导</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="symvar-在符号输入中发现符号变量"><a href="#symvar-在符号输入中发现符号变量" class="headerlink" title="symvar - 在符号输入中发现符号变量"></a>symvar - 在符号输入中发现符号变量</h3><p>  Find symbolic variables of symbolic input</p><p>  <strong>Syntax</strong> </p><ul><li><p>symvar(s)</p><p>它通过矢量方式返回在s中的符号变量。变量是以按字母顺序返回并且大写字母优于小写字母返回</p></li><li><p>symvar(s,n)</p><p>它选择按字母顺序最接近x的在s中的n个符号变量和返回它们以字母顺序。如果s是符号函数，symvar(s,n)返回s中的输入参数在s中的其他变量之前。</p><p><strong>Input arguments</strong></p></li><li><p><strong>s – input</strong></p><p>number | vector | matrix | array | symbolic number | symbolic variable | symbolic array | symbolic function | symbolic expression</p></li><li><p><strong>n – Number of variables</strong></p><p>integer</p><p><strong>Example</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fout</span> = <span class="title">Test</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="comment">%Describe Find symbolic variables in expression</span></span><br><span class="line"><span class="comment">%Syntax symvar(s)  </span></span><br><span class="line">syms wa wb ya yb</span><br><span class="line">sum = wa +wb + ya + yb;</span><br><span class="line">symvar(sum) <span class="comment">%按字母顺序返回变量 wa wb ya yb</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fout = Test(a,b,c)</span><br><span class="line">%Describe Find Default variable of expression</span><br><span class="line">%Syntax symvar(s,n)  </span><br><span class="line">syms v z</span><br><span class="line">g = v + z;</span><br><span class="line">symvar(g,1) %发现默认自变量 z</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="subs-符号代替"><a href="#subs-符号代替" class="headerlink" title="subs - 符号代替"></a>subs - 符号代替</h3><p><strong>Syntax</strong></p></li><li><p>subs(s,old,new)</p><p>返回一个s的复制，代替所有的old的出现为new，和计算s</p></li><li><p>subs(s,new)</p><p>返回一个s的复制，代替在s中所有的默认变量出现为new，和计算s。默认变量是定义通过symvar.</p></li><li><p>sub(s)</p><p>反回一个s的复制，代替在s中所有的符号变量。这些符号变量的值来自调用函数和MatLab工作空间，和计算s。没有赋值的值将会保持作为变量</p><p><strong>Input Arguments</strong></p></li><li><p><strong>s – Input</strong></p><p>symbolic variable | symbolic expression | symbolic equation | symbolic function | symbolic array | symbolic matrix</p></li><li><p><strong>old – Element to substitute</strong></p><p>symbolic variable | symbolic expression | symbolic array</p></li><li><p><strong>new – New element</strong></p><p>number | symbolic number | symbolic variable | symbolic expression | symbolic array | structure</p><p><strong>Example</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fout</span> = <span class="title">Test</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="comment">%Describe Single Substitution</span></span><br><span class="line"><span class="comment">%Syntax subs(s,old,new)</span></span><br><span class="line">syms a b</span><br><span class="line">subs(a + b,a,<span class="number">4</span>) <span class="comment">%代替a为4并计算</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fout</span> = <span class="title">Test</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="comment">%Describe default Substitution variable</span></span><br><span class="line"><span class="comment">%Syntax subs(s,new)</span></span><br><span class="line">syms x y a</span><br><span class="line">symvar(x + y,<span class="number">1</span>); <span class="comment">%按字母顺序 x</span></span><br><span class="line">subs(x + y,a) <span class="comment">%根据上面默认变量，替换x为a</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%Describe update Expression with new value</span></span><br><span class="line"><span class="comment">%Syntax subs(s)</span></span><br><span class="line">syms a y(t)</span><br><span class="line">y = dsolve(diff(y) == -a*y)</span><br><span class="line">a = <span class="number">980</span>;</span><br><span class="line">C2 = <span class="number">3</span>;</span><br><span class="line">subs(y)</span><br></pre></td></tr></table></figure></li></ul><h3 id="solve-方程和系统求解器"><a href="#solve-方程和系统求解器" class="headerlink" title="solve - 方程和系统求解器"></a>solve - <a href="https://ww2.mathworks.cn/help/symbolic/solve.html?searchHighlight=solve&amp;s_tid=doc_srchtitle#bue6mwo-1" target="_blank" rel="noopener">方程和系统求解器</a></h3><p><strong>Syntax</strong></p><ul><li><p>S = solve(eqn,var)</p><p>解方程变量通过方程 eqn，如果你并没有指定 var, symvar函数决定解变量。 </p></li><li><p>S = solve(eqn,var,Name,Value)</p><p>solve(eqn,var,Name,Value) 使用一个或者多个Name,Vakue对参数指定额外的选择</p></li><li><p>Y = solve(eqns,vars)</p><p>解指定变量 vars 通过系统方程 eqns和返回一个包含解的结构体。如果你并没有指定 vars,<strong>solve</strong>使用<strong>symvar</strong>来找到解变量。在这个案例中，<strong>symvar</strong>发现的变量数量等于方程 <strong>eqns</strong>的数量</p></li><li><p>[y1,…,yN] = solve(eqns,vars)</p><p>解指定变量 vars 通过系统方程 eqns和这个解将会被赋值给变量y1,y2,y3…yN,<strong>solve</strong>使用<strong>symvar</strong>来找到解变量。在这个案例中，<strong>symvar</strong>发现的变量数量等于方程 <strong>eqns</strong>的数量</p></li><li><p>[y1,…,yN,parameters,conditions] = solve(eqns,vars,’ReturnConditions’,true)</p><p>返回额外的参数自变量和指定解和此解的条件的参数</p></li></ul><p><code>其他未写</code>:busts_in_silhouette:</p><p><strong>Input  Arguments</strong></p><ul><li><p>eqn – Equation to solve</p><p>symbolic expression | symbolic equation</p></li><li><p>var – Variable for which you solve equation</p><p>symbolic variable</p></li></ul><p><strong>Example</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fout</span> = <span class="title">Test</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="comment">%Describe Solve an equation</span></span><br><span class="line"><span class="comment">%Syntax solve(eqn,var)</span></span><br><span class="line">syms x</span><br><span class="line">eqn = <span class="built_in">sin</span>(x) == <span class="number">1</span>;</span><br><span class="line">solx = solve(eqn,x) <span class="comment">%pi/2，solve并不会返回一个无限集合，可以使用name value 设置，2014a不存在这个参数</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fout</span> = <span class="title">Test</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="comment">%Describe Return real solutions</span></span><br><span class="line"><span class="comment">%Syntax solve(eqn,var,Name,Value)</span></span><br><span class="line">syms x</span><br><span class="line">eqn = x^<span class="number">5</span> == <span class="number">3125</span>;</span><br><span class="line">solve(eqn,x); <span class="comment">%返回实数根和负数根</span></span><br><span class="line">solve(eqn,x,<span class="string">'Real'</span>,true) <span class="comment">%只返回实数根</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span> = <span class="title">Test</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="comment">%Describe Solve Multivariate Equations and Assign Outputs to Structure</span></span><br><span class="line"><span class="comment">%Syntax solve(eqns,vars)</span></span><br><span class="line">syms u v</span><br><span class="line">eqns = [<span class="number">2</span>*u + v == <span class="number">0</span>,u - v == <span class="number">1</span>];</span><br><span class="line">S = solve(eqns,u,v); <span class="comment">%以结构体返回</span></span><br><span class="line">expr1 = u^<span class="number">2</span>;</span><br><span class="line">subs(expr1, S)   <span class="comment">%替换u通过已知值</span></span><br><span class="line">expr2 = <span class="number">3</span>*v+u;</span><br><span class="line">subs(expr2, S)   <span class="comment">%替换v通过已知值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>Other</strong></p><p>图解法和<code>slove</code>和<code>fsolve</code>的比较</p><p><a href="https://jingyan.baidu.com/article/a681b0de7f383f3b18434606.html" target="_blank" rel="noopener">点击</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Matlab函数功能记录&quot;&gt;&lt;a href=&quot;#Matlab函数功能记录&quot; class=&quot;headerlink&quot; title=&quot;Matlab函数功能记录&quot;&gt;&lt;/a&gt;Matlab函数功能记录&lt;/h2&gt;&lt;h3 id=&quot;int&quot;&gt;&lt;a href=&quot;#int&quot; class
      
    
    </summary>
    
      <category term="extension" scheme="http://log.xiaohaoming.com/categories/extension/"/>
    
    
      <category term="matlab" scheme="http://log.xiaohaoming.com/tags/matlab/"/>
    
      <category term="functions" scheme="http://log.xiaohaoming.com/tags/functions/"/>
    
  </entry>
  
  <entry>
    <title>token简单介绍</title>
    <link href="http://log.xiaohaoming.com//2018/09/extension-%E4%BB%80%E4%B9%88%E6%98%AFtoken.html"/>
    <id>http://log.xiaohaoming.com//2018/09/extension-什么是token.html</id>
    <published>2018-09-25T13:59:06.940Z</published>
    <updated>2018-09-25T13:59:04.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是token"><a href="#什么是token" class="headerlink" title="什么是token"></a>什么是token</h3><p><strong>token</strong>的意思是”令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。</p><p>当用户登陆后，服务器生成一个<strong>token</strong>并将此<strong>token</strong>返回给客户端，以后客户端只需带上这个token并将此token返回给客户端，无需再次带上用户名和密码。</p><p>简单的token的组成：uid<a href="用户名唯一的身份标识">^1</a> time<a href="当前时间的时间戳">^2</a> sign<a href="签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串for防止token泄露">^3</a></p><h4 id="身份认证概述"><a href="#身份认证概述" class="headerlink" title="身份认证概述"></a>身份认证概述</h4><p><strong>HTTP</strong>是一种没有状态的协议，他并不知道是谁访问了我们的应用</p><p>解决方案</p><ul><li><p><strong>session/cookie</strong></p></li><li><p><strong>token</strong></p><p>客户端使用用户名和密码请求登陆。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个<strong>token</strong>，然后把这个<strong>token</strong>发送给客户端。客户端收到<strong>token</strong>后把它存储起来，可以放在<strong>cookie</strong>或者<strong>Local Storage</strong>。客户端每次向服务端发送请求的时候都需要带上服务端发给的<strong>token</strong>。如果验证成功，就像客户端返回请求的数据。</p></li></ul><h4 id="Token登陆认证几个方式"><a href="#Token登陆认证几个方式" class="headerlink" title="Token登陆认证几个方式"></a>Token登陆认证几个方式</h4><ul><li>用设备<code>mac</code>地址作为<strong>token</strong> </li><li>用<code>sessionid</code>作为<strong>token</strong> </li></ul><h4 id="Token的存储"><a href="#Token的存储" class="headerlink" title="Token的存储"></a>Token的存储</h4><p><strong>token</strong>可以存到数据库中，但是有可能查询<strong>token</strong>的时间会过长导致<strong>token</strong>丢失</p><p>为了避免查询时间过长，可以将<strong>token</strong>放到内存中。这样的查询速度绝对不是问题，也不担心占据内存，就算<strong>token</strong>是一个32位的字符串，应用的用户量在百万级或者千万级，也是占不了多少内存的。</p><h4 id="Token的加密"><a href="#Token的加密" class="headerlink" title="Token的加密"></a>Token的加密</h4><p><strong>token</strong>是很容易泄露的，如果不进行加密处理，很容易被恶意拷贝并用来登陆</p><p>在存储的时候把<strong>token</strong>进行对称加密存储，用到的时候再解密。文章最开始提到的签名<u>sign</u>：将请求<u>URL</u>、时间戳<u>time</u>、<u>token</u>三者合并，通过算法进行加密处理。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是token&quot;&gt;&lt;a href=&quot;#什么是token&quot; class=&quot;headerlink&quot; title=&quot;什么是token&quot;&gt;&lt;/a&gt;什么是token&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;token&lt;/strong&gt;的意思是”令牌”，是服务端生成的一串字符串，作为
      
    
    </summary>
    
      <category term="extension" scheme="http://log.xiaohaoming.com/categories/extension/"/>
    
    
      <category term="understand" scheme="http://log.xiaohaoming.com/tags/understand/"/>
    
  </entry>
  
  <entry>
    <title>问题解决</title>
    <link href="http://log.xiaohaoming.com//2018/09/extension-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html"/>
    <id>http://log.xiaohaoming.com//2018/09/extension-问题解决.html</id>
    <published>2018-09-25T13:58:12.707Z</published>
    <updated>2018-09-09T08:49:59.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="1-导入-jar文件可执行文件与eclipse需要重写遇到did-not-contain-the-main-type的原因"><a href="#1-导入-jar文件可执行文件与eclipse需要重写遇到did-not-contain-the-main-type的原因" class="headerlink" title="(1) 导入.jar文件可执行文件与eclipse需要重写遇到did not contain the main type的原因"></a>(1) 导入.jar文件可执行文件与eclipse需要重写遇到did not contain the main type的原因</h4><pre><code>导入后实际为普通文件形式，不属于src文件，不能运行，*.jar里面的库重新build path导入，其它.java复制进去</code></pre><p><a href="https://stackoverflow.com/questions/16225177/error-selection" target="_blank" rel="noopener">其他可能造成的原因请看</a></p><h4 id="2-未在jdk中找到javax-xml-blind（classnotFoundException"><a href="#2-未在jdk中找到javax-xml-blind（classnotFoundException" class="headerlink" title="(2) 未在jdk中找到javax.xml.blind（classnotFoundException)"></a>(2) 未在jdk中找到javax.xml.blind（classnotFoundException)</h4><p><code>jdk9.0.1</code>已经抛弃<code>javax.xml.blind</code>包，从<a href="https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api/2.3.0" target="_blank" rel="noopener">maven</a>导入找到要导入的包及依赖库描述，建立一个maven项目artifact，在<code>pom.xml</code>中加入依赖<code>dependency</code><br><a href="https://stackoverflow.com/questions/43574426/how-to-resolve-java-lang-noclassdeffounderror-javax-xml-bind-jaxbexception-in-j/48136912#48136912" target="_blank" rel="noopener">具体参考</a></p><h4 id="3-WARNING-An-illegal-reflective-access-operation-has-occurred"><a href="#3-WARNING-An-illegal-reflective-access-operation-has-occurred" class="headerlink" title="(3) WARNING: An illegal reflective access operation has occurred"></a>(3) WARNING: An illegal reflective access operation has occurred</h4><p><code>WARNING: Illegal reflective access by com.sun.xml.bind.v2.runtime.reflect.opt.Injector (file:/C:/Users/13612/.m2/repository/com/sun/xml/bind/jaxb-impl/2.3.0/jaxb-impl-2.3.0.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int)</code></p><ul><li>WARNING: Please consider reporting this to the   maintainercom.sun.xml.bind.v2.runtime.reflect.opt.Injector</li><li>WARNING: Use –illegal-access=warn to enable warnings of further illegal reflective access operations</li><li><p>WARNING: All illegal access operations will be denied in a future release<br><code>原因：jdk9加入的安全</code><br><code>解决方案</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//屏蔽掉非法反射访问，JDK9</span></span><br><span class="line">      StudentMessagHandler.disableWarning();<span class="comment">//主要这个语句</span></span><br><span class="line">      StudentMessagHandler smh=<span class="keyword">new</span> StudentMessagHandler(</span><br><span class="line">      <span class="string">"C:\\data\\（含预警1.0）大一、大二、大三通讯录\\"</span></span><br><span class="line">      + <span class="string">"（含预警）大一、大二、大三通讯录\\学生通讯录\\16级\\160801.xlsx"</span>);</span><br><span class="line">      <span class="keyword">for</span>(String str:smh.randomMacth(<span class="number">5</span>)) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p> <code>2: StackOverflow查找问题解决方案</code></p></li></ul><h4 id="4-405-method-not-allowed"><a href="#4-405-method-not-allowed" class="headerlink" title="(4) 405 method not allowed"></a>(4) 405 method not allowed</h4><p><code>原因</code></p><p><code>在尝试访问endpoint使用浏览器工具，然而，什么嘛时候打印资源URL在浏览器框，是正在执行request请求，这和是默认的因此，浏览器不能给你灵活的测试REST API，你只能执行GET请求。</code></p><p><code>解决方案</code></p><p><code>为了测试rest API，你应该使用正确的工具。有下列几种：CURL,PostMan等</code></p><p><a href="https://stackoverflow.com/questions/35839547/how-to-perform-post-requests-to-a-rest-webservice" target="_blank" rel="noopener">具体请看</a></p><h4 id="5-curl安装"><a href="#5-curl安装" class="headerlink" title="(5) curl安装"></a>(5) curl安装</h4><p>  <a href="https://curl.haxx.se/dlwiz/?type=bin&amp;os=Win64&amp;flav=-&amp;ver=*&amp;cpu=x86_64" target="_blank" rel="noopener">进入官网</a><br>  <a href="https://stackoverflow.com/questions/9507353/how-do-i-install-set-up-and-use-curl-on-windows" target="_blank" rel="noopener">具体请看</a></p><h4 id="6-the-type-is-not-accessible"><a href="#6-the-type-is-not-accessible" class="headerlink" title="(6) the type** is not accessible"></a>(6) the type** is not accessible</h4><p>​    用<code>eclipse build path</code>导入<code>classpath or module path</code>存在，但通过以<code>Maven</code>形式导入，不存在这种问题<br>    深层封装问题，未解决。</p><h4 id="7-实参和形参的区别"><a href="#7-实参和形参的区别" class="headerlink" title="(7) 实参和形参的区别"></a>(7) 实参和形参的区别</h4><p>请看<code>DeleteLinkedNodeFromTO（packet Algorithm）</code><br> <a href="https://blog.csdn.net/johnson_moon/article/details/54094655" target="_blank" rel="noopener">参考</a></p><h4 id="8-Could-not-instantiate-TestExecutionListener"><a href="#8-Could-not-instantiate-TestExecutionListener" class="headerlink" title="(8) Could not instantiate TestExecutionListener"></a>(8) Could not instantiate TestExecutionListener</h4><p>Specify custom listener classes or make the default listener classes (and their required dependencies) available. Offending class: [javax/servlet/ServletContext]<br><code>原因</code><br><code>没有提供存在该包lib，如果没有使用web一些包，可以不需要管这个问题，这是默认的springTest实例的一些类</code><br><a href="https://stackoverflow.com/questions/26125024/could-not-instantiate-testexecutionlistener" target="_blank" rel="noopener">具体解决方案请看</a></p><h4 id="9-java-lang-ClassNotFoundException-javax-xml-bind-JAXBException"><a href="#9-java-lang-ClassNotFoundException-javax-xml-bind-JAXBException" class="headerlink" title="(9) java.lang.ClassNotFoundException: javax.xml.bind.JAXBException"></a>(9) java.lang.ClassNotFoundException: javax.xml.bind.JAXBException</h4><p><code>原因</code><br><code>未发现这个javax.xml.bind/..包在发布web应用里面由于java9module配置移除了java ee包含的java/xml/bind/</code><br><code>解决方案</code><br><code>发布的web应用下面lib库中添加有关联的包</code><br><a href="https://blog.csdn.net/hadues/article/details/79188793" target="_blank" rel="noopener">具体解决方案</a></p><h4 id="10-严重-Invalid-message-recieved-with-signature-18245"><a href="#10-严重-Invalid-message-recieved-with-signature-18245" class="headerlink" title="(10) 严重: Invalid message recieved with signature 18245"></a>(10) 严重: Invalid message recieved with signature 18245</h4><p> <code>原因</code></p><p><code>这个提示是由于我用HTTP方式访问了8009端口，而8009端口是通过AJP访问的</code></p><h4 id="11-关于mysql-Access-denied-for-user-root-localhos问题解答"><a href="#11-关于mysql-Access-denied-for-user-root-localhos问题解答" class="headerlink" title="(11) 关于mysql Access denied for user root@localhos问题解答"></a>(11) 关于mysql Access denied for user root@localhos问题解答</h4><p>  <code>原因</code><br>  <code>首次登录mysql密码未设置是遇到拒绝访问，权限检查不予许</code><br>  <code>解决方案</code></p><ul><li>如果未关闭MYSQL服务，关闭MYSQL服务 例：command line:net stop mysql;</li><li>进入安装目录 $/my.ini配置文件，在[mysqld]条目下添加–skip-grant-tables，过着cmd命令 $mysqld-nt –skip-grant-tables，启动mysql，忽略权限检查</li><li>在mysql命令行中，mysqladmin -u root flush-privileges password “newpassword” 重设root密码</li><li>net start mysql 重新登录</li></ul><h4 id="12-关于phpmydmin管理界面不存在添加用户权限的原因解答"><a href="#12-关于phpmydmin管理界面不存在添加用户权限的原因解答" class="headerlink" title="(12) 关于phpmydmin管理界面不存在添加用户权限的原因解答"></a>(12) 关于phpmydmin管理界面不存在添加用户权限的原因解答</h4><p><code>原因</code><br><code>首次登录未设置密码权限不够导致.通过上面的解决方案，可以解决这个问题</code></p><h4 id="13-C语言中标准输入的结束符-windows-CTRL-z，linux是Ctrl-d"><a href="#13-C语言中标准输入的结束符-windows-CTRL-z，linux是Ctrl-d" class="headerlink" title="(13) C语言中标准输入的结束符 windows CTRL+z，linux是Ctrl+d"></a>(13) C语言中标准输入的结束符 windows CTRL+z，linux是Ctrl+d</h4><h4 id="14-An-invalid-character-32-was-present-in-the-Cookie-value"><a href="#14-An-invalid-character-32-was-present-in-the-Cookie-value" class="headerlink" title="(14) An invalid character [32] was present in the Cookie value"></a>(14) An invalid character [32] was present in the Cookie value</h4><p>WEB16 lastAccessTimeServlet SimpleDateFormat format = new SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”);<br><code>原因</code><br><code>an invalid character [32] was present in the Cookie value  中32对应的编码是空格</code><br><code>Stack Overflow上的回答：This is due to Tomcat&#39;s cookie processing being changed to a RFC 6265 compliant implementation by default in 8.5, which does not allow space (character 32), among others. 我的tomcat版本是9.0，发现WEB16 lastAccessTimeServlet SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)这行代码yyyy-MM-dd hh:mm:ss存在空格。</code></p><p><code>解决方案</code><br><code>去除空格，问题解决</code><br><a href="https://blog.csdn.net/allan_liu_/article/details/74990162" target="_blank" rel="noopener">具体解决思路</a></p><h4 id="15-android-can’t-resolve-R"><a href="#15-android-can’t-resolve-R" class="headerlink" title="(15) android:can’t resolve R"></a>(15) android:can’t resolve R</h4><p><code>原因</code><br><code>可能R文件无意删除或者其他因素</code><br><code>解决方法</code><br><code>build-&gt;rebuild(重新生成R文件)</code></p><h4 id="16-github-There-isn’t-a-GitHub-Pages-site-here"><a href="#16-github-There-isn’t-a-GitHub-Pages-site-here" class="headerlink" title="(16) github There isn’t a GitHub Pages site here."></a>(16) github There isn’t a GitHub Pages site here.</h4><p>github page 绑定域名以后，在浏览器输入域名但是出现上面错误。<br><code>原因</code><br><code>域名已经成功解析到远程主机（github page），但是因为github page绑定域名需要一个特定文件CNAME（包含域名）才能定向到github，因为我并没有创建。</code>解决方法<code></code>创建一个特定的CNAME文件，在里面加入自己的域名`</p><h4 id="17-java-net-UnknownHostException-Unable-to-resolve-host-“guolin-tech”-No-address-associated-with-hostname"><a href="#17-java-net-UnknownHostException-Unable-to-resolve-host-“guolin-tech”-No-address-associated-with-hostname" class="headerlink" title="(17) java.net.UnknownHostException: Unable to resolve host “guolin.tech”: No address associated with hostname"></a>(17) java.net.UnknownHostException: Unable to resolve host “guolin.tech”: No address associated with hostname</h4><p>在做第一行代码天气项目遇到问题<br><code>原因</code><br><code>安卓浏览器hostname不能够resolved，如果domain name没有附上的</code></p><p><a href="https://stackoverflow.com/questions/8651043/android-browser-hostnames-does-not-get-resolved-if-domain-name-is-not-appended" target="_blank" rel="noopener">具体原因</a><br><code>解决方法</code><br><code>$ ping guolin.tech,替换host域名为ip地址，例子ip为：47.90.126.26</code></p><h4 id="18-未能解决plugin-with-id-‘com-android-application’-not-found-待解决"><a href="#18-未能解决plugin-with-id-‘com-android-application’-not-found-待解决" class="headerlink" title="(18) 未能解决plugin with id ‘com.android.application’ not found$待解决"></a>(18) 未能解决plugin with id ‘com.android.application’ not found$待解决</h4><p><code>不是步骤 new--&gt;import project</code><br><code>而是步骤 new--&gt;import module</code></p><h4 id="19-插入数据库类型Date值错误"><a href="#19-插入数据库类型Date值错误" class="headerlink" title="(19)插入数据库类型Date值错误"></a>(19)插入数据库类型Date值错误</h4><ul><li>第一种情况:<br>Unknown column ‘2018-02-29’ in ‘field list’<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO product(pid,pname,market_price,shop_price,pimage,pdate,is_hot,pdesc,pflag,cid) VALUES(&quot;ghu2&quot;,&quot;12312&quot;,123.2,23.2,&quot;img/1.jpg&quot;,`2018-02-29`,0,&quot;des&quot;,0,&quot;www&quot;);</span><br></pre></td></tr></table></figure></li></ul><p><code>原因</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`2018-02-29`应该使用&apos;2018-02-29&apos;,错误使用符号</span><br></pre></td></tr></table></figure><ul><li><p>第二种情况</p><p>Incorrect date value: ‘2018-02-29’ for column ‘pdate’ at row 1</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO product(pid,pname,market_price,shop_price,pimage,pdate,is_hot,pdesc,pflag,cid) VALUES(&quot;ghu2&quot;,&quot;12312&quot;,123.2,23.2,&quot;img/1.jpg&quot;,&apos;2018-02-29&apos;,0,&quot;des&quot;,0,&quot;www&quot;);</span><br></pre></td></tr></table></figure><p><code>原因</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;2018-02-29&apos; 2018年时平年，不存在29日...</span><br></pre></td></tr></table></figure><p><code>正确答案</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO product(pid,pname,market_price,shop_price,pimage,pdate,is_hot,pdesc,pflag,cid) VALUES(&quot;ghu2&quot;,&quot;12312&quot;,123.2,23.2,&quot;img/1.jpg&quot;,&apos;1999-01-23&apos;,0,&quot;des&quot;,0,&quot;www&quot;);</span><br></pre></td></tr></table></figure><h4 id="20-ClassNotFoundException异常"><a href="#20-ClassNotFoundException异常" class="headerlink" title="(20) ClassNotFoundException异常"></a>(20) ClassNotFoundException异常</h4><ul><li><p>未导入特定<code>jar</code>包，可通过查看具体那个类的未导入声明来决定应该导入那个包</p><p><code>egg</code><img src="C:\Users\13612\Desktop\classNotfoundcase.jpg" alt="classNotfoundcase"></p></li></ul><p>即可以看出是属于javax/activation/DataSource类，然后通过Maven配置文件或者导入<code>jar</code>文件来解决</p><p><a href="https://mvnrepository.com/artifact/javax.activation/activation/1.1" target="_blank" rel="noopener">Maven</a></p><ul><li>包已经导入，但是还是出现异常，可能情况查看自己是否是<code>JAVA WEB</code>应用，如果是的话，查看是否此包正确导入到<code>lib</code>库中</li></ul><h4 id="21-MYSQL-WARN-Establishing-SSL-connection-without-server’s-identity-verification-is-not-recommended"><a href="#21-MYSQL-WARN-Establishing-SSL-connection-without-server’s-identity-verification-is-not-recommended" class="headerlink" title="(21) MYSQL:WARN: Establishing SSL connection without server’s identity verification is not recommended."></a>(21) MYSQL:WARN: Establishing SSL connection without server’s identity verification is not recommended.</h4><p><a href="https://blog.csdn.net/u010429286/article/details/77750177" target="_blank" rel="noopener">问题解决</a></p><h4 id="22"><a href="#22" class="headerlink" title="(22)"></a>(22)</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题解决&quot;&gt;&lt;a href=&quot;#问题解决&quot; class=&quot;headerlink&quot; title=&quot;问题解决&quot;&gt;&lt;/a&gt;问题解决&lt;/h3&gt;&lt;h4 id=&quot;1-导入-jar文件可执行文件与eclipse需要重写遇到did-not-contain-the-main-typ
      
    
    </summary>
    
      <category term="extension" scheme="http://log.xiaohaoming.com/categories/extension/"/>
    
    
      <category term="problem" scheme="http://log.xiaohaoming.com/tags/problem/"/>
    
      <category term="solve" scheme="http://log.xiaohaoming.com/tags/solve/"/>
    
  </entry>
  
  <entry>
    <title>模式匹配</title>
    <link href="http://log.xiaohaoming.com//2018/09/algorithm-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html"/>
    <id>http://log.xiaohaoming.com//2018/09/algorithm-模式匹配.html</id>
    <published>2018-09-25T13:57:50.747Z</published>
    <updated>2018-09-25T13:57:46.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>给定两个字符串S=$$”s_1,s_2,…s_n”$$和T =”$$t_1,t_2…t_n$$”，在主串S种寻找子串T的过程称为<strong>模式匹配</strong><code>pattern matching</code>，T称为模式<code>pattern</code>。如果匹配成功，返回T在S中的位置；如果匹配失败，返回0。</p><h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>基本思想：从主串S的第一个字符开始和模式T的第一个字符进行比较，若相等，则继续比较二者的后续字符；否则，从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直至S或T中所有字符比较完毕。若T中的字符全部比较完毕，则匹配成功，返回本地匹配的开始位置；否则匹配失败，返回0。<img src="C:\Users\13612\Desktop\md\bf_demo.png" alt="bf_demo"></p><p><strong>BF</strong>算法的伪代码描述如下</p><ul><li>在串S和串T中设置比较的起始下标 i 和 j ;</li><li>重复下述操作，直到S或T的所有字符均比较完毕。<ul><li>如果S[i] == T[j]，继续比较S和T的下一对字符</li><li>否则将下标 i 和 j 回溯，准备下一趟比较。</li></ul></li><li>如果T中所有字符均比较完，则匹配成功，返回匹配的开始位置；否则匹配失败，返回0。</li></ul><h5 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h5><p>设主串的长度为n,模式T的长度为m</p><ul><li><p>在最好的情况下，每趟不成功的匹配都发生在模式T的第m个字符。假设不成功的匹配次数为$$i-1$$,则比较的次数为$$(i-1)<em>m$$,第$$i$$躺比较的次数为$$m$$次，共比较的次数为$$i</em>m$$,</p><pre><code>所有成功匹配的位置共有$$n-m+1$$,设每次不成功的概率为$$p$$,在等概率的情况下$$\sum\limits_{i = 1}^{n-m+1} {{\frac{1}{(n-m+1)}*(i*m)}}=m\frac{(n-m+2)}{2}$$</code></pre><p>一般情况下，$$m&lt;&lt;n$$，因此最坏的情况下的时间复杂度是$$O(m*n)$$</p><p><img src="C:\Users\13612\Desktop\md\bf_bad_condition.png" alt="bf_bad_condition"></p></li></ul><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p><code>=\ 为不等于</code></p><p>造成<strong>BF</strong>算法效率低的原因是回溯，即在某躺匹配失败后，对于主串<strong>S</strong>要回溯到本躺匹配开始字符的下一个字符，模式$$T$$要回溯到第一个字符，而这些回溯往往是不必要的。如图<strong>alrotithm-bf-matching_01</strong>所示的匹配过程，在第一躺中<strong>S[0]-S[3]</strong>和<strong>T[0]-T[3]</strong>是匹配成功的，<strong>S[4]</strong>和<strong>T[4]</strong>不匹配的，因此有了第二趟。因为在第一躺中有<strong>S[1] = T[1]</strong>，而<strong>T[0] =\ T[1]</strong>，因此有<strong>T[0] =\ S[1]</strong>，所以第二趟是不必要的，同理第3躺也是不必要的，可以直接到第4躺。进一步分析第4躺中第一对字符<strong>S[3]和T[0]</strong>的比较是多余的，因为第一趟已经比较了<strong>S[3]和T[3]</strong>，并且<strong>S[3] = T[3]</strong>，而<strong>T[0] = T[3]</strong>，因此必有<strong>S[3] = T[0]</strong>，因此第四躺比较可以从第二对字符<strong>S[4]和T[1]</strong>开始进行比较。这就是说，第一趟匹配失败后，下标<strong>i</strong>不会溯，而是将下标<strong>j</strong>回溯至第2个字符，用<strong>T[1]</strong>对准<strong>S[4]</strong>进行比较。</p><p><img src="C:\Users\13612\Desktop\md\bf_demo_1.png" alt="bf_demo_1"></p><p>​                                                                              <strong>algorithm-bf-matching_01</strong></p><p><strong>综上所述，希望某躺在S[i]和T[j]匹配失败后，下标i不会溯，下标j回溯至某个位置k，使得T[k]对准S[i]继续进行比较。显然，关键问题是如何确定位置k</strong></p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p><code>基本思想:主串不进行回溯</code></p><h5 id="KMP的由来"><a href="#KMP的由来" class="headerlink" title="KMP的由来"></a>KMP的由来</h5><p><strong>由上分析可知，关键问题是如何确定位置k</strong></p><p>观察部分匹配成功时的特征,某躺在<strong>S[i]</strong>和<strong>T[j]</strong>匹配失败后，下一趟比较从<strong>S[i]</strong>和<strong>T[k]</strong>开始，则有<strong>T[0]-T[k -1] = S[i - k]-S[i -1]</strong>成立，如图<strong>algorithm-bf-matching_02(b)</strong>所示；在部分匹配成功时，有<strong>T[j - k]-K[j - 1]=S[j - k]-S[i - 1]</strong>成立，如图<strong>algorithm-bf-matching_02(a)</strong>所示</p><p>由<strong>T[0]-T[k -1] = S[i - k]-S[i -1]</strong>和<strong>T[j - k]-K[j - 1]=S[j - k]-S[i - 1]</strong>，可得</p><p>​                                                   <strong>T[0]-T[k -1] = T[j - k]-K[j - 1]</strong></p><p><img src="C:\Users\13612\Desktop\md\bd_demo_2.png" alt="bd_demo_2"></p><p>上式说明，模式中的每一个字符<strong>T[j]</strong>都对应一个<strong>k</strong>值，这个<strong>k</strong>值仅依赖于模式本身字符系列的构成，与主串无关。用<strong>next[j]</strong>表示<strong>T[j]</strong>对应的<strong>k</strong>值<strong>(0&lt;=j&lt;m)</strong>,其定义如下</p><p>$$\left{ \begin{array}{l}{\rm{-1 [round :j=0]}}\{\rm{max [round:k| 1&lt;=k&lt;j且 T[0]-T[k -1] = T[j - k]-K[j - 1]]}}\{\rm{0[round:其他情况]}}\end{array} \right.$$</p><h5 id="KMP的伪代码"><a href="#KMP的伪代码" class="headerlink" title="KMP的伪代码"></a>KMP的伪代码</h5><ul><li>在串S和串T中分别设置比较的起始下标 i 和 j ;</li><li>重复下述操作，直到所有S或T的所有字符均比较完毕；<ul><li>如果S[i]等于T[j]，继续比较S和T的下一对字符；</li><li>否则将下标 j 回溯到next[j]位置，即 j = next[j]；</li><li>如果 j 等于-1，则将下标 i 和 j 分别加1，准备下一趟比较</li></ul></li><li>如果T中所有的字符均比较完毕，则返回匹配的开始位置；否则返回0；</li></ul><h5 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pattern_matching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KMPIndex</span><span class="params">(<span class="keyword">char</span>[] S,<span class="keyword">char</span>[] T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>,n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sLen = S.length;</span><br><span class="line">        <span class="keyword">int</span> tLen = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(T);</span><br><span class="line">        <span class="keyword">while</span> (m &lt; sLen &amp;&amp; n &lt; tLen)&#123;</span><br><span class="line">            <span class="comment">//S[m] == T[n]</span></span><br><span class="line">            <span class="comment">//j==-1说明在之前匹配中不存在可匹配部分字符</span></span><br><span class="line">            <span class="comment">//直接m向前偏移一位，j重新从0匹配</span></span><br><span class="line">            <span class="keyword">if</span>(n == -<span class="number">1</span> || S[m] == T[n])</span><br><span class="line">            &#123;</span><br><span class="line">                ++ m;</span><br><span class="line">                ++ n;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n = next[n];</span><br><span class="line">                <span class="comment">//n = next[m];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == tLen)</span><br><span class="line">            <span class="keyword">return</span> m - n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] T_)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next_ = <span class="keyword">null</span>;</span><br><span class="line">        next_[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//T_.length</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; T_.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == -<span class="number">1</span> &amp;&amp; T_[k] == T_[j])&#123;</span><br><span class="line">                ++ k;</span><br><span class="line">                ++ j;</span><br><span class="line">                next_[j] = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = next_[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] S = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] T = &#123;<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k = BF.bfIndex(S , T);</span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span>)</span><br><span class="line">            System.out.println(<span class="string">"pattern matching is failure"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"pattern matching is successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p><code>假设模式T为“ababaab”</code></p><p><code>next_[]代表存储字符数组，next[]代表存储匹配值数组</code></p><ul><li><p>为什么不用计算next[7]?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码错误片段</span></span><br><span class="line"><span class="comment">//T_.length</span></span><br><span class="line"><span class="keyword">while</span>(j &lt; T_.length - <span class="number">1</span>)&#123;</span><br></pre></td></tr></table></figure><p><strong>答：在最后一个字符匹配失败时，在前面六个字符中寻找最大匹配，此时最大匹配值放在next[6]里面，所以并不存在计算next[7]</strong></p></li><li><p>为什么用next[k]=k?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = next_[k];</span><br></pre></td></tr></table></figure><p><strong>答：</strong></p><p><code>在寻找next[6]匹配时，此时k=3,j=5。因为next_[5]!=next_[3]的，所以next[6]不是next[5]的简单加1，即next[6]=next[5]+1。</code></p><p><img src="C:\Users\13612\Desktop\md\bf_demo_3.png" alt="bf_demo_3"></p><p><code>我们知道next_[0]next_[1]next_[2]=next_[2]next_[3]next_[4]，如图alrotithm_bf_matching_04所示。next[6]在失配时最大的值为next[6]=3,即next_[0]next_[1]next_[2]=next_[4]next_[5]next_[6]情况，这样要满足什么情况下呢？</code></p><p><img src="C:\Users\13612\Desktop\md\bf_demo_4.png" alt="bf_demo_4"></p><p>**<code>显然，一定要存在，next_[0]next_[1]=next_[4]next_[5]，又因为next_[1]next_[2]=next_[4]next_[5]。即满足next_[0]next_[1]=next_[1]next_[2]。可知，这即是next[k]=next[3]所代表的值；然后只需在判断next_[2]是否等于next_[6]，由k=next_[k]下一次循环判断若相等，既可判断next_[0]next_[1]next_[2]</code></p><p><strong><code>=next_[4]next_[5]next_[6]相等。同理，next[6]在失配时次大，次次大的值为2,1也可以通过这样判断。</code></strong></p></li></ul><p>  <strong><code>综上所述，我们可以通过判断k=next[k]的值，可知在next[6]失配时，即next_[5]!=next_[3]情况下，存在的next[6]最大值。</code></strong></p><p>  <code>任意情况下可通过上面方法判断</code></p><h5 id="算法复杂度-1"><a href="#算法复杂度-1" class="headerlink" title="算法复杂度"></a>算法复杂度</h5><p>(文本字符串不回溯)文本串的长度为n,模式串长度为m，匹配过程时间复杂度为o(n),算上计算next数组的o(m)时间，KMP的整体时x间复杂度为o(m+n) </p><h5 id="扩展算法"><a href="#扩展算法" class="headerlink" title="扩展算法"></a>扩展算法</h5><h6 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h6><p>BM算法定义了两个规则：</p><ul><li>坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们成文本串中的这个失配字符为坏字符，此时模式串需要 向右移动。（移动的位数=坏字符在模式串中的位置-坏字符在模式串中最有出现的位置）此时，如果‘坏字符’不包含在模式串之中，则最有出现位置为-1。</li><li><p>好后缀规则：当字符失配时，后移位置=（最大）好后缀在模式串中的位置-好后缀在模式串上一次出现的位置，且如果好后缀在模式串 中没有出现，则为-1</p><p>   时间复杂度在最坏的情况下能够保持o(n)</p></li></ul><h6 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h6><p>Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似，不过Sunday算法时从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符</p><ul><li>如果该字符没有在模式串中出现则直接跳过，即移动位数=匹配串长度+1</li><li>否则，其移动位数=模式串中最右端的该字符到末尾的距离+1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;模式匹配&quot;&gt;&lt;a href=&quot;#模式匹配&quot; class=&quot;headerlink&quot; title=&quot;模式匹配&quot;&gt;&lt;/a&gt;模式匹配&lt;/h3&gt;&lt;p&gt;给定两个字符串S=$$”s_1,s_2,…s_n”$$和T =”$$t_1,t_2…t_n$$”，在主串S种寻找子串T的过程
      
    
    </summary>
    
      <category term="algorithm" scheme="http://log.xiaohaoming.com/categories/algorithm/"/>
    
    
      <category term="kmp" scheme="http://log.xiaohaoming.com/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="http://log.xiaohaoming.com//2018/09/api-StringStringBufferStringBuilder%E5%8C%BA%E5%88%AB.html"/>
    <id>http://log.xiaohaoming.com//2018/09/api-StringStringBufferStringBuilder区别.html</id>
    <published>2018-09-25T13:56:28.532Z</published>
    <updated>2018-09-25T13:56:25.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="String-StringBuffer-StringBuilder区别"><a href="#String-StringBuffer-StringBuilder区别" class="headerlink" title="String StringBuffer StringBuilder区别"></a>String StringBuffer StringBuilder区别</h3><ul><li><p><code>String</code>使不可变的<a href="修改String时，不会在原有的内存地址修改，而是重新指向一个新对象">^1</a> ；<code>String</code>用<code>final</code>修饰，不可继承；<code>String</code>本质上是一个<code>final</code>的<code>char[]</code>数组，所以<code>char[]</code>数组的内存地址不会被修改，而且<code>String</code>也没有暴露修改<code>char[]</code>数组的方法；不可变性可以保证线程安全以及字符串常量池的实现；频繁的增删操作是不建议使用<code>String</code>的</p></li><li><p><code>StringBuffer</code>是线程安全的，多线程建议使用这个</p></li><li><p><code>StringBuffer</code>是非线程安全的，单线程使用这个更快</p></li></ul><ul><li><code>String StringBuffer StringBuilder</code>最终底层存储于操作的都是<code>char</code>数组.但是<code>String</code>里面的<code>char</code>数组是<code>final</code>的，而<code>StringBuffer StringBuilder</code>不是，也就是说<code>String</code>是不可变的，想要新的字符串智能重新生成<code>String</code>。而<code>StringBuffer StringBuilder</code>只需要修改底层的<code>char</code>数组就行。相对来说，开销要小很多。</li><li><code>String</code>的大多数方法都是重新<code>new</code>一个新<code>String</code>对象返回，频繁重新生成容易生成很多垃圾</li><li><code>StringBuffer</code>是线程安全的，<code>StringBuffer</code>是非线程安全的，因为<code>StringBuffer</code>的方法是加了<code>synchronized</code>锁起来的，而<code>StringBuilder</code>没有</li></ul><p>[参考引用]</p><p>你知道String、StringBuffer和StringBuilder之间的区别吗？ -<a href="https://mp.weixin.qq.com/s/6mNH4re2wDrp49gTPVMMtw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6mNH4re2wDrp49gTPVMMtw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;String-StringBuffer-StringBuilder区别&quot;&gt;&lt;a href=&quot;#String-StringBuffer-StringBuilder区别&quot; class=&quot;headerlink&quot; title=&quot;String StringBuffer St
      
    
    </summary>
    
      <category term="api" scheme="http://log.xiaohaoming.com/categories/api/"/>
    
    
      <category term="api" scheme="http://log.xiaohaoming.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://log.xiaohaoming.com//2018/09/deploy-Redis.html"/>
    <id>http://log.xiaohaoming.com//2018/09/deploy-Redis.html</id>
    <published>2018-09-25T13:55:48.486Z</published>
    <updated>2018-09-25T13:55:48.486Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Redis控制五种数据类型"><a href="#Redis控制五种数据类型" class="headerlink" title="Redis控制五种数据类型"></a>Redis控制五种数据类型</h4><ul><li><code>string</code></li><li><code>list</code></li><li><code>hash</code></li><li><code>set</code></li><li><code>sorted-set</code></li></ul><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:set &lt;key&gt; &lt;value&gt;</span><br><span class="line">eg:</span><br><span class="line">set name xiao</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:del &lt;key&gt; </span><br><span class="line">eg:</span><br><span class="line">del name</span><br></pre></td></tr></table></figure><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:get &lt;key&gt;</span><br><span class="line">eg:</span><br><span class="line">get name</span><br></pre></td></tr></table></figure><h4 id="查看有多少个元素"><a href="#查看有多少个元素" class="headerlink" title="查看有多少个元素"></a>查看有多少个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">keys *</span><br></pre></td></tr></table></figure><h4 id="选择仓库"><a href="#选择仓库" class="headerlink" title="选择仓库"></a>选择仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:select &lt;数字&gt;</span><br><span class="line">eg:</span><br><span class="line">select 1 #选择一号仓库，默认为0号仓库，总共为16个仓库</span><br></pre></td></tr></table></figure><h4 id="移动键值对到另外仓库"><a href="#移动键值对到另外仓库" class="headerlink" title="移动键值对到另外仓库"></a>移动键值对到另外仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:move &lt;key&gt; &lt;数字&gt;</span><br><span class="line">eg:</span><br><span class="line">move name 1</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h5 id="测试连接是否存活"><a href="#测试连接是否存活" class="headerlink" title="测试连接是否存活"></a>测试连接是否存活</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">ping #如果响应为PONG，则说明连接存活</span><br><span class="line">eg</span><br><span class="line">echo zhangsan #在命令行打印一些东西</span><br></pre></td></tr></table></figure><h4 id="返回当前数据库中key的数目"><a href="#返回当前数据库中key的数目" class="headerlink" title="返回当前数据库中key的数目"></a>返回当前数据库中key的数目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">dbsize</span><br></pre></td></tr></table></figure><h4 id="删除当前选择数据库中的所有key"><a href="#删除当前选择数据库中的所有key" class="headerlink" title="删除当前选择数据库中的所有key"></a>删除当前选择数据库中的所有key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">flushdb</span><br></pre></td></tr></table></figure><h4 id="删除所有数据库中的所有key"><a href="#删除所有数据库中的所有key" class="headerlink" title="删除所有数据库中的所有key"></a>删除所有数据库中的所有key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Redis控制五种数据类型&quot;&gt;&lt;a href=&quot;#Redis控制五种数据类型&quot; class=&quot;headerlink&quot; title=&quot;Redis控制五种数据类型&quot;&gt;&lt;/a&gt;Redis控制五种数据类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="deploy" scheme="http://log.xiaohaoming.com/categories/deploy/"/>
    
    
      <category term="api" scheme="http://log.xiaohaoming.com/tags/api/"/>
    
      <category term="redis" scheme="http://log.xiaohaoming.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://log.xiaohaoming.com//2018/09/extension-Linux%E5%91%BD%E4%BB%A4.html"/>
    <id>http://log.xiaohaoming.com//2018/09/extension-Linux命令.html</id>
    <published>2018-09-25T13:54:17.416Z</published>
    <updated>2018-09-25T13:54:17.416Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: linux命令<br>categories:</p><ul><li>extension<br>tags:</li><li>orders</li></ul><p>photos:</p><ul><li><a href="http://cn.bing.com/az/hprichbg/rb/Gauchos_EN-US9437338004_1920x1080.jpg" target="_blank" rel="noopener">http://cn.bing.com/az/hprichbg/rb/Gauchos_EN-US9437338004_1920x1080.jpg</a></li></ul><hr><h2 id="Centos6-7"><a href="#Centos6-7" class="headerlink" title="Centos6.7"></a>Centos6.7</h2><h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><blockquote><p>Note: linux有两种用户，一种管理员root，另外一种普通用户xx.</p><p>root用户登陆到linux默认所在的目录是 /root/</p><p>其他用户xx登陆到linux默认所在的目录是 /home/xx/</p></blockquote><h4 id="查询目前所在目录"><a href="#查询目前所在目录" class="headerlink" title="查询目前所在目录"></a>查询目前所在目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pwd</span><br></pre></td></tr></table></figure><h4 id="获取本地IP地址"><a href="#获取本地IP地址" class="headerlink" title="获取本地IP地址"></a>获取本地IP地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig</span><br></pre></td></tr></table></figure><h4 id="在当前目录下创建一个文件"><a href="#在当前目录下创建一个文件" class="headerlink" title="在当前目录下创建一个文件"></a>在当前目录下创建一个文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># touch xiao.txt # 在当前目录创建一个 xiao.txt 文件</span><br></pre></td></tr></table></figure><h4 id="清除屏幕"><a href="#清除屏幕" class="headerlink" title="清除屏幕"></a>清除屏幕</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># clear # 清除屏幕</span><br></pre></td></tr></table></figure><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ps -ef </span><br><span class="line"># ps -ef | grep -i crond 查看系统中crond的进程信息</span><br></pre></td></tr></table></figure><h4 id="查看本机上所有已经安装成功的软件和特定软件"><a href="#查看本机上所有已经安装成功的软件和特定软件" class="headerlink" title="查看本机上所有已经安装成功的软件和特定软件"></a>查看本机上所有已经安装成功的软件和特定软件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rpm -qa </span><br><span class="line"># rpm -qa | grep java #只查看和java相关的</span><br></pre></td></tr></table></figure><h4 id="删除软件"><a href="#删除软件" class="headerlink" title="删除软件"></a>删除软件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps &lt;软件包&gt; #</span><br><span class="line">eg:</span><br><span class="line"># rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686 #</span><br></pre></td></tr></table></figure><h4 id="查看本机开放的端口号"><a href="#查看本机开放的端口号" class="headerlink" title="查看本机开放的端口号"></a>查看本机开放的端口号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/iptables status</span><br></pre></td></tr></table></figure><h4 id="防火墙打开特定端口"><a href="#防火墙打开特定端口" class="headerlink" title="防火墙打开特定端口"></a>防火墙打开特定端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">8080端口</span><br><span class="line"># /sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</span><br><span class="line"># /etc/rc.d/init.d/iptables save  #存储设置</span><br></pre></td></tr></table></figure><h4 id="查询特定服务运行状态"><a href="#查询特定服务运行状态" class="headerlink" title="查询特定服务运行状态"></a>查询特定服务运行状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"># service mysql status #查询mysql服务运行状态</span><br></pre></td></tr></table></figure><h4 id="加入系统服务并自动启动"><a href="#加入系统服务并自动启动" class="headerlink" title="加入系统服务并自动启动"></a>加入系统服务并自动启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig --add mysql #加入系统服务</span><br><span class="line"># chkconfig mysql on #自动启动</span><br><span class="line"># chkconfig #查询列表</span><br></pre></td></tr></table></figure><h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><h5 id="list命令-查看目录结构"><a href="#list命令-查看目录结构" class="headerlink" title="list命令 - 查看目录结构"></a>list命令 - 查看目录结构</h5><ul><li><p>ls <code>list</code> 功能： 列出目录内容</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式: ls [参数] [文件或者目录]</span><br></pre></td></tr></table></figure></li></ul><p>【参数】<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-a 或 #all 列出所有的文件或者目录。包括隐藏文件，特殊目录</span><br><span class="line">-l 使用详细格式列表</span><br></pre></td></tr></table></figure></p><ul><li>常用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ls -l</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ls -al</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ls /bin 列出根目录下bin目录下的文件信息</span><br></pre></td></tr></table></figure><p>更多内容，参考入门文档 </p><blockquote><p>Note: 在文件前缀符<code>.</code> 意味着这是隐藏文件 :artificial_satellite:</p></blockquote><p><img src="C:\Users\13612\Desktop\md\linux_command_mark_001.jpg" alt="linux_command_mark_001"></p><h5 id="cd命令-切换目录命令"><a href="#cd命令-切换目录命令" class="headerlink" title="cd命令 - 切换目录命令"></a>cd命令 - 切换目录命令</h5><ul><li>cd <code>change directory</code> </li><li>语法 cd [目录]</li><li>常用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cd ~ 当前用户目录</span><br><span class="line"># cd / 根目录</span><br><span class="line"># cd - 上一次访问的目录</span><br><span class="line"># cd .. 上一级目录</span><br><span class="line"># cd 缺省当前用户目录</span><br></pre></td></tr></table></figure><h5 id="pwd命令-显示当前目录"><a href="#pwd命令-显示当前目录" class="headerlink" title="pwd命令 - 显示当前目录"></a>pwd命令 - 显示当前目录</h5><p><code>print working directory</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pwd</span><br></pre></td></tr></table></figure><h5 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir - 创建目录"></a>mkdir - 创建目录</h5><p><code>make directory</code></p><p>-p 父目录不存在的情况下先生成父目录 【parent】</p><p>-v 显示命令执行过程中的详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkdir -pv ./xiao/ming</span><br></pre></td></tr></table></figure><h5 id="文件管理-文件浏览"><a href="#文件管理-文件浏览" class="headerlink" title="文件管理 - 文件浏览"></a>文件管理 - 文件浏览</h5><h6 id="cat命令-显示文本文件内容"><a href="#cat命令-显示文本文件内容" class="headerlink" title="cat命令 - 显示文本文件内容"></a>cat命令 - 显示文本文件内容</h6><p><code>catenate</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd 回到根目录</span><br><span class="line"># cat install.log 显示根目录下的日志文件内容</span><br></pre></td></tr></table></figure><blockquote><p>Note: cat不适合文件内容太多的情况，应该选择more命令</p></blockquote><h6 id="more命令-分页显示文件内容，还支持直接跳转行等功能"><a href="#more命令-分页显示文件内容，还支持直接跳转行等功能" class="headerlink" title="more命令 - 分页显示文件内容，还支持直接跳转行等功能"></a>more命令 - 分页显示文件内容，还支持直接跳转行等功能</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">###### more file #语法</span><br><span class="line">enter #向下n行，需要定义，默认一行</span><br><span class="line">空格键 #向下滚动一屏或ctrl + F</span><br><span class="line">B #返回上一屏 或 ctrl + B</span><br><span class="line">q #退出more</span><br><span class="line">eg:</span><br><span class="line">###### more /root/install.log</span><br></pre></td></tr></table></figure><blockquote><p>Note: 按 tab 键有自动补齐功能</p></blockquote><h6 id="less命令-分页显示文件内容，操作更详细"><a href="#less命令-分页显示文件内容，操作更详细" class="headerlink" title="less命令 - 分页显示文件内容，操作更详细"></a>less命令 - 分页显示文件内容，操作更详细</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">less [参数] 文件 #语法</span><br><span class="line">-m #显示类似more命令的百分比</span><br><span class="line">-n #显示每行的行号</span><br><span class="line">操作：</span><br><span class="line">       #覆盖了more的所有操作</span><br><span class="line">/字符串 #向下搜索字符串</span><br><span class="line">?字符串 #向上搜索字符串</span><br><span class="line">u  # 后退半页</span><br><span class="line">d  # 前进半页</span><br><span class="line">y  # 后退一行</span><br></pre></td></tr></table></figure><h6 id="tail命令-用于显示指定文件末尾的内容"><a href="#tail命令-用于显示指定文件末尾的内容" class="headerlink" title="tail命令 - 用于显示指定文件末尾的内容"></a>tail命令 - 用于显示指定文件末尾的内容</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail [必要参数][选择参数][文件]  #语法</span><br><span class="line">-n #显示行数 #必要参数</span><br><span class="line">tail -f 循环读取 #选择参数</span><br></pre></td></tr></table></figure><h5 id="文件管理-文件操作"><a href="#文件管理-文件操作" class="headerlink" title="文件管理 - 文件操作"></a>文件管理 - 文件操作</h5><h6 id="cp命令-复制文件或目录"><a href="#cp命令-复制文件或目录" class="headerlink" title="cp命令 - 复制文件或目录"></a>cp命令 - 复制文件或目录</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Syntax: cp [参数] [源文件或目录] [目标文件或目录]</span><br><span class="line">-r 或 #recursive 递归处理。将指定目录下的文件与子目录一并处理</span><br><span class="line">Note:</span><br><span class="line">#复制目录</span><br><span class="line">cp ./abc ./xxx #无法复制目录</span><br><span class="line">cp -r ./abc ./xxx #复制目录必须使用-r参数</span><br><span class="line">eg:</span><br><span class="line">#复制文件</span><br><span class="line">cd /root/</span><br><span class="line">cp install.log install01.log #复制文件install.log到当前目录下的install01.log</span><br><span class="line">cp -b install.log 01.log # -b参数当复制时如果在当前目录存在01.log，备份这个文件为01.log~</span><br><span class="line">cp ./install.log ../install.log #将当前目录的install.log复制到父目录的install.log</span><br></pre></td></tr></table></figure><h6 id="mv命令-移动或更名现有文件或目录"><a href="#mv命令-移动或更名现有文件或目录" class="headerlink" title="mv命令 - 移动或更名现有文件或目录"></a>mv命令 - 移动或更名现有文件或目录</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Syntax: mv [源文件或目录][目标文件或目录]</span><br><span class="line">-f或--force 若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录</span><br><span class="line">eg:</span><br><span class="line">#既可以做剪切又可以做重命名</span><br><span class="line">mv ./a.txt ./b/b.txt</span><br></pre></td></tr></table></figure><h6 id="rm命令-删除文件或目录"><a href="#rm命令-删除文件或目录" class="headerlink" title="rm命令 - 删除文件或目录"></a>rm命令 - 删除文件或目录</h6><p><code>remove</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Syntax: rm [-dfirv][--help][--version][文件或目录]</span><br><span class="line">-f或--force 强制删除文件或目录</span><br><span class="line">-r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理</span><br><span class="line">eg:</span><br><span class="line">#删除文件</span><br><span class="line">rm -f install01.log  #-f 强制删除</span><br><span class="line">rm install01.log #提示</span><br><span class="line">#删除目录</span><br><span class="line">rm -f ./a #强制删除目录,不可行</span><br><span class="line">rm -rf ./a #强制删除目录，需要加上-r参数</span><br></pre></td></tr></table></figure><h6 id="find命令-查找文件或目录"><a href="#find命令-查找文件或目录" class="headerlink" title="find命令 - 查找文件或目录"></a>find命令 - 查找文件或目录</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax find [目录 ...][参数]</span><br><span class="line">-name 指定字符串作为寻找文件或目录的范本样式</span><br><span class="line">eg:</span><br><span class="line">find /root/ -name &apos;in*&apos; #在根目录下寻找名称中包含in而且是以in开头的文件或者目录</span><br></pre></td></tr></table></figure><h6 id="vi或vim命令"><a href="#vi或vim命令" class="headerlink" title="vi或vim命令"></a>vi或vim命令</h6><p>vim基本概念</p><ul><li><p>基本上vi可以分为三种状态。分别是命令行模式<code>command mode</code>,插入模式<code>insert mode</code>和底行模式<code>last line mde</code></p><ul><li><p>命令行模式</p><p>控制屏幕光标的移动，字符，字或者行的删除，移动复制某区段及进入<code>insert mode</code>下，或者到<code>last line mode</code>。</p></li><li><p>插入模式</p><p>只有在插入模式下，才可以做文字输入。按<code>Esc</code>键可以回到命令行模式</p></li><li><p>底行模式</p><p>将文件保存或退出vi，也可以设置编辑环境。如寻找字符串，列出行号</p></li></ul></li><li><p>[x] 输入<code>syntax: vim 文件名</code>进入一般模式</p></li><li>[x] 按下<code>i</code>从一般模式进入插入模式</li><li>[x] 按下<code>esc</code>从插入模式退出到一般模式</li><li>[x] 在一般模式下，输入<code>:wq</code>，退出编辑</li></ul><h5 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h5><h6 id="grep命令-全局正则表达式"><a href="#grep命令-全局正则表达式" class="headerlink" title="grep命令 - 全局正则表达式"></a>grep命令 - 全局正则表达式</h6><p><code>Global Regular Expression Print</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: 用于过滤/搜素特定字符</span><br><span class="line">Syntax: grep [option] pattern [file]</span><br><span class="line">-i 或 --ignore-case #忽略字符大小写的差别</span><br><span class="line">egg:</span><br><span class="line">grep -i mysql /root/install.log</span><br></pre></td></tr></table></figure><h6 id="kill功能-删除执行中的程序或工作"><a href="#kill功能-删除执行中的程序或工作" class="headerlink" title="kill功能 - 删除执行中的程序或工作"></a>kill功能 - 删除执行中的程序或工作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Syntax: kill [参数][程序]</span><br><span class="line">-l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称</span><br><span class="line">kill -9 #表示强制终止</span><br><span class="line">eg:</span><br><span class="line">ps ef #列出所有进程</span><br><span class="line">kill -9 4199 #表示强制终止UID为4199的进程</span><br></pre></td></tr></table></figure><h6 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: 测试与目标主机的连通性</span><br><span class="line">Syntax：ping 主机名或ip地址</span><br><span class="line">eg:</span><br><span class="line">ping 127.0.0.1 测试本机连通性</span><br><span class="line">% 按ctrl+c退出ping</span><br></pre></td></tr></table></figure><h6 id="tar命令-压缩解压缩"><a href="#tar命令-压缩解压缩" class="headerlink" title="tar命令 - 压缩解压缩"></a>tar命令 - 压缩解压缩</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Syntax: 文件备份压缩</span><br><span class="line">语法: tar命令</span><br><span class="line">-c `create` 建立一个压缩文件的参数指令 --压缩</span><br><span class="line">-x `extract` 解开一个压缩文件的参数指令 --解压</span><br><span class="line">-z 是否需要用gzip压缩</span><br><span class="line">-v `verbose`压缩过程中显示文件</span><br><span class="line">-f `file`使用档名,在f之后要立即接档名</span><br><span class="line">常用参数组合</span><br><span class="line">解压缩  zxvf</span><br><span class="line">压缩    zcvf</span><br><span class="line">eg:</span><br><span class="line">tar zxvf ./xxx.tar #解压当前目录下的./xxx.tar</span><br></pre></td></tr></table></figure><h6 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Linux centos重启命令</span><br><span class="line">eg:</span><br><span class="line">reboot</span><br><span class="line">Linux centos关机命令</span><br><span class="line">eg:</span><br><span class="line">halt</span><br></pre></td></tr></table></figure><h5 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h5><h6 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Usage: 变更文件或目录的权限</span><br><span class="line">Syntax: chmod [参数] [&lt;权限范围&gt;&lt;符号&gt;&lt;权限代号&gt;]</span><br><span class="line">权限范围表示法：</span><br><span class="line">u `User`文件或目录的拥有者</span><br><span class="line">g `Group`文件或目录的所属群组</span><br><span class="line">o `Other`除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围</span><br><span class="line">a `All` 即全部的用户，包含拥有者，所属群组以及其他用户</span><br><span class="line">符号：</span><br><span class="line">+ 添加权限</span><br><span class="line">- 取消权限</span><br><span class="line">有关权限代号部分：</span><br><span class="line">r 读取权限，数字代号为4</span><br><span class="line">w 写入权限，数字代号为2</span><br><span class="line">x 执行或切换权限，数字代号为1</span><br><span class="line">- 不具任何权限，数字代号为0</span><br><span class="line">eg:</span><br><span class="line">mkdir xxx</span><br><span class="line">ll | grep xxx</span><br><span class="line">chmod u-rwx xxx #取消xxx目录，用户&quot;读写执行&quot;权限</span><br><span class="line">chmod g-rwx xxx #取消xxx目录，组&quot;读写执行&quot;权限</span><br><span class="line">chmod 777 xxx #给xxx目录添加所有权限</span><br></pre></td></tr></table></figure><p><img src="C:\Users\13612\Desktop\md\permission.jpg" alt="permission"></p><h6 id="Linux权限格式-lt-类型-gt-lt-用户-gt-lt-组-gt-lt-其他用户-gt"><a href="#Linux权限格式-lt-类型-gt-lt-用户-gt-lt-组-gt-lt-其他用户-gt" class="headerlink" title="Linux权限格式 &lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt;"></a>Linux权限格式 &lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt;</h6><p> -rwxrw-r–</p><ul><li>第一位： 【文件类型  d：目录，-：普通文件，|：链接文件】</li><li>第二至四位 【所属用户权限，用<code>u(user)</code>表示】</li><li>第五至七位 【所属组权限，用<code>g(group)</code>表示】</li><li>第八至十位 【其他用户权限，用<code>o(other)</code>表示】</li><li>第二至十位 【表示所有权限，用<code>a(all)</code>表示】</li></ul><h5 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h5><h6 id="查看各个命令的参数"><a href="#查看各个命令的参数" class="headerlink" title="查看各个命令的参数"></a>查看各个命令的参数</h6><p>Linux命令</p><ul><li>内部命令：Linux系统核心命令，等价于windows <code>dir</code>等命令</li><li>外部命令：后来加入的命令，等价于windows <code>java</code>等命令</li></ul><p>查看内部命令帮助文档方式 help + 命令</p><p>查看外部命令帮助文档方式 man + 命令</p><h2 id="KaLi"><a href="#KaLi" class="headerlink" title="KaLi"></a>KaLi</h2><h6 id="TCP端口扫描工具Namp"><a href="#TCP端口扫描工具Namp" class="headerlink" title="TCP端口扫描工具Namp"></a>TCP端口扫描工具Namp</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"># nmap 192.168.41.136 #查看目标主机开放Tcp端口</span><br></pre></td></tr></table></figure><h6 id="打开SSH服务"><a href="#打开SSH服务" class="headerlink" title="打开SSH服务"></a>打开SSH服务</h6><p><a href="https://blog.csdn.net/qq_37458055/article/details/75205282" target="_blank" rel="noopener">点我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: linux命令&lt;br&gt;categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;extension&lt;br&gt;tags:&lt;/li&gt;
&lt;li&gt;orders&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;photos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://cn.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文本组件</title>
    <link href="http://log.xiaohaoming.com//2018/09/api-JTextComponent.html"/>
    <id>http://log.xiaohaoming.com//2018/09/api-JTextComponent.html</id>
    <published>2018-09-25T13:51:24.234Z</published>
    <updated>2018-09-25T13:51:21.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JTextComponent"><a href="#JTextComponent" class="headerlink" title="JTextComponent"></a><a href="https://docs.oracle.com/javase/tutorial/uiswing/components/generaltext.html" target="_blank" rel="noopener">JTextComponent</a></h3><p><strong>descendants</strong> <code>子孙,后代</code></p><p><strong>JTextComponent</strong>类是<strong>Swing</strong>位文本模块基础。这个类为它的所有子孙后代提供下述习惯化特征</p><ul><li><strong>model</strong>，也叫做<strong>document</strong>，管理组件内容</li><li><strong>view</strong>，在屏幕上展示组件</li><li><strong>controller</strong>，也叫做<strong>editor kit</strong>，阅读和写文本和实现<strong>actions</strong>编辑兼容</li><li><strong>插件式光标</strong><code>caret</code>和支持光标改变监听器和导航过滤器</li></ul><h4 id="关于Documents"><a href="#关于Documents" class="headerlink" title="关于Documents"></a>关于Documents</h4><p>文本组件是<strong>Model</strong>和<strong>View</strong>分离，可以查看<a href="https://docs.oracle.com/javase/tutorial/uiswing/components/model.html" target="_blank" rel="noopener">Using Models</a>参考</p><p>文本组件<strong>Model</strong>是被叫做<strong>document</strong>和实现了<strong>Document</strong>接口的实例。一个<strong>document</strong>为文本组件提供下述服务。</p><ul><li><strong>document</strong>在<strong>Element</strong>对象储存文本内容。</li><li>通过<strong>remove</strong>和<strong>insertString</strong>方法提供编辑文本支持</li><li>通知文本监听器和撤销编辑监听器关于文本的改变</li><li>管理追踪在文本中即使被修改了的特殊的位置的<strong>Position</strong>对象</li><li>承诺你获得文本信息</li></ul><p><strong>Swing</strong>包含<strong>Document</strong>子接口<code>eg:StyledDocumentd等</code>。一般<code>JTextComponent</code>子类默认请求<strong>StyledDocument</strong></p><p>详情请看<strong>document</strong>类<a href="https://docs.oracle.com/javase/tutorial/uiswing/components/generaltext.html#bindingkeystrokes" target="_blank" rel="noopener">继承关系</a></p><p>如果你使用<strong>setPage</strong>方法来加载文本到<strong>editor</strong>板或者<strong>text板</strong>，<strong>document</strong>实例被<strong>pane</strong>使用可能会改变。请看<a href="https://docs.oracle.com/javase/tutorial/uiswing/components/editorpane.html" target="_blank" rel="noopener">How to Use Editor Panes and Text Panes</a></p><p>你能通过安装一个<strong>document filter</strong>或者代替文本组件的<strong>document</strong>来实现你自己习惯化的事物。<code>eg:使用document filter来改变如何文本组件数据被设置</code></p><p>查看简单的<a href="https://docs.oracle.com/javase/tutorial/uiswing/components/generaltext.html#bindingkeystrokes" target="_blank" rel="noopener">Implementing a Document Filter</a>代码片段</p><h4 id="关于Editor-Kits"><a href="#关于Editor-Kits" class="headerlink" title="关于Editor Kits"></a>关于Editor Kits</h4><p>文本组件使用<strong>EditorKit</strong>来绑定不同片段的文本组件。<strong>EditorKit</strong>提供<strong>view factory</strong>,<strong>document</strong>,<strong>caret</strong>,<strong>actions</strong>。一个<strong>editor kit</strong>也阅读和写特殊格式的<strong>document</strong>。所有的文本组件使用<strong>editor kit</strong>，<strong>Editor panes</strong>和<strong>text panes</strong>提供<strong>getEditorKit</strong>方法获得目前<strong>Editor kit</strong>和<strong>setEditorKit</strong>方法来改变它。</p><p><strong>JTextComponent</strong>类提供<strong>API</strong>帮助你直接调用或者习惯化一些<strong>Editor kit</strong>能力。例如，<strong>JTextComponent</strong>提供调用<strong>editor kit</strong>的<strong>read</strong>和<strong>write</strong>的<strong>read</strong>和<strong>write</strong>的方法；也是提供返回所有被该组件支持的<strong>actions</strong>通过<strong>getActions</strong>.</p><p><strong>Swing</strong>文本包提供下述的<strong>editor kits</strong></p><p><strong>DefaultEditorKit</strong></p><p><strong>StyledEditorKit</strong></p><p><strong>HtmlEditorKit</strong></p><p>每一个<strong>editor kit</strong>列举在上面的已经被<strong>JEditorPane</strong>注册和联系<strong>kit</strong>阅读,写和编辑的文本格式。当一个文件被加载到<strong>EditorPane</strong>，这个板依靠注册<strong>kit</strong>检查文件格式。如果注册<strong>kit</strong>是发现支持这个文件格式，<strong>pane</strong>使用这个<strong>kit</strong>来阅读文件，展示和编辑它。那么，<strong>editor pane</strong>有效率的转换它自己到符合文本格式的<strong>editor</strong>。</p><p><strong>你能够继承JEditorPane</strong>来支持你自己文本格式通过为它创造一个<strong>editor kit</strong>，和使用<code>JEditorPane</code>‘s <code>registerEditorKitForContentType</code> 来联系你的文本格式的<strong>kit</strong></p><h4 id="TextComponentDemo"><a href="#TextComponentDemo" class="headerlink" title="TextComponentDemo"></a><a href="https://docs.oracle.com/javase/tutorial/uiswing/examples/components/index.html" target="_blank" rel="noopener">TextComponentDemo</a></h4><p><a href="https://docs.oracle.com/javase/tutorial/uiswing/components/generaltext.html#bindingkeystrokes" target="_blank" rel="noopener">联系文本组件例子扩展的知识点</a></p><h5 id="Associating-Text-Actions-with-menus-and-Buttons"><a href="#Associating-Text-Actions-with-menus-and-Buttons" class="headerlink" title="Associating Text Actions with menus and Buttons"></a><strong>Associating Text Actions with menus and Buttons</strong></h5><p>所有的文本组件支持标准得编辑命令，例如 <strong>Cut,Paste,Insert</strong>字符命令。每个编辑命令是通过<strong>Action</strong>对象表示和实现。学习更多关于<a href="https://docs.oracle.com/javase/tutorial/uiswing/misc/action.html" target="_blank" rel="noopener">Actions</a>。<strong>Actions</strong>承诺联系命令和<strong>GUI</strong>组件，例如菜单项和按钮。</p><ol><li><p>上述<strong>Action</strong>的名字来自于<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/DefaultEditorKit.html" target="_blank" rel="noopener"><strong>DefaultEditorKit</strong></a>。这个<strong>kit</strong>提供基础的文本编辑和是所有被<strong>Swing</strong>提供的文本编辑<strong>kit</strong> <code>eg:StyledEditorKit 提供styled text的编辑命令</code>的父类 。所以它是被所有的文本组件兼容的，除非那些是为了习惯化重载了的。</p></li><li><p>为了效率，文本组件分享<strong>Action</strong>。这个分享的特性<code>characteristic</code>有两个重要的衍生<code>ramifications</code></p><ul><li><p>你不需要修改<strong>Action</strong>对象你从<strong>Editor Kits</strong>。如果你做了，这个将影响在你项目中的所有文本组件</p></li><li><p><strong>Action</strong>能够运行在其他文本组件。如果你不想分享，实例化<strong>Action</strong>对象</p></li></ul></li></ol><h5 id="Associating-Text-Actions-With-Key-Strokes"><a href="#Associating-Text-Actions-With-Key-Strokes" class="headerlink" title="Associating Text Actions With Key Strokes"></a>Associating Text Actions With Key Strokes</h5><p>使用文本组件的<strong>Input Map</strong>联系<strong>Key Stroke</strong>的<strong>Action</strong>。了解更多的<strong>Input Binding</strong><a href="https://docs.oracle.com/javase/tutorial/uiswing/misc/keybinding.html" target="_blank" rel="noopener">信息</a></p><ol><li><p>下述代码添加<strong>Ctrl-B</strong>键绑定<strong>TextPane</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputMap inputMap = textPane.getInputMap();</span><br><span class="line">KeyStroke key = KeyStroke.getKeyStoke(KeyEvent.VK_B,Event.CTRL_MASK);</span><br><span class="line">inputMap.put(key,DefaultEditorKit.backwardAction);</span><br></pre></td></tr></table></figure><p>首先，这个代码获得了文本组件的<strong>Input Map</strong>。然后，它发现表示<strong>Ctrl-B</strong>键对的一个<strong><a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/KeyStroke.html" target="_blank" rel="noopener">KeyStroke</a></strong>对象。最后，这个代码绑定这个<strong>Key Stroke</strong>到光标后退的<strong>Action</strong></p></li></ol><h5 id="Implementing-Undo-and-Redo"><a href="#Implementing-Undo-and-Redo" class="headerlink" title="Implementing Undo and Redo"></a>Implementing Undo and Redo</h5><p>实现撤销和重做有两部分</p><ul><li><p>记住撤销的编辑文本</p><p>为了支持撤销和重做，文本组件必须记住每次编辑文本的发生，编辑的顺序和在每次需要撤销的编辑中什么是需要的。<strong><a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/undo/UndoManager.html" target="_blank" rel="noopener">UndoManager</a></strong>类可以管理这些撤销的编辑的表单。 </p><p><code>step1:实例化一个UndoManager</code></p><p><code>step2:在document中添加UndoListener,为UndoMana获取上次编辑的内容</code></p><p><strong>查看更多的关于撤销编辑监听器<code>undoable edit listener</code>和撤销编辑事件，请看<a href="https://docs.oracle.com/javase/tutorial/uiswing/events/undoableeditlistener.html" target="_blank" rel="noopener">How to Write an Undoable Edit Listener</a></strong></p></li><li><p>实现撤销和重做命令和为它们提供使用者接口</p><p><code>step1:添加实现undo和redo的Action放在需要添加Action的组件</code></p><p><code>step2:实现undo和redo的abstractAction</code></p></li></ul><h5 id="Implementing-a-Document-Filter"><a href="#Implementing-a-Document-Filter" class="headerlink" title="Implementing a Document Filter"></a>Implementing a Document Filter</h5><p><code>step1:创造一个DocumentFilter的子类</code></p><p><code>step2:使用一个定义在AbstractDocument的setDocumentFilter方法附着它到document</code></p><p>: Note 默认<strong>Swing</strong>文本组件使用<strong>AbstractDocument</strong>子类作为它们的<strong>document</strong></p><h5 id="Listening-for-changes-on-a-Document"><a href="#Listening-for-changes-on-a-Document" class="headerlink" title="Listening for changes on a Document"></a>Listening for changes on a Document</h5><p>你能够在<strong>document</strong>注册两种不同的监听器 <strong>document listener and undoable edit listeners</strong></p><p>查看更多<a href="https://docs.oracle.com/javase/tutorial/uiswing/components/generaltext.html#undo" target="_blank" rel="noopener"><strong>undoable edit listener</strong></a></p><p>使用<strong>document listener</strong>来加入发生插入和删除或者文本风格改变时候的反应</p><p><code>step1:创造一个实现了DocumentListener的子类</code></p><p><code>step2:在doc的addDocumentListener添加上述类</code></p><p>监听器实现三个不同的文档事件<code>insertion,removal,stylechanges</code></p><p>关于更多的文档监听器信息和文档事件，查看<a href="https://docs.oracle.com/javase/tutorial/uiswing/events/documentlistener.html" target="_blank" rel="noopener">How to Write a Document Listener</a></p><h6 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h6><p><strong>你可能想在文档监听器修改文档文本，但是，这个是不允许在文档监听器修改的。因为这样可能导致项目死锁问题。你可以使用格式化的文本字段<code>field</code>或者提供一个document过滤器达到修改的目的</strong></p><h5 id="Listening-for-Caret-and-Selection-Changes"><a href="#Listening-for-Caret-and-Selection-Changes" class="headerlink" title="Listening for Caret and Selection Changes"></a>Listening for Caret and Selection Changes</h5><p><strong>TextComponentDemo</strong>项目使用<strong>caret</strong>监听器展示<code>caret</code>目前的位置。如果文本是被选择，那么扩展选择</p><p><code>step1:创造一个实现了CaretListener的类</code></p><p><code>step2:在文本组件addCaretListener类中添加上述的类</code></p><p><code>step3:必须实现的方法 caretUpdate</code></p><p>更多的信息关于<code>caret监听器和caret事件</code>，请看<a href="https://docs.oracle.com/javase/tutorial/uiswing/events/caretlistener.html" target="_blank" rel="noopener">How to Write Caret Listener</a></p><p>如果你想要改变<strong>Caret</strong>或者<strong>Selection</strong>，使用<strong>navigation filter</strong>或者<strong>习惯化的caret</strong></p><ul><li>实现<strong>navigation filter</strong><ul><li>写一个<strong>NavigationFilter</strong>的子类</li><li>通过setNavigationFilter方法添加子类的实现到文本组件</li></ul></li><li>实现习惯化的<strong>caret</strong><ul><li>实现<strong>Caret</strong>接口，或者扩展<strong>DefaultCarets</strong>类</li><li>通过setCaret方法添加子类的实现到文本组件</li></ul></li></ul><h5 id="文本组件API"><a href="#文本组件API" class="headerlink" title="文本组件API"></a>文本组件API</h5><p>这些<strong>API</strong>列举在这个部分包括下述的目录</p><ul><li><p>设置属性<code>JTextComponent类</code></p><p>编辑,组件之间边距等</p></li><li><p>操控选择部分</p></li><li><p>传递介于<strong>Model</strong>和<strong>View</strong>的<strong>Position</strong></p></li><li><p>文本编辑命令 </p><p><strong>cut,copy</strong></p></li><li><p>表示<strong>Document</strong>的类和接口</p></li><li><p>工作在<strong>Document</strong></p></li><li><p>操控<a href="https://docs.oracle.com/javase/tutorial/uiswing/components/textapi.html#carrots" target="_blank" rel="noopener">Carets and Selection Highlighters</a> </p></li><li><p>阅读和写文本</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JTextComponent&quot;&gt;&lt;a href=&quot;#JTextComponent&quot; class=&quot;headerlink&quot; title=&quot;JTextComponent&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tuto
      
    
    </summary>
    
      <category term="api" scheme="http://log.xiaohaoming.com/categories/api/"/>
    
    
      <category term="api" scheme="http://log.xiaohaoming.com/tags/api/"/>
    
      <category term="java" scheme="http://log.xiaohaoming.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>j按键事件</title>
    <link href="http://log.xiaohaoming.com//2018/09/api-JKeyEvent.html"/>
    <id>http://log.xiaohaoming.com//2018/09/api-JKeyEvent.html</id>
    <published>2018-09-25T13:50:56.566Z</published>
    <updated>2018-09-25T13:50:51.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JKeyEvent"><a href="#JKeyEvent" class="headerlink" title="JKeyEvent"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/awt/event/KeyEvent.html" target="_blank" rel="noopener">JKeyEvent</a></h3><p>一个指示<strong>keystroke</strong>在组件发生的事件。</p><p>按键在被按压，释放或者敲得时候<strong>low-level event</strong>较低层级事件被组件对象生成<code>例如：tetx field</code>。这些事件是被传递到已经通过组件<strong>addKeyListener</strong>注册的<strong>KeyListener</strong>或者<strong>KeyAdapter</strong>对象来接受这些事件。<code>KeyAdapter Objects实现KeyListener接口</code>。当事件发生的时候，每一个监听器得到这个事件</p><p><strong>Key typed event</strong>是<strong>higher level</strong>高层级的和不依赖平台或者键盘布局的。当<strong>Unicode</strong>字符是被键入，它们是被生成的和以一种最完美的方式找到字符输入。</p><p><strong>getKeyChar</strong>方法总是返回一个有效的<strong>Unicode</strong>字符或者<strong>CHAR_UNDEFINED</strong>。字符输入是报道通过<strong>KEY_TYPED</strong>事件</p><p>对于键按压和键释放事件，<strong>getKeyCode</strong>方法返回事件<strong>keyCode</strong></p><p><strong>Key Pressed</strong>和<strong>Key Released</strong>事件依赖平台和键盘布局。是唯一的方式发现键这个并没有字符输入<code>action keys,modifier keys等</code></p><h4 id="按压和释放一个在键盘中的键造成下述键事件的合成"><a href="#按压和释放一个在键盘中的键造成下述键事件的合成" class="headerlink" title="按压和释放一个在键盘中的键造成下述键事件的合成"></a>按压和释放一个在键盘中的键造成下述键事件的合成</h4><ul><li><strong>KEY_PRESSED</strong></li><li><strong>KEY_TYPED</strong></li><li><strong>KEY_RELEASED</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JKeyEvent&quot;&gt;&lt;a href=&quot;#JKeyEvent&quot; class=&quot;headerlink&quot; title=&quot;JKeyEvent&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/awt
      
    
    </summary>
    
      <category term="api" scheme="http://log.xiaohaoming.com/categories/api/"/>
    
    
      <category term="api" scheme="http://log.xiaohaoming.com/tags/api/"/>
    
      <category term="java" scheme="http://log.xiaohaoming.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>键盘绑定</title>
    <link href="http://log.xiaohaoming.com//2018/09/api-JKeyBinding.html"/>
    <id>http://log.xiaohaoming.com//2018/09/api-JKeyBinding.html</id>
    <published>2018-09-25T13:50:21.678Z</published>
    <updated>2018-09-25T13:50:19.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JKeyBinding"><a href="#JKeyBinding" class="headerlink" title="JKeyBinding"></a><a href="https://docs.oracle.com/javase/tutorial/uiswing/misc/keybinding.html" target="_blank" rel="noopener">JKeyBinding</a></h3><p><strong>JComponent</strong>类支持键绑定作为一种方式响应用户的键敲入。</p><p>通常不需要直接地使用键绑定。在使用这些键绑定的时候应该先考虑使用助记键<code>mnemonics</code>[被所有的按钮支持和索引式窗格<code>tabbed panes</code>和<code>JLabel</code>]和加速键[被菜单项支持]。你能够发现通用的助记键和加速键在<a href="https://docs.oracle.com/javase/tutorial/uiswing/components/menu.html#mnemonic" target="_blank" rel="noopener">Enabling Keyboard Operation</a>部分</p><h4 id="How-Key-Binding-Work"><a href="#How-Key-Binding-Work" class="headerlink" title="How Key Binding Work"></a>How Key Binding Work</h4><p>键绑定支持由<strong>JComponent</strong>提供的，依赖于<strong>InputMap</strong>和<strong>ActionMap</strong>类。<strong>input map</strong>绑定<strong>key strokes</strong>到<strong>action names</strong>，和<strong>action map</strong>指定<strong>action</strong>符合每个<strong>action</strong>名字。</p><p>每一个<strong>JComponent</strong>有一个<strong>Action map</strong>和三个<strong>Input map</strong>。这些<strong>input map</strong>符合下述聚焦情况：</p><ul><li><strong>JComponent.WHEN_FOCUSED</strong></li></ul><p>组件有键盘聚焦</p><ul><li><strong>JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</strong></li></ul><p>组件包含[继承]或者是已经聚焦的组件。这个<strong>Input Map</strong>是通常在组合组件中使用</p><ul><li><strong>JComponent.WHEN_IN_FOCUSED_WINDOW</strong></li></ul><p>组件窗口已经聚焦或者包含已经聚焦的组件</p><p>当用户敲了一个键，<strong>JComponent</strong>键事件处理代码寻找一个或多个<strong>Input Map</strong>来为键找到有效的绑定。当它发现绑定，它寻找在<strong>action map</strong>符合中<strong>action</strong>。如果这个<strong>action</strong>是<strong>enabled</strong>,这个绑定是有效的和这个<strong>action</strong>是执行的。如果是<strong>disabled</strong>，寻找有效的绑定是继续的</p><p>如果单个键存在多个绑定，只有第一个发现且有效的是被执行的。<strong>Input maps</strong>是以这种顺序被检查的。</p><ul><li>聚焦的组件的<strong>JComponent.WHEN_FOCUSED</strong>的<strong>input map</strong></li><li>聚焦的组件的<strong>JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</strong>的<strong>input map</strong></li><li>聚焦的组件的父亲<strong>JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</strong>的<strong>input map</strong>，然后父亲的父亲，按照继承顺序。:arrow_down_small:组件禁止<strong>input map</strong>是被略过的</li><li>所有的<strong>enabled</strong>组件在聚焦窗口的<strong>JComponent.WHEN_IN_FOCUSED_WINDOW</strong>的<strong>input map</strong>是被搜索的</li></ul><h4 id="How-to-Make-and-Remove-Key-Bindings"><a href="#How-to-Make-and-Remove-Key-Bindings" class="headerlink" title="How to Make and Remove Key Bindings"></a>How to Make and Remove Key Bindings</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特定字符串"doSomething"绑定一个key Stroke                     </span></span><br><span class="line">component.getInputMap().put(KeyStroke.getKeyStroke(<span class="string">"F2"</span>),<span class="string">"doSomething"</span>);</span><br><span class="line"><span class="comment">//特定字符串"doSimething"绑定一个特定的action</span></span><br><span class="line">component.getActionMap().put(<span class="string">"doSomething"</span>,anAction);</span><br><span class="line"><span class="comment">//where anAction is a javax.swing.Action</span></span><br></pre></td></tr></table></figure><p>你能发现关于创造<strong>Action</strong>例子在<a href="https://docs.oracle.com/javase/tutorial/uiswing/misc/action.html" target="_blank" rel="noopener">How to Use Actions</a></p><p>为了让组件忽视通常响应的键，你能使用指定<strong>Action name</strong>,即[<strong>none</strong>]。例如，下述代码让组件忽视<strong>F2</strong>键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.getInputMap().put(KeyStroke.getKeyStroke(<span class="string">"F2"</span>),<span class="string">"none"</span>);</span><br></pre></td></tr></table></figure><p>:heavy_plus_sign:<strong>Note</strong>:<br>在先前的代码不能<strong>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT and WHEN_IN_FOCUSED_WINDOW input map</strong>搜索<strong>F2</strong>键的绑定。为了阻止这种搜索，能够使用有效的<strong>action</strong>代替[<strong>none</strong>]。例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Action doNothing =<span class="keyword">new</span> AbstractAction() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> = <span class="keyword">new</span> actionPerformed(ActionEvent e)&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">component.getInputMap().put(KeyStroke.getKeyStroke(<span class="string">"F2"</span>),<span class="string">"doNothing"</span>);</span><br><span class="line">component.getActionMap().put(<span class="string">"doNothing"</span>,doNoting);</span><br></pre></td></tr></table></figure><h4 id="The-Key-Binding-API"><a href="#The-Key-Binding-API" class="headerlink" title="The Key Binding API"></a>The Key Binding API</h4><ul><li>创造和使用<strong>InputMaps</strong></li><li>创造和使用<strong>ActionMaps</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JKeyBinding&quot;&gt;&lt;a href=&quot;#JKeyBinding&quot; class=&quot;headerlink&quot; title=&quot;JKeyBinding&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uisw
      
    
    </summary>
    
      <category term="api" scheme="http://log.xiaohaoming.com/categories/api/"/>
    
    
      <category term="api" scheme="http://log.xiaohaoming.com/tags/api/"/>
    
      <category term="java" scheme="http://log.xiaohaoming.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java日志</title>
    <link href="http://log.xiaohaoming.com//2018/09/api-Java%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F-Logger.html"/>
    <id>http://log.xiaohaoming.com//2018/09/api-Java日志系统-Logger.html</id>
    <published>2018-09-25T13:49:47.373Z</published>
    <updated>2018-09-25T13:49:41.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java日志系统-Logger"><a href="#Java日志系统-Logger" class="headerlink" title="Java日志系统 - Logger"></a>Java日志系统 - Logger</h3><p>Logger类是用来记录某个级别的日志信息</p><h4 id="级别"><a href="#级别" class="headerlink" title="级别"></a>级别</h4><ul><li>SEVERE </li><li>WARNING</li><li>INFO</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>级别按从上至下逐级剃减</p><p>另外还有级别OFF，可以用来关闭日志；使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java日志系统-Logger&quot;&gt;&lt;a href=&quot;#Java日志系统-Logger&quot; class=&quot;headerlink&quot; title=&quot;Java日志系统 - Logger&quot;&gt;&lt;/a&gt;Java日志系统 - Logger&lt;/h3&gt;&lt;p&gt;Logger类是用来记录某个
      
    
    </summary>
    
      <category term="api" scheme="http://log.xiaohaoming.com/categories/api/"/>
    
    
      <category term="api" scheme="http://log.xiaohaoming.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>awt和swing简易性质</title>
    <link href="http://log.xiaohaoming.com//2018/09/api-Java-Awt%E5%8C%85%E5%92%8Cjava-Swing%E7%9A%84%E7%AE%80%E6%98%93%E6%80%A7%E8%B4%A8%E5%92%8C%E8%B5%B7%E6%BA%90.html"/>
    <id>http://log.xiaohaoming.com//2018/09/api-Java-Awt包和java-Swing的简易性质和起源.html</id>
    <published>2018-09-25T13:49:06.770Z</published>
    <updated>2018-09-25T13:49:02.268Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java SE 9</code></p><h3 id="Java-Awt包和java-Swing的简易性质和起源"><a href="#Java-Awt包和java-Swing的简易性质和起源" class="headerlink" title="Java.Awt包和java.Swing的简易性质和起源"></a>Java.Awt包和java.Swing的简易性质和起源</h3><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p><strong>GUI</strong><code>图形用户界面</code>为程序提供界面。最初的目的为程序员构建一个通用的<strong>GUI</strong>，使其能够在所有平台运行。但<strong>java1.0</strong>中的基础类<strong>AWT</strong><code>抽象窗口箱</code>并不能够实现这个目的，所以<strong>Swing</strong>出现了</p><h4 id="简易性质"><a href="#简易性质" class="headerlink" title="简易性质"></a>简易性质</h4><ul><li><p>相互存在性</p><p><strong>Swing</strong>是<strong>AWT</strong>的增强组件，但是它并不能完全替代<strong>AWT</strong>组件</p></li><li><p>平台无关性</p><p><strong>Swing</strong>属于”轻量级组件”，完全由<strong>Java</strong>编写，而<strong>Java</strong>不依赖操作系统；<strong>AWT</strong>属于”重量级组件”，依赖本地平台的窗口来决定组件的功能，外观和风格</p></li></ul><h4 id="JTextArea"><a href="#JTextArea" class="headerlink" title="JTextArea"></a><a href="https://docs.oracle.com/javase/9/docs/api/javax/swing/JTextArea.html" target="_blank" rel="noopener">JTextArea</a></h4><ul><li><p>容量<code>capabilities</code></p><p><strong>java.awt.TextArea &lt; JTextArea &lt;JTextPane/JEditorPane</strong></p></li><li><p>滚动<code>scrolling</code></p><p>内部处理滚动，实现<strong>Scrollable</strong>接口。如果想要滚动操作，可以放置在<strong>JScrollPane</strong>，否则直接使用</p></li><li><p>行包装<code>Line wrap</code></p><p>实现换行通过设置属性，默认为<strong>false</strong>，不包装</p></li><li><p>行和列<code>row column</code></p><p>设置喜欢的大小</p></li><li><p>文本倾听器<code>TextListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DocumentListener myListener = ??</span><br><span class="line">JTextArea myArea = ??</span><br><span class="line">myArea.getDocument().addDocumentListener(myListener);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Java SE 9&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;Java-Awt包和java-Swing的简易性质和起源&quot;&gt;&lt;a href=&quot;#Java-Awt包和java-Swing的简易性质和起源&quot; class=&quot;headerlink&quot; title=&quot;Java.A
      
    
    </summary>
    
      <category term="api" scheme="http://log.xiaohaoming.com/categories/api/"/>
    
    
      <category term="api" scheme="http://log.xiaohaoming.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>JAction</title>
    <link href="http://log.xiaohaoming.com//2018/09/api-JAction-API-Interface.html"/>
    <id>http://log.xiaohaoming.com//2018/09/api-JAction-API-Interface.html</id>
    <published>2018-09-25T13:48:08.829Z</published>
    <updated>2018-09-25T13:48:04.771Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAction-API-Interface"><a href="#JAction-API-Interface" class="headerlink" title="JAction - API - Interface"></a><a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html#putValue-java.lang.String-java.lang.Object-" target="_blank" rel="noopener">JAction - API - Interface</a></h3><p><strong>All SuperInterface</strong></p><ul><li><strong>ActionListener</strong></li><li><strong>EventListener</strong></li></ul><p><strong>Action</strong>接口提供一个对<strong>ActionListener</strong>接口有用的扩展当相同功能可能被多个控件访问的时候</p><h4 id="Swing组件支持Action"><a href="#Swing组件支持Action" class="headerlink" title="Swing组件支持Action"></a>Swing组件支持Action</h4><p>许多<strong>Swing</strong>组件有<strong>Action</strong>属性。当<strong>Action</strong>是在组件被设置，下述的事情将发生</p><ul><li><strong>Action</strong>被添加作为<strong>ActionListener</strong>到组件</li><li>组件配置一些属于他的属性来匹配<strong>Action</strong></li><li><p>组件在<strong>Action</strong>安装中<strong>PropertyChangeListener</strong>，所以组件能改变他的属性来更改在<strong>Action</strong>中的属性改变。</p><p>下述表描述被Swing组件使用的支持<strong>Actions</strong>的属性</p><p><code>eg:</code></p></li></ul><table><thead><tr><th>Component Property</th><th>Components</th><th>Action Key</th><th>Notes</th></tr></thead><tbody><tr><td>toolTipText</td><td>All</td><td>SHORT_DESCRIPTION</td></tr></tbody></table><p>表示在所有的<strong>Swing</strong>组件都可以通过putValue方法的ActionKey键”SHORT_DESCRIPTION”设置的提示信息文本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//where is Action class</span></span><br><span class="line">putValue(SHORT_DESCRIPTION, desc);  <span class="comment">//desc为描述提示停息的文本字符串</span></span><br></pre></td></tr></table></figure><p><strong>注意：其他属性请通过标题名字链接查询</strong></p><h4 id="How-to-Use-Action"><a href="#How-to-Use-Action" class="headerlink" title="How to Use Action"></a>How to Use Action</h4><p><code>具体可以查询demo在Intellij Datastructlecturedesignation-&gt;test-&gt;ActionDemo|引自Oracle tutorial</code></p><p>一个<strong>Action</strong>能够被用来从一个组件分离功能和状态。例如，如果你有两个或者更多组件执行相同的功能，考虑使用一个<strong>Action</strong>对象来实现功能。一个<strong>Action</strong>对象是一个<strong>Action Listener</strong>这个提供不仅<strong>Action-Event</strong>处理，也中心化处理<strong>action-event-firing</strong>组件状态。</p><p>你典型地附着一个<strong>action</strong>到组件使用<strong>setAction</strong>方法。在这里列举当<strong>setAction</strong>是在组件中被调用会发生什么</p><ul><li>组件状态被更新来匹配<strong>Action</strong>的状态。例如，如果<strong>Action</strong>的文本和图标被设置。组件文本和图标也被设置成这些值。</li><li>这个<strong>Action</strong>对象是被注册作为一个在组建的<strong>Action Listener</strong></li><li>如果<strong>Action</strong>的状态被改变，组建状态是被更新来匹配<strong>Action</strong>。例如，如果你改变在<strong>Action</strong>中<strong>Enabled</strong>状态，它附着的所有组件将会改变他们的来匹配这个<strong>Action</strong>。</li></ul><h4 id="The-Action-API"><a href="#The-Action-API" class="headerlink" title="The Action API"></a><a href="https://docs.oracle.com/javase/tutorial/uiswing/misc/action.html" target="_blank" rel="noopener">The Action API</a></h4><ul><li><p>支持<strong>set/getAction</strong>的组件</p></li><li><p>创造和使用一个<strong>AbsttracAction</strong></p></li><li><p><strong>Action</strong>属性</p><p>定义了能在一个<strong>Action</strong>设置的属性。组件自动使用这个属性[在附在<strong>menu item</strong>中的<strong>Action</strong>设置<strong>ACCELERATOR_KEY</strong>，意味着这个<strong>JMenuItem.setAccelerator(KeyStroke)</strong>是自动被调用]</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAction-API-Interface&quot;&gt;&lt;a href=&quot;#JAction-API-Interface&quot; class=&quot;headerlink&quot; title=&quot;JAction - API - Interface&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://do
      
    
    </summary>
    
      <category term="api" scheme="http://log.xiaohaoming.com/categories/api/"/>
    
    
      <category term="api" scheme="http://log.xiaohaoming.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>插值</title>
    <link href="http://log.xiaohaoming.com//2018/09/algorithm-Interpolation-%E6%8F%92%E5%80%BC.html"/>
    <id>http://log.xiaohaoming.com//2018/09/algorithm-Interpolation-插值.html</id>
    <published>2018-09-25T13:46:58.142Z</published>
    <updated>2018-09-25T13:46:53.193Z</updated>
    
    <content type="html"><![CDATA[<p>###Interpolation - 插值</p><p>In the <a href="https://en.wikipedia.org/wiki/Mathematics" target="_blank" rel="noopener">mathematical</a> field of <a href="https://en.wikipedia.org/wiki/Numerical_analysis" target="_blank" rel="noopener">numerical analysis</a>, <strong>interpolation</strong> is a method of constructing new <a href="https://en.wikipedia.org/wiki/Data_points" target="_blank" rel="noopener">data points</a> within the range of a <a href="https://en.wikipedia.org/wiki/Discrete_set" target="_blank" rel="noopener">discrete set</a> of known data points. <a href="在数值分析数学领域，插值是在已知的数据点的实体集合范围内构造新的数据点方法">^8</a></p><h4 id="Piecewise-constant-interpolation-分段常量插值"><a href="#Piecewise-constant-interpolation-分段常量插值" class="headerlink" title="Piecewise constant interpolation - 分段常量插值"></a>Piecewise constant interpolation - 分段常量插值</h4><p>Further information: <a href="https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation" target="_blank" rel="noopener">Nearest-neighbor interpolation</a></p><p>The simplest interpolation method is to locate the nearest data value, and assign the same value. <a href="最简单的插值方法是插入已知数据值最接近的数据值，和赋相同的值">^9</a></p><h4 id="Linear-interpolation-线性插值"><a href="#Linear-interpolation-线性插值" class="headerlink" title="Linear interpolation - 线性插值"></a><a href="https://en.wikipedia.org/wiki/Linear_interpolation" target="_blank" rel="noopener">Linear interpolation </a>- 线性插值</h4><p>One of the simplest method is linear interpolation.<a href="线性插值是其中一个比较简单的方法">^10</a></p><p>Generally,linear interpolation takes two data points,say$$(x_a,y_a)$$,and the interpolation is given by:</p><p>$$y = y_a + (y_b -y_a) \frac{x-x_a}{x_b - x_a}$$ at the point $$(x,y)$$  </p><p>Then the linear interpolation error is </p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/15e835bf7d5d64ca8fef6bd55cfd937460b4752e" alt="|f(x)-g(x)|\leq C(x_{b}-x_{a})^{2}\quad {\text{where}}\quad C={\frac {1}{8}}\max _{r\in [x_{a},x_{b}]}|g&#39;&#39;(r)|."> </p><h4 id="Polynomial-interpolation-多项式插值"><a href="#Polynomial-interpolation-多项式插值" class="headerlink" title="Polynomial interpolation - 多项式插值"></a><a href="https://en.wikipedia.org/wiki/Polynomial_interpolation" target="_blank" rel="noopener">Polynomial interpolation </a>- 多项式插值</h4><p>Polynomial interpolation is generalization of linear interpolation.<a href="多项式插值是线性插值的综合">^11</a>Note that the linear interpolation is a linear function. <a href="注意线性插值是一个线性函数">^12</a>We replace this interpolation with polynominal of higher degree. <a href="我们使用高次的多项式替换插值">^13</a></p><p>Calculating the interpolating polynomial is computationally expensive (see <a href="https://en.wikipedia.org/wiki/Computational_complexity_theory" target="_blank" rel="noopener">computational complexity</a>) compared to linear interpolation. [^14]Furthermore, polynomial interpolation may exhibit oscillatory artifacts, especially at the end points (see <a href="https://en.wikipedia.org/wiki/Runge%27s_phenomenon" target="_blank" rel="noopener">Runge’s phenomenon</a>). [^15]</p><h4 id="Spline-interpolatio-样条插值"><a href="#Spline-interpolatio-样条插值" class="headerlink" title="Spline interpolatio - 样条插值"></a><a href="https://en.wikipedia.org/wiki/Spline_interpolation" target="_blank" rel="noopener">Spline interpolatio</a> - 样条插值</h4><p>Remember that linear interpolation uses a linear function for each of intervals [$$x_k,x_{k+1}$$] .[^16]Spline interpolation uses low-degree polynominals in each of the intervals,and choose the polynominal piece such that fit smoothly together.[^17]The resulting function is called a spline. [^18]</p><p>However, the global nature of the basis functions leads to ill-conditioning. This is completely mitigated <code>减弱</code> by using splines of compact support, such as are implemented in <a href="https://en.wikipedia.org/wiki/Interpolation#cite" target="_blank" rel="noopener">Boost.Math and discussed in Kress</a></p><h4 id="Via-Gaussian-processes-使用高斯处理"><a href="#Via-Gaussian-processes-使用高斯处理" class="headerlink" title="Via Gaussian processes - 使用高斯处理"></a>Via Gaussian processes - 使用高斯处理</h4><p><a href="https://en.wikipedia.org/wiki/Gaussian_process" target="_blank" rel="noopener">Gaussian process</a> is a powerful non-linear interpolation tool. Many popular interpolation tools are actually equivalent to particular Gaussian processes.[^19]</p><h4 id="Other-forms-其他解决插值方法组合"><a href="#Other-forms-其他解决插值方法组合" class="headerlink" title="Other forms - 其他解决插值方法组合"></a>Other forms - 其他解决插值方法组合</h4><p>Other forms of interpolation can be constructed by picking a different class of interpolations.[^20]</p><h4 id="In-higher-dimensions-高纬度插值使用"><a href="#In-higher-dimensions-高纬度插值使用" class="headerlink" title="In higher dimensions - 高纬度插值使用"></a><a href="https://en.wikipedia.org/wiki/Multivariate_interpolation" target="_blank" rel="noopener">In higher dimensions</a> - 高纬度插值使用</h4><p>Multivariate interpolation is the interpolation of functions of more than one variable. [^21]</p><h4 id="Related-concepts-相关概念"><a href="#Related-concepts-相关概念" class="headerlink" title="Related concepts - 相关概念"></a>Related concepts - 相关概念</h4><p>The term <em>extrapolation</em> is used to find data points outside the range of known data points. </p><p><strong>插值与曲线拟合不同</strong></p><p>In <a href="https://en.wikipedia.org/wiki/Curve_fitting" target="_blank" rel="noopener">curve fitting</a> problems, the constraint that the interpolant has to go exactly through the data points is relaxed.  </p><p><a href="https://en.wikipedia.org/wiki/Approximation_theory" target="_blank" rel="noopener">Approximation theory</a> studies how to find the best approximation to a given function by another function from some predetermined class, and how good this approximation is. This clearly yields a bound on how well the interpolant can approximate the unknown function.</p><h4 id="Extension-拓展"><a href="#Extension-拓展" class="headerlink" title="Extension - 拓展"></a>Extension - 拓展</h4><h5 id="rational-functions"><a href="#rational-functions" class="headerlink" title="rational functions"></a><a href="https://en.wikipedia.org/wiki/Rational_function" target="_blank" rel="noopener">rational functions</a></h5><p>rational [‘ræʃ(ə)nəl]<br>n adj: 理性,有理数</p><p>In mathmatics, a rational function is any function which can be defined by a rational fraction.<a href="在数学上，一个有理数函数是能被有理分式定义任何函数">^1</a>i.e. an algebraic  fraction such that the numerator  and the denominator are polynominals.<a href="即代数分式，即分子和分母是多项式">^2</a>The coefficients of the polynominals need not be rational numbers;<a href="多项式系数需要不是有理数的数字">^3</a>They can be taken in any field K.<a href="它们可以被包含在任意领域K">^4</a>In this case, one speaks of a rational function and a rational function over K.[^5]The values of the variables may be taken in any field L containing K.<a href="变量的值可能被包含在包含K任意领域L">^6</a>Then the function is the set of the value of the variables for which the denominator is not zero and the codomain is L.<a href="那么这个函数是分母不为0的变量的值的集合和[陪域]()https://baike.baidu.com/item/陪域/942697是L">^7</a></p><h4 id="MatLab实现插值"><a href="#MatLab实现插值" class="headerlink" title="MatLab实现插值"></a>MatLab实现插值</h4><h5 id="griddedInterpolant函数"><a href="#griddedInterpolant函数" class="headerlink" title="griddedInterpolant函数"></a><a href="https://ww2.mathworks.cn/help/matlab/ref/griddedinterpolant.html?lang=en" target="_blank" rel="noopener">griddedInterpolant</a>函数</h5><ul><li><p><strong>Description</strong></p><p>使用<code>griddedInterpolant</code>来执行1-D,2-D,3-D,or N-D 栅格数据集插值。<code>griddedInterpolant</code>返回插值<strong>F</strong>从被给予的数据集.能够在查询点集合测量<strong>F</strong></p><p>使用<a href="https://ww2.mathworks.cn/help/matlab/ref/scatteredinterpolant.html" target="_blank" rel="noopener">scatteredInterpolant</a>来执行对于离散数据<code>scattered data</code>的插值</p></li><li><p><strong>Syntax</strong></p><p><code>F = griddedInterpolant</code></p><p><code>F = griddedInterpolant(x,v)</code> </p><p>创造一个1-D插值通过样本点集矢量<code>vertor</code>x和符合值v.   </p><p><code>F = griddedInterpolant(X1,X2,...,Xn,V)</code> ，</p><p><code>F = griddedInterpolant(V)</code></p><p>使用默认网格创造插值。当你在使用这个语法时候<code>griddedInterpolant</code>定义在第ith 维空间是1和范围是[1,size(V,i)]网格作为一个点集合。使用这个语法在你不需要关注内存和点之间绝对距离</p><p><code>F = griddedInterpolant(gridVecs,V)</code></p><p>指定包含n个grid vectors[^gird_vec]的描述n维样本网格cell数组gridvecs。使用这个语法当你需要使用指定的网格和关心内存</p><p><code>F = griddedInterpolant(___,Method)</code></p><p><code>F = griddedInterpolant(___,Method,ExtrapolationMethod)</code></p><p>指定 both the interpolation and extrapolation methods. <code>griddedInterpolant</code> uses <code>ExtrapolationMethod</code> to estimate the value when your query points fall outside the domain of your sample point</p></li><li><p><strong>example</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ F ]</span> = <span class="title">Test_Interpolation</span><span class="params">(  )</span></span></span><br><span class="line"><span class="comment">%TEST 任何需要测试的例子</span></span><br><span class="line"><span class="comment">%   1-D Interpolation，使用默认‘linear’插值</span></span><br><span class="line"><span class="comment">%   Syntax F = griddedInterpolant(x,v) </span></span><br><span class="line">x = sort(<span class="number">20</span> * <span class="built_in">rand</span>(<span class="number">100</span>,<span class="number">1</span>));  <span class="comment">%介于0-20的100个随机数</span></span><br><span class="line">v = <span class="built_in">besselj</span>(<span class="number">0</span>,x);  <span class="comment">%一个函数</span></span><br><span class="line">F = griddedInterpolant(x,v);  <span class="comment">%创造一个网格插值对象，默认使用'linear' 插值方法</span></span><br><span class="line">xq = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">20</span>,<span class="number">500</span>);  <span class="comment">%插入500个统一距离的介于0-20的值</span></span><br><span class="line">vq = F(xq);</span><br><span class="line">plot(x,v,<span class="string">'ro'</span>)</span><br><span class="line">hold on  <span class="comment">%当需要多次使用plot且图像需要叠加时</span></span><br><span class="line">plot(xq,vq,<span class="string">'.'</span>)</span><br><span class="line">legend(<span class="string">'Sample points'</span>,<span class="string">'Interpolated Values'</span>)</span><br><span class="line">hold off <span class="comment">%终止接下来的需要plot图像叠加,则下一次plot在另外一个窗口打开</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ F ]</span> = <span class="title">Test_Interpolation</span><span class="params">(  )</span></span></span><br><span class="line"><span class="comment">%TEST 任何需要测试的例子</span></span><br><span class="line"><span class="comment">%Describe  Using Full Grid </span></span><br><span class="line"><span class="comment">%Syntax F = griddedInterpolant(gridVecs,V)</span></span><br><span class="line"><span class="comment">%Vq = F(Xq1,Xq2,...,Xqn,V) 相对于F(&#123;xgq1,xgq2,...,xgqn&#125;,V)</span></span><br><span class="line">x = (<span class="number">1</span>:<span class="number">0.3</span>:<span class="number">5</span>)';  <span class="comment">%行向量转置</span></span><br><span class="line">y = x';</span><br><span class="line">V = <span class="built_in">cos</span>(x) * <span class="built_in">sin</span>(y);</span><br><span class="line">n = <span class="built_in">length</span>(x);</span><br><span class="line"><span class="comment">%surf(1:n,1:n,V)  %未插值，画3-D表面，一一对应(x,y,z)</span></span><br><span class="line">F = griddedInterpolant(V);</span><br><span class="line">[xq,yq] = <span class="built_in">ndgrid</span>(<span class="number">1</span>:<span class="number">0.2</span>:n);  <span class="comment">%当存储无较大关系</span></span><br><span class="line">Vq = F(xq,yq);</span><br><span class="line">surf(xq',yq',Vq)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Input Argument</strong></p><p><code>x</code> — Sample points vector</p><p><strong>Data Types:</strong> <code>single</code> | <code>double</code></p><p><code>v</code> — Sample values vector</p><p><strong>Data Types:</strong> <code>single</code> | <code>double</code></p><p><code>X1</code>, <code>X2</code>, <code>Xn</code> — Sample points in full grid form arrays </p><p><strong>Data Types:</strong> <code>single</code> | <code>double</code></p><p><code>gridVecs</code> — Sample points in grid vector form cell array of grid vectors</p><p>当你网格是非常大的时候，使用这个形式作为一个和完整网格交替的形式</p><blockquote><p><code>Vq = F({xgq1,xgq2,...,xgqn})</code> specifies the query points as <a href="https://ww2.mathworks.cn/help/matlab/ref/griddedinterpolant.html#bvh2f0p-5" target="_blank" rel="noopener">grid vectors</a>. Use this syntax to conserve memory when you want to query a large grid of points.</p><p><code>Vq = F(Xq1,Xq2,...,Xqn)</code> specifies the query points using the <code>n</code>-dimensional arrays <code>Xq1,Xq2,...,Xqn</code>, which define a <a href="https://ww2.mathworks.cn/help/matlab/ref/griddedinterpolant.html#bvh2f0p-4" target="_blank" rel="noopener">full grid</a> of points.</p></blockquote><p><strong>Data Types:</strong> <code>single</code> | <code>double</code></p><p><code>V</code> — Sample values array</p><p><strong>Data Types:</strong> <code>single</code> | <code>double</code></p><p><code>Method</code> — Interpolation method <code>&#39;linear&#39;</code> (default) | <code>&#39;nearest&#39;</code> | <code>&#39;next&#39;</code> | <code>&#39;previous&#39;</code> | <code>&#39;pchip&#39;</code> | <code>&#39;cubic&#39;</code> | <code>&#39;spline&#39;</code> | <code>&#39;makima&#39;</code></p><p><code>ExtrapolationMethod</code> — Extrapolation method <code>&#39;linear&#39;</code> (default) | <code>&#39;nearest&#39;</code> | <code>&#39;next&#39;</code> | <code>&#39;previous&#39;</code> | <code>&#39;pchip&#39;</code> | <code>&#39;cubic&#39;</code> | <code>&#39;spline&#39;</code> | <code>&#39;makima&#39;</code> | <code>&#39;none&#39;</code></p><p>具体method代表意义，请参考手册，</p></li><li><p><strong>Properties</strong><br>类似于成员变量<br><code>GridVectors</code> — Grid vectors  cell array</p></li></ul><p>​       <code>Values</code> — Function values at sample points  array</p><p>​      <code>Method</code> — Interpolation method  <code>&#39;linear&#39;</code> (default) | <code>&#39;nearest&#39;</code> | <code>&#39;next&#39;</code> | <code>&#39;previous&#39;</code> | <code>&#39;pchip&#39;</code>        | <code>&#39;cubic&#39;</code> | <code>&#39;spline&#39;</code> | <code>&#39;makima&#39;</code></p><p>​     <code>ExtrapolationMethod</code> — Extrapolation method  <code>&#39;linear&#39;</code> | <code>&#39;nearest&#39;</code> | <code>&#39;next&#39;</code> | <code>&#39;previous&#39;</code> | <code>&#39;pchip&#39;</code> | <code>&#39;cubic&#39;</code> | <code>&#39;spline&#39;</code> | <code>&#39;makima&#39;</code> | <code>&#39;none&#39;</code></p><h5 id="interp1函数"><a href="#interp1函数" class="headerlink" title="interp1函数"></a><a href="https://ww2.mathworks.cn/help/matlab/ref/interp1.html?lang=en" target="_blank" rel="noopener">interp1函数</a></h5><p><a href="https://ww2.mathworks.cn/help/matlab/ref/griddedinterpolant.html?searchHighlight=griddedInterpolant&amp;s_tid=doc_srchtitle" target="_blank" rel="noopener">参考</a></p><p>这个函数能够通过插值生成具体函数表达式</p><p> 参考 pp = interp1(x,v,method,’pp’) 描述</p><p>[^14]: 计算插值多项式是计算昂贵的【计算复杂度 】<a href="https://en.wikipedia.org/wiki/Computational_complexity_theory" target="_blank" rel="noopener">computational complexity</a> 相比线性插值<br>[^15]: 更多的是，多项式插值可能会展现oscillatory[震荡] artifacts，特别在末尾的点 see <a href="https://en.wikipedia.org/wiki/Runge%27s_phenomenon" target="_blank" rel="noopener">Runge’s phenomenon</a><br>[^16]: 记住线性插值在每个$$[x_k,x_{k+1}]$$使用线性函数<br>[^17]: 样条插值在每一个区间内使用低次多项式，和使用能够光滑的拟合在一起多项式段<br>[^18]: 这个结果函数被叫做样条<br>[^19]: 高斯处理是一个强大的非线性插值工具。许多普遍化插值工具实际上是类似于特殊的高斯处理<br>[^20]: 其他的插值格式能够被构造通过选择不同的插值类<br>[^21]: Multivariate interpolation是超过一个变量的插值函数</p><p>参考引用：</p><ol><li><a href="https://en.wikipedia.org/wiki/Interpolation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Interpolation</a></li></ol><p>[^gird_vec]: 一个服务作为表示(compact representation)ndgrid格式的网格矢量集合。 例如:[X,Y] = ndgrid(xg,yg)返回一个完整的网格矩阵X和Y.能够通过使用网格矢量xg和yg表示相同网格。意义是后者能比前者节省内存.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###Interpolation - 插值&lt;/p&gt;
&lt;p&gt;In the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mathematical&lt;/a&gt; f
      
    
    </summary>
    
      <category term="algorithm" scheme="http://log.xiaohaoming.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://log.xiaohaoming.com/tags/algorithm/"/>
    
      <category term="method" scheme="http://log.xiaohaoming.com/tags/method/"/>
    
  </entry>
  
  <entry>
    <title>给定结点求距离K其它结点</title>
    <link href="http://log.xiaohaoming.com//2018/09/algorithm-kTree.html"/>
    <id>http://log.xiaohaoming.com//2018/09/algorithm-kTree.html</id>
    <published>2018-09-25T13:39:09.850Z</published>
    <updated>2018-09-25T13:38:10.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="863-All-Nodes-Distance-K-in-Binary-Tree"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree" class="headerlink" title="863. All Nodes Distance K in Binary Tree"></a>863. All Nodes Distance K in Binary Tree</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/description/" target="_blank" rel="noopener">描述</a></h3><p>我们将会给予一个二叉树<a href="二叉树根节点为root">^1</a>，一个<code>target</code>结点，和一个整数值<code>K</code>。</p><p>返回距离<code>target</code>结点为<code>K</code>路径长度的所有结点的值的集合。答案能够返回以任何顺序。</p><p><code>We are given a binary tree (with root node root), a target node, and an integer value K.Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.</code></p><h3 id="是否能够解决"><a href="#是否能够解决" class="headerlink" title="是否能够解决"></a>是否能够解决</h3><p>不能，通过查看此题的<code>solution</code>和<code>discuss</code>的大神操作，查看解题思路和代码<code>snippet</code>，摘录以下：</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ul><li>先遍历结点，采用中序遍历递归</li><li>如果发现<code>target</code>结点，遍历子结点添加距离<code>target</code>路径为K的结点的值,采用中序遍历递归的回溯作用查找距离<code>target</code>路径为K的结点的值</li><li>如果没有发现<code>target</code>结点，递归直至结点为<code>null</code></li></ul><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">distanceK</span><span class="params">(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || target == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        preOrder(root, target, list, K);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">preOrder</span><span class="params">(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, List&lt;T&gt; list, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val.equals(target.val)) &#123;</span><br><span class="line">        <span class="comment">//k == 0 的情况</span></span><br><span class="line">        <span class="comment">//当K为0时，只存在它本身，没必要在遍历</span></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getNodesFromChildren(root.left, list, K - <span class="number">1</span>);</span><br><span class="line">        getNodesFromChildren(root.right, list, K - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//回溯作用，能够回溯到祖先和祖先的右孩子</span></span><br><span class="line">        <span class="comment">//在找到target结点后，此时ret返回值大于0，所以开始进行上述回溯操作</span></span><br><span class="line">        <span class="keyword">int</span> ret = preOrder(root.left, target, list, K);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//K大于等于1的情况</span></span><br><span class="line">            <span class="keyword">if</span> (ret == K) &#123;</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            getNodesFromChildren(root.right, list, K - (ret + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯作用，能够回溯到祖先和祖先的右孩子</span></span><br><span class="line">        ret = preOrder(root.left, target, list, K);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret == K) &#123;</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            getNodesFromChildren(root.left, list, K - (ret + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root（1）满足root.val==target.val （2）祖先结点 K=K-向上回溯祖先的数目</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list  添加满足值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> K  距离K的路径</span></span><br><span class="line"><span class="comment"> * 实现根据以树根节点root进行中序遍历查找距离K路径的结点，并把满足的结点的值添加进list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNodesFromChildren</span><span class="params">(TreeNode&lt;T&gt; root, List&lt;T&gt; list, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getNodesFromChildren(root.left, list, K - <span class="number">1</span>);</span><br><span class="line">    getNodesFromChildren(root.right, list, K - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><h4 id="Annotate-Parent"><a href="#Annotate-Parent" class="headerlink" title="Annotate Parent"></a><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/solution/" target="_blank" rel="noopener">Annotate Parent</a></h4><p><strong>Intuition</strong></p><p>If we know the parent of every node <code>x</code>, we know all nodes that are distance <code>1</code> from <code>x</code>. We can then perform a breadth first search from the <code>target</code> node to find the answer.</p><p><strong>Algorithm</strong></p><p>We first do a depth first search where we annotate every node with information about it’s parent.</p><p>After, we do a breadth first search to find all nodes a distance <code>K</code> from the <code>target</code>.</p><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ul><li><p>深度搜索注释所有子结点的父亲结点，根节点的父亲结点为<code>null</code></p></li><li><p>以<code>target</code>结点为首层，递增路径，每次队列存放的结点<strong>只满足</strong>递增路径深度为相同列<a href="如何区分每次队列存放的结点**只满足**递增路径深度为相同？采用在递增路径深度相同的队列中添加null标志">^2</a></p></li><li><p>直至递增路径等于<code>k</code>路径长度，此时队列中的存放的结点即为满足元素</p></li></ul><h4 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">distanceK1</span><span class="params">(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    parents = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="comment">//dfs(root, parents);</span></span><br><span class="line">    dfs(root, <span class="keyword">null</span>);</span><br><span class="line">    List&lt;TreeNode&lt;T&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">null</span>);</span><br><span class="line">    queue.add(target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止回溯到已经遍历过的结点</span></span><br><span class="line">    Set&lt;TreeNode&lt;T&gt;&gt; seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">    seen.add(<span class="keyword">null</span>);</span><br><span class="line">    seen.add(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//移除队列的首元素（first）</span></span><br><span class="line">        TreeNode&lt;T&gt; node = ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll();</span><br><span class="line">        <span class="comment">//每次出队元素为null而且此时dist长度不等于k时，路径进1</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist == K) &#123;</span><br><span class="line">                List&lt;T&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;T&gt; t : queue)</span><br><span class="line">                    ans.add(t.val);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ++dist;</span><br><span class="line">            ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!seen.contains(node.left)) &#123;</span><br><span class="line">                seen.add(node.left);</span><br><span class="line">                <span class="comment">//添加元素到尾(tails)</span></span><br><span class="line">                ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!seen.contains(node.right)) &#123;</span><br><span class="line">                seen.add(node.right);</span><br><span class="line">                ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;T&gt; parent = parents.get(node);</span><br><span class="line">            <span class="keyword">if</span> (!seen.contains(parent)) &#123;</span><br><span class="line">                seen.add(parent);</span><br><span class="line">                ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.api.tree.Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任何实现equals类且都可以进行深度为K路径长度的检索</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTAllNodeDistanceK</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T dist[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> controlDiVa = <span class="number">0</span>;</span><br><span class="line">    List&lt;T&gt; list;</span><br><span class="line">    <span class="comment">//错误使用 Map&lt;TreeNode&lt;T&gt; node,TreeNode&lt;T&gt; parents&gt; parents;</span></span><br><span class="line">    Map&lt;TreeNode&lt;T&gt;, TreeNode&lt;T&gt;&gt; parents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T val;</span><br><span class="line">        TreeNode&lt;T&gt; left;</span><br><span class="line">        TreeNode&lt;T&gt; right;</span><br><span class="line"></span><br><span class="line">        TreeNode(T x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BTAllNodeDistanceK</span><span class="params">(T sour[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generat d constructor stub</span></span><br><span class="line">        <span class="keyword">this</span>.dist = sour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">distanceK</span><span class="params">(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || target == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        preOrder(root, target, list, K);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">preOrder</span><span class="params">(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, List&lt;T&gt; list, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val.equals(target.val)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            getNodesFromChildren(root.left, list, K - <span class="number">1</span>);</span><br><span class="line">            getNodesFromChildren(root.right, list, K - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//回溯作用，能够回溯到祖先和祖先的右孩子</span></span><br><span class="line">            <span class="keyword">int</span> ret = preOrder(root.left, target, list, K);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret == K) &#123;</span><br><span class="line">                    list.add(root.val);</span><br><span class="line">                    <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                getNodesFromChildren(root.right, list, K - (ret + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回溯作用，能够回溯到祖先和祖先的右孩子</span></span><br><span class="line">            ret = preOrder(root.left, target, list, K);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret == K) &#123;</span><br><span class="line">                    list.add(root.val);</span><br><span class="line">                    <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                getNodesFromChildren(root.left, list, K - (ret + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root（1）满足root.val==target.val （2）祖先结点 K=K-向上回溯祖先的数目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list                          添加满足值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> K                             距离K的路径</span></span><br><span class="line"><span class="comment">     *                                      实现根据以树根节点root进行中序遍历查找距离K路径的结点，并把满足的结点的值添加进list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNodesFromChildren</span><span class="params">(TreeNode&lt;T&gt; root, List&lt;T&gt; list, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getNodesFromChildren(root.left, list, K - <span class="number">1</span>);</span><br><span class="line">        getNodesFromChildren(root.right, list, K - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创造一颗二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> tN指向引用和调用函数root值引用不同，所以需要返回值使调用函数的root引用地址保持和tN引用地址一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">createTree</span><span class="params">(TreeNode&lt;T&gt; tN)</span> </span>&#123;</span><br><span class="line">        T tem = dist[controlDiVa];</span><br><span class="line">        controlDiVa++;</span><br><span class="line">        <span class="keyword">if</span> (tem == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tN = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tN = <span class="keyword">new</span> TreeNode&lt;T&gt;();</span><br><span class="line">            tN.val = tem;</span><br><span class="line">            tN.left = createTree(tN.left);</span><br><span class="line">            tN.right = createTree(tN.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现中序排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">" "</span>);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/****************************第一种方法查找********************************</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         int k=2;</span></span><br><span class="line"><span class="comment">         //必须满足上述条件的数组才能使用createTree方法建立一颗二叉树</span></span><br><span class="line"><span class="comment">         Integer[] sour= &#123;1,2,3,null,null,null,134,5,null,null,6,null,null&#125;;</span></span><br><span class="line"><span class="comment">         **</span></span><br><span class="line"><span class="comment">         *                            1</span></span><br><span class="line"><span class="comment">         *                     ////////\\\\\\\\</span></span><br><span class="line"><span class="comment">         *                    2               134</span></span><br><span class="line"><span class="comment">         *                ////\\\\         ////\\\\</span></span><br><span class="line"><span class="comment">         *               3       null      5       6</span></span><br><span class="line"><span class="comment">         *             //\\              //\\     //\\</span></span><br><span class="line"><span class="comment">         *         null   null        null  null  null null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         TreeNode&lt;Integer&gt; root=new TreeNode&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">         TreeNode&lt;Integer&gt; target=new TreeNode&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">         target.val=2;</span></span><br><span class="line"><span class="comment">         target.left=null;</span></span><br><span class="line"><span class="comment">         target.right=null;</span></span><br><span class="line"><span class="comment">         BTAllNodeDistanceK&lt;Integer&gt; a=new BTAllNodeDistanceK&lt;Integer&gt;(sour);</span></span><br><span class="line"><span class="comment">         root=a.createTree(root);</span></span><br><span class="line"><span class="comment">         a.distanceK(root,target,k);</span></span><br><span class="line"><span class="comment">         Iterator&lt;Integer&gt; ite=a.list.iterator();</span></span><br><span class="line"><span class="comment">         System.out.println("距离路径为"+k+"的值为：");</span></span><br><span class="line"><span class="comment">         while(ite.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">         System.out.println(ite.next());</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         ******************************************************************/</span></span><br><span class="line">        <span class="comment">//必须满足上述条件的数组才能使用createTree1方法建立一颗二叉树</span></span><br><span class="line">        Integer[] sour = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">/* 必须满足的树的结构</span></span><br><span class="line"><span class="comment">                                       3</span></span><br><span class="line"><span class="comment">                               //////// \\\\\\\\</span></span><br><span class="line"><span class="comment">                              5                 1</span></span><br><span class="line"><span class="comment">                          //// \\\\         //// \\\\</span></span><br><span class="line"><span class="comment">                         6          2      0         8</span></span><br><span class="line"><span class="comment">                       // \\      // \\</span></span><br><span class="line"><span class="comment">                    null   null  7     4</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        TreeNode&lt;Integer&gt; root;</span><br><span class="line">        TreeNode&lt;Integer&gt; target;</span><br><span class="line">        BTAllNodeDistanceK&lt;Integer&gt; a = <span class="keyword">new</span> BTAllNodeDistanceK&lt;&gt;(sour);</span><br><span class="line">        root = a.createTree1();</span><br><span class="line">        System.out.println(<span class="string">"1.测试是否能够生成二叉树："</span>);</span><br><span class="line">        a.inOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"2.测试是否能够查找到在指定树中指定树结点值的结点："</span>);</span><br><span class="line">        target = a.dfsForTarget(root, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"target.val:"</span> + target.val);</span><br><span class="line">        <span class="keyword">if</span> (target.left != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"if target.left != null target.left.val: "</span>+target.left.val);</span><br><span class="line">        <span class="keyword">if</span> (target.right != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"if target.right != null target.left.val: "</span>+target.right.val);</span><br><span class="line">        a.list=a.distanceK1(root,target,<span class="number">2</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; ite=a.list.iterator();</span><br><span class="line">        System.out.println(<span class="string">"距离路径为"</span>+<span class="number">2</span>+<span class="string">"的值为："</span>);</span><br><span class="line">        <span class="keyword">while</span>(ite.hasNext()) &#123;</span><br><span class="line">            System.out.println(ite.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">distanceK1</span><span class="params">(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        parents = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">//dfs(root, parents);</span></span><br><span class="line">        dfs(root, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;TreeNode&lt;T&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">null</span>);</span><br><span class="line">        queue.add(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//防止回溯到已经遍历过的结点</span></span><br><span class="line">        Set&lt;TreeNode&lt;T&gt;&gt; seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">        seen.add(<span class="keyword">null</span>);</span><br><span class="line">        seen.add(target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//移除队列的首元素（first）</span></span><br><span class="line">            TreeNode&lt;T&gt; node = ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll();</span><br><span class="line">            <span class="comment">//每次null路径进1</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist == K) &#123;</span><br><span class="line">                    List&lt;T&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;T&gt; t : queue)</span><br><span class="line">                        ans.add(t.val);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                ++dist;</span><br><span class="line">                ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(<span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!seen.contains(node.left)) &#123;</span><br><span class="line">                    seen.add(node.left);</span><br><span class="line">                    <span class="comment">//添加元素到尾(tails)</span></span><br><span class="line">                    ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!seen.contains(node.right)) &#123;</span><br><span class="line">                    seen.add(node.right);</span><br><span class="line">                    ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode&lt;T&gt; parent = parents.get(node);</span><br><span class="line">                <span class="keyword">if</span> (!seen.contains(parent)) &#123;</span><br><span class="line">                    seen.add(parent);</span><br><span class="line">                    ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创造一颗二叉树,存储值的数组需要满足特定结构</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">createTree1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = dist.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode&lt;T&gt; tN = <span class="keyword">new</span> TreeNode&lt;&gt;();</span><br><span class="line">        tN.val = dist[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        List&lt;TreeNode&lt;T&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(tN);</span><br><span class="line">        <span class="comment">//申明在作用域的上一层</span></span><br><span class="line">        TreeNode&lt;T&gt; parent;</span><br><span class="line">        TreeNode&lt;T&gt; tem;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">2</span> * i - <span class="number">1</span>) &lt; j) &#123;</span><br><span class="line"><span class="comment">/***********************错误代码*************************************</span></span><br><span class="line"><span class="comment"> *  parent不可能为null，因为每次可进入队列的元素必然new TreeNode&lt;T&gt;一次</span></span><br><span class="line"><span class="comment"> *******************************************************************/</span></span><br><span class="line"><span class="comment">//            parent=((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll();</span></span><br><span class="line"><span class="comment">//            if(parent==null)</span></span><br><span class="line"><span class="comment">//                throw new NullPointerException("不存在parent为null的结点");</span></span><br><span class="line"><span class="comment">//            tem = new TreeNode&lt;&gt;();</span></span><br><span class="line"><span class="comment">//            tem.val = dist[2 * i - 1];</span></span><br><span class="line"><span class="comment">//            parent.left = tem;</span></span><br><span class="line"><span class="comment">//            ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(tem);</span></span><br><span class="line"><span class="comment">/***********************正确代码*************************************</span></span><br><span class="line"><span class="comment"> *  添加数组元素是否为null的判定</span></span><br><span class="line"><span class="comment"> *******************************************************************/</span></span><br><span class="line"></span><br><span class="line">            parent = ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"不存在父亲为null的结点"</span>);</span><br><span class="line">            <span class="keyword">if</span> (dist[<span class="number">2</span> * i - <span class="number">1</span>] == <span class="keyword">null</span>)</span><br><span class="line">                ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tem = <span class="keyword">new</span> TreeNode&lt;&gt;();</span><br><span class="line">                tem.val = dist[<span class="number">2</span> * i - <span class="number">1</span>];</span><br><span class="line">                parent.left = tem;</span><br><span class="line">                ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(tem);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[<span class="number">2</span> * i] == <span class="keyword">null</span>)</span><br><span class="line">                    ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tem = <span class="keyword">new</span> TreeNode&lt;&gt;();</span><br><span class="line">                    tem.val = dist[<span class="number">2</span> * i];</span><br><span class="line">                    parent.right = tem;</span><br><span class="line">                    ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(tem);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * :leetcode提供解决方案</span></span><br><span class="line"><span class="comment">     * 把所有结点的父结点标记</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node   孩子结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父亲结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode&lt;T&gt; node, TreeNode&lt;T&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parents.put(node, parent);</span><br><span class="line">            dfs(node.left, node);</span><br><span class="line">            dfs(node.right, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * :自己模仿写的</span></span><br><span class="line"><span class="comment">     * 把所有结点的父结点标记</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root_    父结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parents_ 以孩子结点为key,父亲结点为value的标记集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(TreeNode&lt;T&gt; root_, Map parents_)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排除第一次进入时出现root_为null的情况</span></span><br><span class="line">        <span class="keyword">if</span> (root_ == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//递归基</span></span><br><span class="line">        <span class="keyword">if</span> (root_.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parents_.put(root_.left, root_);</span><br><span class="line">            dfs1(root_.left, parents_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root_.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parents_.put(root_.right, root_);</span><br><span class="line">            dfs1(root_.right, parents_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">dfsForTarget</span><span class="params">(TreeNode&lt;T&gt; root, T val)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;T&gt; tem;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.val.equals(val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            tem = dfsForTarget(root.left, val);</span><br><span class="line">            <span class="keyword">if</span> (tem != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> tem;</span><br><span class="line">            &#125;</span><br><span class="line">            tem = dfsForTarget(root.right, val);</span><br><span class="line">            <span class="keyword">if</span> (tem != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;863-All-Nodes-Distance-K-in-Binary-Tree&quot;&gt;&lt;a href=&quot;#863-All-Nodes-Distance-K-in-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;863. All Nodes
      
    
    </summary>
    
      <category term="algorithm" scheme="http://log.xiaohaoming.com/categories/algorithm/"/>
    
    
      <category term="quickSort" scheme="http://log.xiaohaoming.com/tags/quickSort/"/>
    
      <category term="algorithm" scheme="http://log.xiaohaoming.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用命令</title>
    <link href="http://log.xiaohaoming.com//2018/07/extension-MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>http://log.xiaohaoming.com//2018/07/extension-MySQL常用命令.html</id>
    <published>2018-07-09T16:49:37.414Z</published>
    <updated>2018-07-09T16:49:37.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h3><h4 id="查询表user所有字段信息"><a href="#查询表user所有字段信息" class="headerlink" title="查询表user所有字段信息"></a>查询表user所有字段信息</h4><pre><code>SELECT 字段 FROM 表；</code></pre><p><code>eg :SELECT * FROM user;</code></p><h4 id="选择db-test数据库"><a href="#选择db-test数据库" class="headerlink" title="选择db_test数据库"></a>选择db_test数据库</h4><pre><code>USE 数据库;</code></pre><p><code>eg :USE db_test;</code></p><h4 id="在表user插入一列名为name，类型为varchar，且不为NULL字段"><a href="#在表user插入一列名为name，类型为varchar，且不为NULL字段" class="headerlink" title="在表user插入一列名为name，类型为varchar，且不为NULL字段"></a>在表user插入一列名为name，类型为varchar，且不为NULL字段</h4><pre><code>ALTER TABLE 表 ADD 字段名 类型 xx;</code></pre><p><code>eg :ALTER TABLE user ADD name varchar(40) NOT NULL;</code></p><h4 id="删除表user中字段为id的一列"><a href="#删除表user中字段为id的一列" class="headerlink" title="删除表user中字段为id的一列"></a>删除表user中字段为id的一列</h4><pre><code>ALTER TABLE 表 DROP 字段名;</code></pre><p><code>eg :ALTER TABLE user DROP id;</code></p><h4 id="在表user中七个字段（Filed）插入一行数据"><a href="#在表user中七个字段（Filed）插入一行数据" class="headerlink" title="在表user中七个字段（Filed）插入一行数据"></a>在表user中七个字段（Filed）插入一行数据</h4><pre><code>INSERT INTO 表 VALUES(Field,Field,Field,Field);</code></pre><p><code>eg :INSERT INTO user(username,password,uid,name,email,sex,birthday) VALUES(&quot;ghu2&quot;,&quot;12312&quot;,&quot;1e0d8987-7c8d-4f9b-8cd4-2adba575b464&quot;,&quot;gy&quot;,&quot;twg&quot;,&quot;tfy&quot;,&quot;wf&quot;);</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySQL常用命令&quot;&gt;&lt;a href=&quot;#MySQL常用命令&quot; class=&quot;headerlink&quot; title=&quot;MySQL常用命令&quot;&gt;&lt;/a&gt;MySQL常用命令&lt;/h3&gt;&lt;h4 id=&quot;查询表user所有字段信息&quot;&gt;&lt;a href=&quot;#查询表user所有字段信
      
    
    </summary>
    
      <category term="extension" scheme="http://log.xiaohaoming.com/categories/extension/"/>
    
    
      <category term="mysql" scheme="http://log.xiaohaoming.com/tags/mysql/"/>
    
      <category term="command" scheme="http://log.xiaohaoming.com/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>SSLCertificateVerification）</title>
    <link href="http://log.xiaohaoming.com//2018/07/extension-SSLCertificateVerification-%E8%AF%81%E4%B9%A6.html"/>
    <id>http://log.xiaohaoming.com//2018/07/extension-SSLCertificateVerification-证书.html</id>
    <published>2018-07-05T08:15:57.116Z</published>
    <updated>2018-07-05T08:15:57.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SSL-Certificate-Verification-证书"><a href="#SSL-Certificate-Verification-证书" class="headerlink" title="SSL Certificate Verification_证书"></a>SSL Certificate Verification_证书</h3><p><a href="https://curl.haxx.se/docs/sslcerts.html" target="_blank" rel="noopener">SSL</a><br>SSL是的旧的名字，现在他被叫做TLS</p><h4 id="原生SSL"><a href="#原生SSL" class="headerlink" title="原生SSL"></a>原生SSL</h4><p>如果<code>libcurl</code>是用<code>Schannel</code>或者<code>Secure Transport</code>构造的（原生<code>SSL</code>库包含在<code>Windows</code>和<code>Mac OS x</code>)，那么这个不能适用你。向下滑获得<code>OS-native-engines</code>如何处理<code>SSL</code>证书。如果你是不确定，那么run“curl -V”和阅读结果 。如果版本字符串包含”<code>WinSSL</code>“，那么这个是使用<code>hannel support</code></p><h4 id="是关于可信"><a href="#是关于可信" class="headerlink" title="是关于可信"></a>是关于可信</h4><p>这个系统是关于可信的。在你的当地<code>CA</code>证书存储区，你有来自可信赖<code>CA</code>证书机构证书这个你能够使用来验证这个你看起来是有效的证书。他们是被签署通过你信赖的某一个<code>CAs</code>证书机构。<br>    你信赖这个CAs？你能够决定信赖一个相同的公司组这个你操作系统信赖的，或者一个组某一个知名浏览器信赖的。这些都基于你的信任。你应该意识到这个现代操作系统和浏览器是被启动信任上百个公司和最近几年<code>several such CAS</code>已经被发现时不可信的。</p><h4 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h4><p><code>libcurl</code>默认执行<code>peer</code>对等<code>SSL</code>证书验证。这个是被做通过使用能够被<code>SSL</code>库使用来确认对等服务器证书时有效的<code>CA</code>证书存储区。</p><pre><code>Note:If you communicate with HTTPS, FTPS or other TLS-using servers using  certificates that are signed by CAs present in the store, you can be sure that the remote server really is the one it claims to be.</code></pre><h4 id="忽略证书验证"><a href="#忽略证书验证" class="headerlink" title="忽略证书验证"></a>忽略证书验证</h4><p>如果远程服务器使用一个自签名证书，如果你没有安装CA证书存储区，如果服务器使用一个被并没有包含在你使用存储区CA证书签署，或者这个远程主机是一个<code>imposer</code>冒名顶替者<code>impersonting</code>扮演你喜爱的站点，但是你想从这个服务器传输文件，做下面的一种：</p><p>1: 告诉libcurl不要验证对等。使用libcurl禁用<code>curl_easy_setopt(curl,CURLOPT_SSL_VERIFYPEER,FALSE)</code><br>2: 使用<code>curl command line tool</code>禁用这个使用<code>-k/--insecure</code><br>3:  得到一个能够验证远程服务器CA 证书和当连接的时候使用恰当的选择来指定这个CA证书来证。<br>     <1>   对于<code>libcurl hacker</code>  <code>curl_easy_setopt(curl,CURLOPT_CAPATH,capath)</code><br>     <2>  <code>curl command line tool</code> <code>--cacert [file]</code><br>4: 为你服务器添加<code>CA</code>证书到已经存在默认的<code>CA</code> 证书存储区。默认的CA证书存储区能够在<code>compile</code>时间改变,即通过下面的配置选择：</2></1></p><ul><li><code>--with-ca-bundle=FILE</code><br>  Note:use the specified file as CA certificate store. CA certificates need to be concatenated in PEM format into this file</li><li><p><code>--with-ca-path=PATH</code><br>  Note:use the specified path as CA certificate store. CA certificates need to be stored as individual PEM files in this directory. You may need to run c_rehash after adding files there.</p></li><li><p>If neither of the two options is specified, configure will try to auto-detect a setting. It’s also<br>possible to explicitly not hardcode any default store but rely on the built in default the crypto library may provide instead. You can achieve that by passing both –without-ca-bundle and –without-ca-pathto the configure script.</p></li><li><p>If you use Internet Explorer, this is one way to get extract the CA cert for a particular server:</p><pre><code>&lt;1&gt;  View the certificate by double-clicking the padlock(挂锁)&lt;2&gt;  Find out where the CA certificate is kept (Certificate&gt; Authority Information Access&gt;URL)&lt;3&gt;  Get a copy of the crt file using curl&lt;4&gt;  Convert it from crt to PEM using the openssl tool: openssl x509 -inform DES -in     yourdownloaded.crt -out outcert.pem -text&lt;5&gt;  Add the &apos;outcert.pem&apos; to the CA certificate store or use it stand-alone as described below.If you use the &apos;openssl&apos; tool, this is one way to get extract the CA cert for a particular server: 1:openssl s_client -connect xxxxx.com:443 |tee logfile 2:type &quot;QUIT&quot;, followed by the &quot;ENTER&quot; key  3:The certificate will have &quot;BEGIN CERTIFICATE&quot; and &quot;END CERTIFICATE&quot; markers.If you want to see the data in the certificate, you can do: &quot;openssl x509 -inform PEM -in certfile -text -out certdata&quot; where certfile is the cert you extracted from logfile. Look in certdata.If you want to trust the certificate, you can add it to your CA certificate store or use it stand-alone as described. Just remember that the security is no better than the way you obtained the certificate.If you&apos;re using the curl command line tool, you can specify your own CA cert path by setting the environment variable CURL_CA_BUNDLE to the path of your choice.</code></pre></li><li><p>If you’re using the curl command line tool on Windows, curl will search for a CA cert file named “curl-ca-bundle.crt” in these directories and in this order:<br><1> application’s directory<br><2> current working directory<br><3> Windows System directory (e.g. C:\windows\system32)<br><4> Windows Directory (e.g. C:\windows)<br><5> all directories along %PATH%</5></4></3></2></1></p></li><li>Get a better/different/newer CA cert bundle! One option is to extract the one a recent Firefox browser uses by running ‘make ca-bundle’ in the curl build tree root, </li><li><p>or possibly download a version that was generated this way for you: CA Extract<br><1>Certificate Verification with NSS<br><2>Certificate Verification with Schannel and Secure Transport</2></1></p></li><li><p>如果libcurl是使用Schannel(Microsoft native TLS engine:验证得出本机目前使用这个built的)built或者苹果（省略）支持，那么libcurl将会任然执行对等验证，但是如果代替使用CAcertificate bundle，它将会使用这个built在OS里证书.这些相同证书出现在internet Options controls panel(under windows),任何用于证书的自定义安全规则都将得到遵守<br>  除非对等验证被禁用，否则Schannel将对证书运行CRL检查<br>  HTTPS proxy   </p><h3 id="SSL-certificate-problem-unable-to-get-local-issuer-certificate"><a href="#SSL-certificate-problem-unable-to-get-local-issuer-certificate" class="headerlink" title="SSL certificate problem: unable to get local issuer certificate"></a>SSL certificate problem: unable to get local issuer certificate</h3><p>意味着cUrl不信任 Verisign证书机构<br>  Note:VeriSign  的数字信任服务通过VeriSign的域名登记、数字认证和网上支付三大核心业务，在全球范围内建立起了一个可信的虚拟环境，使任何人在任何地点都能放心地进行数字交易和沟通。而数字证书业务是其起家的核心业务.VeriSign数字证书产品是目前市场上最完整的支持最多应用和最多设备的数字证书产品，主要包括： SSL 证书和代码签名证书。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SSL-Certificate-Verification-证书&quot;&gt;&lt;a href=&quot;#SSL-Certificate-Verification-证书&quot; class=&quot;headerlink&quot; title=&quot;SSL Certificate Verification_证
      
    
    </summary>
    
      <category term="extension" scheme="http://log.xiaohaoming.com/categories/extension/"/>
    
    
      <category term="SSL" scheme="http://log.xiaohaoming.com/tags/SSL/"/>
    
      <category term="extenstion" scheme="http://log.xiaohaoming.com/tags/extenstion/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令（更新）</title>
    <link href="http://log.xiaohaoming.com//2018/07/deploy-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89.html"/>
    <id>http://log.xiaohaoming.com//2018/07/deploy-Git常用命令（更新）.html</id>
    <published>2018-07-05T03:33:24.221Z</published>
    <updated>2018-07-05T03:33:24.221Z</updated>
    
    <content type="html"><![CDATA[<h3 id="提交代码时候，来确认谁提交的代码"><a href="#提交代码时候，来确认谁提交的代码" class="headerlink" title="提交代码时候，来确认谁提交的代码"></a>提交代码时候，来确认谁提交的代码</h3><pre><code>Note:所有命令在git bash命令行输入</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">$ git config --global user.name <span class="string">"Nautilus-Nemo"</span></span><br><span class="line">$ git config --global user.name <span class="string">"13612262974@163.com"</span></span><br></pre></td></tr></table></figure><p>确认上面的配置是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">$ git config --global user.name</span><br><span class="line">$ git config --global user.name</span><br></pre></td></tr></table></figure><h3 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h3><p> 仓库<code>repository</code>是用于保存版本管理所需信息的地方，所有本地提交的代码都会保存在代码仓库中，<br> 如果有需要还可以推送到远程仓库中</p><ul><li>进入所需要创建代码仓库的项目的目录 <code>$ cd [your project directory]</code></li><li><code>$ git init</code></li></ul><pre><code>Note:仓库建立以后，项目的根目录会生成一个隐藏的`.git`文件夹,这个文件就是来记录本地  所有的`git`操作。如果要删除本地仓库的话，只需要删除这个文件夹</code></pre><h3 id="查看所有本地的git操作"><a href="#查看所有本地的git操作" class="headerlink" title="查看所有本地的git操作"></a>查看所有本地的git操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls al</span><br></pre></td></tr></table></figure><h3 id="提交本地代码"><a href="#提交本地代码" class="headerlink" title="提交本地代码"></a>提交本地代码</h3><ul><li><p>添加一个文件 $ git add (your file)</p></li><li><p>添加一个目录 $ git add (your directory)</p></li><li><p>添加某项目下的所有文件 $  git add .</p></li><li><p>添加完所需要的文件后，提交 <code>$ git commit -m &quot;First commit.&quot;</code></p><p>  Note:我们一般通过-m参数来加上提交的文件信息</p></li></ul><h3 id="发布至远程仓库"><a href="#发布至远程仓库" class="headerlink" title="发布至远程仓库"></a>发布至远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>其中origin部分指定的是远程版本库的Git地址，master部分指定的是同步到哪一个分支上</p><h4 id="远程版本库上的修改同步到本地"><a href="#远程版本库上的修改同步到本地" class="headerlink" title="远程版本库上的修改同步到本地"></a>远程版本库上的修改同步到本地</h4><ol><li><p>Git提供了两种命令来完成此功能，分别是<code>fetch</code>和<code>pull</code>,<code>fetch</code>的语法规则和<code>push</code>差不多</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br></pre></td></tr></table></figure></li><li><p>执行了这个命令后，就会将远程版本库上的代码同步到本地，不过同步下来的代码并不会合并到任何分支上，而是会存放到<code>origin/master</code>分支。</p></li><li><p>我们可以通过diff命令来查看远程版本库到底修改了那些东西:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff origin/master</span><br></pre></td></tr></table></figure></li><li><p>调用<code>merge</code>命令将<code>origin/master</code>分支上的修改合并到主分支上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br></pre></td></tr></table></figure></li></ol><h4 id="pull命令"><a href="#pull命令" class="headerlink" title="pull命令"></a>pull命令</h4><p>则是将fetch和merge这两个命令放在一起执行。他可以从远程版本库上获取最新的代码并且合并到本地上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><h3 id="复制Github中已有的开源库"><a href="#复制Github中已有的开源库" class="headerlink" title="复制Github中已有的开源库"></a>复制Github中已有的开源库</h3><ol><li>复制这个开源库的url：即右上角蓝色<code>clone or download</code>按钮</li><li><p>打开<code>git bash</code>,<code>cd</code>至你要复制的项目目录，使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> (url)</span><br></pre></td></tr></table></figure><p> Note:可能需要把所有clone的文件复制到上一层，因为上一层才是项目的根目录，要注意把隐藏文件.git复制过去</p></li></ol><h3 id="分支的用法"><a href="#分支的用法" class="headerlink" title="分支的用法"></a>分支的用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p>查看有那些分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch version1.0</span><br></pre></td></tr></table></figure></p><p>创建了一个名为version1.0的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>切换到master分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge -D version1.0</span><br></pre></td></tr></table></figure><p>使用merge命令来完成合并操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D version1.0</span><br></pre></td></tr></table></figure><p>删除分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --repo=https://github.com/Nautilus-Nemo/coolweather</span><br></pre></td></tr></table></figure></p><p>提交到具体的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p>确定提交的库</p><p>[详情]  (file:///C:/software/Git/mingw64/share/doc/git-doc/git-push.html#URLS）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;提交代码时候，来确认谁提交的代码&quot;&gt;&lt;a href=&quot;#提交代码时候，来确认谁提交的代码&quot; class=&quot;headerlink&quot; title=&quot;提交代码时候，来确认谁提交的代码&quot;&gt;&lt;/a&gt;提交代码时候，来确认谁提交的代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Note:所
      
    
    </summary>
    
      <category term="deploy" scheme="http://log.xiaohaoming.com/categories/deploy/"/>
    
    
      <category term="Git" scheme="http://log.xiaohaoming.com/tags/Git/"/>
    
      <category term="deploy" scheme="http://log.xiaohaoming.com/tags/deploy/"/>
    
      <category term="tool" scheme="http://log.xiaohaoming.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>开始使用GitHub</title>
    <link href="http://log.xiaohaoming.com//2018/06/deploy-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8GitHub.html"/>
    <id>http://log.xiaohaoming.com//2018/06/deploy-开始使用GitHub.html</id>
    <published>2018-06-29T15:11:03.343Z</published>
    <updated>2018-06-29T15:11:03.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始使用GitHub"><a href="#开始使用GitHub" class="headerlink" title="开始使用GitHub"></a>开始使用GitHub</h1><h2 id="什么是GitHub？"><a href="#什么是GitHub？" class="headerlink" title="什么是GitHub？"></a>什么是GitHub？</h2><h4 id="GitHub是一个用于版本控制和合并代码托管平台。它让你和你的工作伙伴工作在同一个项目不管你们两者是否相隔天涯海角。"><a href="#GitHub是一个用于版本控制和合并代码托管平台。它让你和你的工作伙伴工作在同一个项目不管你们两者是否相隔天涯海角。" class="headerlink" title="GitHub是一个用于版本控制和合并代码托管平台。它让你和你的工作伙伴工作在同一个项目不管你们两者是否相隔天涯海角。"></a>GitHub是一个用于版本控制和合并代码托管平台。它让你和你的工作伙伴工作在同一个项目不管你们两者是否相隔天涯海角。</h4><h2 id="创造一个Respository"><a href="#创造一个Respository" class="headerlink" title="创造一个Respository"></a>创造一个Respository</h2><h4 id="一个respository是通常用来组织一个项目。Respository能够包含文件夹和文件，图像，视频，电子表格，和数据集等任何东西你的项目需要的。我们建议包括一个README，或者一个文件包含你的项目信息。Github使它容易去增加一个在相同时间你去创造一个新的Respository（GitHub可以在创建新存储库的同时轻松添加一个）。它也提供其他常用的选择。例：license-file"><a href="#一个respository是通常用来组织一个项目。Respository能够包含文件夹和文件，图像，视频，电子表格，和数据集等任何东西你的项目需要的。我们建议包括一个README，或者一个文件包含你的项目信息。Github使它容易去增加一个在相同时间你去创造一个新的Respository（GitHub可以在创建新存储库的同时轻松添加一个）。它也提供其他常用的选择。例：license-file" class="headerlink" title="一个respository是通常用来组织一个项目。Respository能够包含文件夹和文件，图像，视频，电子表格，和数据集等任何东西你的项目需要的。我们建议包括一个README，或者一个文件包含你的项目信息。Github使它容易去增加一个在相同时间你去创造一个新的Respository（GitHub可以在创建新存储库的同时轻松添加一个）。它也提供其他常用的选择。例：license file"></a>一个<code>respository</code>是通常用来组织一个项目。Respository能够包含文件夹和文件，图像，视频，电子表格，和数据集等任何东西你的项目需要的。我们建议包括一个README，或者一个文件包含你的项目信息。Github使它容易去增加一个在相同时间你去创造一个新的<code>Respository</code>（GitHub可以在创建新存储库的同时轻松添加一个）。它也提供其他常用的选择。例：<code>license file</code></h4><ul><li>在右上角，在你的头像（avatar）或身份证（identicon)旁边,点击+和选择NEW repository</li><li>给你的repository取个名字。例：Hello_world</li><li>写一个简短的描述</li><li>选择初始化这个repository with a README.</li></ul><h2 id="创造一个Branch"><a href="#创造一个Branch" class="headerlink" title="创造一个Branch"></a>创造一个Branch</h2><h4 id="Branching-是一种方式工作在同一时间同一个库中不同的版本。默认的你的repository有一个branch被叫做master-我们经常使用branches来在committing他们到master以前实验和编辑。什么时候你创造一个branch从master-branch-你是制造一个copy，或者快照-snapshot-他人在master分支上工作时对分支进行了更改-你能获得这些更新。"><a href="#Branching-是一种方式工作在同一时间同一个库中不同的版本。默认的你的repository有一个branch被叫做master-我们经常使用branches来在committing他们到master以前实验和编辑。什么时候你创造一个branch从master-branch-你是制造一个copy，或者快照-snapshot-他人在master分支上工作时对分支进行了更改-你能获得这些更新。" class="headerlink" title="Branching 是一种方式工作在同一时间同一个库中不同的版本。默认的你的repository有一个branch被叫做master.我们经常使用branches来在committing他们到master以前实验和编辑。什么时候你创造一个branch从master branch,你是制造一个copy，或者快照(snapshot).他人在master分支上工作时对分支进行了更改,你能获得这些更新。"></a>Branching 是一种方式工作在同一时间同一个库中不同的版本。默认的你的repository有一个branch被叫做master.我们经常使用branches来在committing他们到master以前实验和编辑。什么时候你创造一个branch从master branch,你是制造一个copy，或者快照(snapshot).他人在master分支上工作时对分支进行了更改,你能获得这些更新。</h4><pre><code>你曾经存储过不同的文件版本？像这样story.txtstory-joe-edit.txtstory-joe-edit-reviewed.txtBranches在Github repository完成相同的目标</code></pre><ul><li>先去到你新创建的repository</li><li>点击文件清单上面叫Branch:master下拉项。</li><li>在新的分支文本框打上一个分支名字</li><li>选择蓝色Create Branch框或者点击”Enter”在你的键盘。</li></ul><h2 id="对文件做修改和push他们到GitHub-as-commits"><a href="#对文件做修改和push他们到GitHub-as-commits" class="headerlink" title="对文件做修改和push他们到GitHub as commits"></a>对文件做修改和push他们到GitHub as commits</h2><h4 id="在Github-存储改变是被叫做commits-每个commit有一个相关联的来描述解释变化commit信息。Commit信息能够抓住历史中的变化，所以其他的contributor能够理解你做了什么和为什么这样做"><a href="#在Github-存储改变是被叫做commits-每个commit有一个相关联的来描述解释变化commit信息。Commit信息能够抓住历史中的变化，所以其他的contributor能够理解你做了什么和为什么这样做" class="headerlink" title="在Github,存储改变是被叫做commits.每个commit有一个相关联的来描述解释变化commit信息。Commit信息能够抓住历史中的变化，所以其他的contributor能够理解你做了什么和为什么这样做"></a>在Github,存储改变是被叫做commits.每个commit有一个相关联的来描述解释变化commit信息。Commit信息能够抓住历史中的变化，所以其他的contributor能够理解你做了什么和为什么这样做</h4><p><a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="noopener">具体操作步骤</a></p><h2 id="打开和merge一个pull-request"><a href="#打开和merge一个pull-request" class="headerlink" title="打开和merge一个pull request"></a>打开和merge一个pull request</h2><h4 id="Pull-Request-是的在Github合并的核心-什么时候你打开了一个pull-request-你是正在提出你的改变和请求其他人review和pull-in你的contribution（并要求有人审查并提交你的贡献）和融合他们到他们的分支。pull-请求展示两个分支的diffs，或者不同。"><a href="#Pull-Request-是的在Github合并的核心-什么时候你打开了一个pull-request-你是正在提出你的改变和请求其他人review和pull-in你的contribution（并要求有人审查并提交你的贡献）和融合他们到他们的分支。pull-请求展示两个分支的diffs，或者不同。" class="headerlink" title="Pull Request 是的在Github合并的核心.什么时候你打开了一个pull request,你是正在提出你的改变和请求其他人review和pull in你的contribution（并要求有人审查并提交你的贡献）和融合他们到他们的分支。pull 请求展示两个分支的diffs，或者不同。"></a>Pull Request 是的在Github合并的核心.什么时候你打开了一个pull request,你是正在提出你的改变和请求其他人review和pull in你的contribution（并要求有人审查并提交你的贡献）和融合他们到他们的分支。pull 请求展示两个分支的diffs，或者不同。</h4><h4 id="Gihub-mention-system"><a href="#Gihub-mention-system" class="headerlink" title="Gihub@mention system"></a><a href="https://help.github.com/articles/about-writing-and-formatting-on-github/#text-formatting-toolbar" target="_blank" rel="noopener">Gihub@mention system</a></h4><h4 id="你能询问反馈从指定人们或者队伍。"><a href="#你能询问反馈从指定人们或者队伍。" class="headerlink" title="你能询问反馈从指定人们或者队伍。"></a>你能询问反馈从指定人们或者队伍。</h4><p><a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="noopener">具体操作步骤</a></p><h4 id="融合一个分支到主分支"><a href="#融合一个分支到主分支" class="headerlink" title="融合一个分支到主分支"></a>融合一个分支到主分支</h4><p><a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="noopener">具体操作步骤</a></p><pre><code>To learn more about the power of Pull Requests, we recommend reading the GitHub Flow Guide`https://guides.github.com/introduction/flow/`. You might also visit GitHub Explore`https://github.com/explore` and   get involved in an Open Source project </code></pre><h2 id="Connecting-to-GiHub-with-SSH"><a href="#Connecting-to-GiHub-with-SSH" class="headerlink" title="Connecting to GiHub with SSH"></a>Connecting to GiHub with SSH</h2><h4 id="使用SSH协议，你能连接和认证远程服务器和服务。使用SSH-keys-你能连接Github不需要提供你的用户名和密码在每一次登陆网站"><a href="#使用SSH协议，你能连接和认证远程服务器和服务。使用SSH-keys-你能连接Github不需要提供你的用户名和密码在每一次登陆网站" class="headerlink" title="使用SSH协议，你能连接和认证远程服务器和服务。使用SSH keys,你能连接Github不需要提供你的用户名和密码在每一次登陆网站"></a>使用SSH协议，你能连接和认证远程服务器和服务。使用SSH keys,你能连接Github不需要提供你的用户名和密码在每一次登陆网站</h4><pre><code>当您设置SSH时，您将生成一个SSH密钥并将其添加到ssh-agent，然后将密钥添加到您的 GitHub帐户。将SSH密钥添加到ssh-agent.可确保您的SSH密钥通过使用密码短语具有额外 的安全层。有关更多信息，请参阅“ 使用SSH密钥密码”。要将SSH密钥与使用SAML单点登录 的组织拥有的存储库一起使用，您需要先对其进行授权。有关更多信息，请参阅“ 授权SSH密 钥以用于SAML单一登录组织。”我们建议您定期查看您的SSH密钥列表并撤销任何无效或已被入侵的密钥。</code></pre><p><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">具体生成SSH或者其他步骤</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开始使用GitHub&quot;&gt;&lt;a href=&quot;#开始使用GitHub&quot; class=&quot;headerlink&quot; title=&quot;开始使用GitHub&quot;&gt;&lt;/a&gt;开始使用GitHub&lt;/h1&gt;&lt;h2 id=&quot;什么是GitHub？&quot;&gt;&lt;a href=&quot;#什么是GitHub？&quot;
      
    
    </summary>
    
      <category term="deploy" scheme="http://log.xiaohaoming.com/categories/deploy/"/>
    
    
      <category term="deploy" scheme="http://log.xiaohaoming.com/tags/deploy/"/>
    
      <category term="tool" scheme="http://log.xiaohaoming.com/tags/tool/"/>
    
      <category term="Github" scheme="http://log.xiaohaoming.com/tags/Github/"/>
    
  </entry>
  
</feed>
