<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F%2F2018%2F07%2Falgorithm-863-AllNodesDistanceKinBinaryTree.html</url>
    <content type="text"><![CDATA[863. All Nodes Distance K in Binary Tree描述我们将会给予一个二叉树^1，一个target结点，和一个整数值K。 返回距离target结点为K路径长度的所有结点的值的集合。答案能够返回以任何顺序。 We are given a binary tree (with root node root), a target node, and an integer value K.Return a list of the values of all nodes that have a distance K from the target node. The answer can be returned in any order. 是否能够解决不能，通过查看此题的solution和discuss的大神操作，查看解题思路和代码snippet，摘录以下： 方案一步骤： 先遍历结点，采用中序遍历递归 如果发现target结点，遍历子结点添加距离target路径为K的结点的值,采用中序遍历递归的回溯作用查找距离target路径为K的结点的值 如果没有发现target结点，递归直至结点为null 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public List&lt;T&gt; distanceK(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, int K) &#123; if (root == null || target == null) return null; list = new ArrayList&lt;T&gt;(); preOrder(root, target, list, K); return list; &#125;private int preOrder(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, List&lt;T&gt; list, int K) &#123; if (root == null) return -1; if (root.val.equals(target.val)) &#123; //k == 0 的情况 //当K为0时，只存在它本身，没必要在遍历 if (K == 0) &#123; list.add(root.val); return 1; &#125; getNodesFromChildren(root.left, list, K - 1); getNodesFromChildren(root.right, list, K - 1); return 1; &#125; else &#123; //回溯作用，能够回溯到祖先和祖先的右孩子 //在找到target结点后，此时ret返回值大于0，所以开始进行上述回溯操作 int ret = preOrder(root.left, target, list, K); if (ret &gt;= 0) &#123; //K大于等于1的情况 if (ret == K) &#123; list.add(root.val); return ret + 1; &#125; getNodesFromChildren(root.right, list, K - (ret + 1)); return ret + 1; &#125; //回溯作用，能够回溯到祖先和祖先的右孩子 ret = preOrder(root.left, target, list, K); if (ret &gt;= 0) &#123; if (ret == K) &#123; list.add(root.val); return ret + 1; &#125; getNodesFromChildren(root.left, list, K - (ret + 1)); return ret + 1; &#125; &#125; return -1;&#125;/** * @param root（1）满足root.val==target.val （2）祖先结点 K=K-向上回溯祖先的数目 * @param list 添加满足值 * @param K 距离K的路径 * 实现根据以树根节点root进行中序遍历查找距离K路径的结点，并把满足的结点的值添加进list */private void getNodesFromChildren(TreeNode&lt;T&gt; root, List&lt;T&gt; list, int K) &#123; if (root == null) return; if (K == 0) &#123; list.add(root.val); return; &#125; getNodesFromChildren(root.left, list, K - 1); getNodesFromChildren(root.right, list, K - 1);&#125; 方案二Annotate ParentIntuition If we know the parent of every node x, we know all nodes that are distance 1 from x. We can then perform a breadth first search from the target node to find the answer. Algorithm We first do a depth first search where we annotate every node with information about it’s parent. After, we do a breadth first search to find all nodes a distance K from the target. 步骤： 深度搜索注释所有子结点的父亲结点，根节点的父亲结点为null 以target结点为首层，递增路径，每次队列存放的结点只满足递增路径深度为相同列^2 直至递增路径等于k路径长度，此时队列中的存放的结点即为满足元素 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 public List&lt;T&gt; distanceK1(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, int K) &#123; parents = new HashMap(); //dfs(root, parents); dfs(root, null); List&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.add(null); queue.add(target); //防止回溯到已经遍历过的结点 Set&lt;TreeNode&lt;T&gt;&gt; seen = new HashSet(); seen.add(null); seen.add(target); int dist = 0; while (!queue.isEmpty()) &#123; //移除队列的首元素（first） TreeNode&lt;T&gt; node = ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll(); //每次出队元素为null而且此时dist长度不等于k时，路径进1 if (node == null) &#123; if (dist == K) &#123; List&lt;T&gt; ans = new ArrayList&lt;&gt;(); for (TreeNode&lt;T&gt; t : queue) ans.add(t.val); return ans; &#125; ++dist; ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(null); &#125; else &#123; if (!seen.contains(node.left)) &#123; seen.add(node.left); //添加元素到尾(tails) ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.left); &#125; if (!seen.contains(node.right)) &#123; seen.add(node.right); ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.right); &#125; TreeNode&lt;T&gt; parent = parents.get(node); if (!seen.contains(parent)) &#123; seen.add(parent); ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(parent); &#125; &#125; &#125; return new ArrayList&lt;&gt;();&#125; 完整测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363package leetcode;import jdk.nashorn.api.tree.Tree;import java.util.*;/** * 任何实现equals类且都可以进行深度为K路径长度的检索 * * @param &lt;T&gt; 泛型类 */public class BTAllNodeDistanceK&lt;T&gt; &#123; private T dist[]; private static int controlDiVa = 0; List&lt;T&gt; list; //错误使用 Map&lt;TreeNode&lt;T&gt; node,TreeNode&lt;T&gt; parents&gt; parents; Map&lt;TreeNode&lt;T&gt;, TreeNode&lt;T&gt;&gt; parents; //Definition for a binary tree node. public static class TreeNode&lt;T&gt; &#123; T val; TreeNode&lt;T&gt; left; TreeNode&lt;T&gt; right; TreeNode(T x) &#123; val = x; &#125; public TreeNode() &#123; &#125; &#125; public BTAllNodeDistanceK(T sour[]) &#123; // TODO Auto-generat d constructor stub this.dist = sour; &#125; public List&lt;T&gt; distanceK(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, int K) &#123; if (root == null || target == null) return null; list = new ArrayList&lt;T&gt;(); preOrder(root, target, list, K); return list; &#125; private int preOrder(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, List&lt;T&gt; list, int K) &#123; if (root == null) return -1; if (root.val.equals(target.val)) &#123; if (K == 0) &#123; list.add(root.val); return 1; &#125; getNodesFromChildren(root.left, list, K - 1); getNodesFromChildren(root.right, list, K - 1); return 1; &#125; else &#123; //回溯作用，能够回溯到祖先和祖先的右孩子 int ret = preOrder(root.left, target, list, K); if (ret &gt;= 0) &#123; if (ret == K) &#123; list.add(root.val); return ret + 1; &#125; getNodesFromChildren(root.right, list, K - (ret + 1)); return ret + 1; &#125; //回溯作用，能够回溯到祖先和祖先的右孩子 ret = preOrder(root.left, target, list, K); if (ret &gt;= 0) &#123; if (ret == K) &#123; list.add(root.val); return ret + 1; &#125; getNodesFromChildren(root.left, list, K - (ret + 1)); return ret + 1; &#125; &#125; return -1; &#125; /** * @param root（1）满足root.val==target.val （2）祖先结点 K=K-向上回溯祖先的数目 * @param list 添加满足值 * @param K 距离K的路径 * 实现根据以树根节点root进行中序遍历查找距离K路径的结点，并把满足的结点的值添加进list */ private void getNodesFromChildren(TreeNode&lt;T&gt; root, List&lt;T&gt; list, int K) &#123; if (root == null) return; if (K == 0) &#123; list.add(root.val); return; &#125; getNodesFromChildren(root.left, list, K - 1); getNodesFromChildren(root.right, list, K - 1); &#125; /** * 创造一颗二叉树 * * @param tN * @return tN指向引用和调用函数root值引用不同，所以需要返回值使调用函数的root引用地址保持和tN引用地址一样 */ public TreeNode&lt;T&gt; createTree(TreeNode&lt;T&gt; tN) &#123; T tem = dist[controlDiVa]; controlDiVa++; if (tem == null) &#123; return tN = null; &#125; else &#123; tN = new TreeNode&lt;T&gt;(); tN.val = tem; tN.left = createTree(tN.left); tN.right = createTree(tN.right); &#125; return tN; &#125; /** * 实现中序排序 * * @param root 根结点 */ public void inOrder(TreeNode&lt;T&gt; root) &#123; if (root == null) &#123; return; &#125; inOrder(root.left); System.out.print(root.val + " "); inOrder(root.right); &#125; public static void main(String[] args) &#123; /****************************第一种方法查找******************************** * int k=2; //必须满足上述条件的数组才能使用createTree方法建立一颗二叉树 Integer[] sour= &#123;1,2,3,null,null,null,134,5,null,null,6,null,null&#125;; ** * 1 * ////////\\\\\\\\ * 2 134 * ////\\\\ ////\\\\ * 3 null 5 6 * //\\ //\\ //\\ * null null null null null null * TreeNode&lt;Integer&gt; root=new TreeNode&lt;Integer&gt;(); TreeNode&lt;Integer&gt; target=new TreeNode&lt;Integer&gt;(); target.val=2; target.left=null; target.right=null; BTAllNodeDistanceK&lt;Integer&gt; a=new BTAllNodeDistanceK&lt;Integer&gt;(sour); root=a.createTree(root); a.distanceK(root,target,k); Iterator&lt;Integer&gt; ite=a.list.iterator(); System.out.println("距离路径为"+k+"的值为："); while(ite.hasNext()) &#123; System.out.println(ite.next()); &#125; ******************************************************************/ //必须满足上述条件的数组才能使用createTree1方法建立一颗二叉树 Integer[] sour = &#123;3, 5, 1, 6, 2, 0, 8, null, null, 7, 4&#125;; /* 必须满足的树的结构 3 //////// \\\\\\\\ 5 1 //// \\\\ //// \\\\ 6 2 0 8 // \\ // \\ null null 7 4 */ TreeNode&lt;Integer&gt; root; TreeNode&lt;Integer&gt; target; BTAllNodeDistanceK&lt;Integer&gt; a = new BTAllNodeDistanceK&lt;&gt;(sour); root = a.createTree1(); System.out.println("1.测试是否能够生成二叉树："); a.inOrder(root); System.out.println(); System.out.println("2.测试是否能够查找到在指定树中指定树结点值的结点："); target = a.dfsForTarget(root, 5); System.out.println("target.val:" + target.val); if (target.left != null) System.out.println("if target.left != null target.left.val: "+target.left.val); if (target.right != null) System.out.println("if target.right != null target.left.val: "+target.right.val); a.list=a.distanceK1(root,target,2); Iterator&lt;Integer&gt; ite=a.list.iterator(); System.out.println("距离路径为"+2+"的值为："); while(ite.hasNext()) &#123; System.out.println(ite.next()); &#125; &#125; public List&lt;T&gt; distanceK1(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, int K) &#123; parents = new HashMap(); //dfs(root, parents); dfs(root, null); List&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.add(null); queue.add(target); //防止回溯到已经遍历过的结点 Set&lt;TreeNode&lt;T&gt;&gt; seen = new HashSet(); seen.add(null); seen.add(target); int dist = 0; while (!queue.isEmpty()) &#123; //移除队列的首元素（first） TreeNode&lt;T&gt; node = ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll(); //每次null路径进1 if (node == null) &#123; if (dist == K) &#123; List&lt;T&gt; ans = new ArrayList&lt;&gt;(); for (TreeNode&lt;T&gt; t : queue) ans.add(t.val); return ans; &#125; ++dist; ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(null); &#125; else &#123; if (!seen.contains(node.left)) &#123; seen.add(node.left); //添加元素到尾(tails) ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.left); &#125; if (!seen.contains(node.right)) &#123; seen.add(node.right); ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.right); &#125; TreeNode&lt;T&gt; parent = parents.get(node); if (!seen.contains(parent)) &#123; seen.add(parent); ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(parent); &#125; &#125; &#125; return new ArrayList&lt;&gt;(); &#125; /** * 创造一颗二叉树,存储值的数组需要满足特定结构 * * @return root */ public TreeNode&lt;T&gt; createTree1() &#123; int j = dist.length; int i = 1; if (j == 0) &#123; return null; &#125; TreeNode&lt;T&gt; tN = new TreeNode&lt;&gt;(); tN.val = dist[0]; List&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.add(tN); //申明在作用域的上一层 TreeNode&lt;T&gt; parent; TreeNode&lt;T&gt; tem; while ((2 * i - 1) &lt; j) &#123;/***********************错误代码************************************* * parent不可能为null，因为每次可进入队列的元素必然new TreeNode&lt;T&gt;一次 *******************************************************************/// parent=((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll();// if(parent==null)// throw new NullPointerException("不存在parent为null的结点");// tem = new TreeNode&lt;&gt;();// tem.val = dist[2 * i - 1];// parent.left = tem;// ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(tem);/***********************正确代码************************************* * 添加数组元素是否为null的判定 *******************************************************************/ parent = ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll(); if (parent == null) throw new NullPointerException("不存在父亲为null的结点"); if (dist[2 * i - 1] == null) ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(null); else &#123; tem = new TreeNode&lt;&gt;(); tem.val = dist[2 * i - 1]; parent.left = tem; ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(tem); &#125; if (2 * i &lt; j) &#123; if (dist[2 * i] == null) ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(null); else &#123; tem = new TreeNode&lt;&gt;(); tem.val = dist[2 * i]; parent.right = tem; ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(tem); &#125; &#125; i++; &#125; return tN; &#125; /** * :leetcode提供解决方案 * 把所有结点的父结点标记 * * @param node 孩子结点 * @param parent 父亲结点 */ private void dfs(TreeNode&lt;T&gt; node, TreeNode&lt;T&gt; parent) &#123; if (node != null) &#123; parents.put(node, parent); dfs(node.left, node); dfs(node.right, node); &#125; &#125; /** * :自己模仿写的 * 把所有结点的父结点标记 * * @param root_ 父结点 * @param parents_ 以孩子结点为key,父亲结点为value的标记集合 */ private void dfs1(TreeNode&lt;T&gt; root_, Map parents_) &#123; //排除第一次进入时出现root_为null的情况 if (root_ == null) return; //递归基 if (root_.left != null) &#123; parents_.put(root_.left, root_); dfs1(root_.left, parents_); &#125; if (root_.right != null) &#123; parents_.put(root_.right, root_); dfs1(root_.right, parents_); &#125; return; &#125; public TreeNode&lt;T&gt; dfsForTarget(TreeNode&lt;T&gt; root, T val) &#123; TreeNode&lt;T&gt; tem; if (root != null) &#123; if (root.val.equals(val)) &#123; return root; &#125; tem = dfsForTarget(root.left, val); if (tem != null) &#123; return tem; &#125; tem = dfsForTarget(root.right, val); if (tem != null) return tem; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>quickSort</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题解决]]></title>
    <url>%2F%2F2018%2F07%2Fextension-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[问题解决(1) 导入.jar文件可执行文件与eclipse需要重写遇到did not contain the main type的原因导入后实际为普通文件形式，不属于src文件，不能运行，*.jar里面的库重新build path导入，其它.java复制进去 其他可能造成的原因请看 (2) 未在jdk中找到javax.xml.blind（classnotFoundException)jdk9.0.1已经抛弃javax.xml.blind包，从maven导入找到要导入的包及依赖库描述，建立一个maven项目artifact，在pom.xml中加入依赖dependency具体参考 (3) WARNING: An illegal reflective access operation has occurredWARNING: Illegal reflective access by com.sun.xml.bind.v2.runtime.reflect.opt.Injector (file:/C:/Users/13612/.m2/repository/com/sun/xml/bind/jaxb-impl/2.3.0/jaxb-impl-2.3.0.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int) WARNING: Please consider reporting this to the maintainercom.sun.xml.bind.v2.runtime.reflect.opt.Injector WARNING: Use –illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release原因：jdk9加入的安全解决方案 123456789101: public static void main(String[] args) &#123; //屏蔽掉非法反射访问，JDK9 StudentMessagHandler.disableWarning();//主要这个语句 StudentMessagHandler smh=new StudentMessagHandler( "C:\\data\\（含预警1.0）大一、大二、大三通讯录\\" + "（含预警）大一、大二、大三通讯录\\学生通讯录\\16级\\160801.xlsx"); for(String str:smh.randomMacth(5)) &#123; System.out.println(str); &#125; &#125; 2: StackOverflow查找问题解决方案 (4) 405 method not allowed原因 在尝试访问endpoint使用浏览器工具，然而，什么嘛时候打印资源URL在浏览器框，是正在执行request请求，这和是默认的因此，浏览器不能给你灵活的测试REST API，你只能执行GET请求。 解决方案 为了测试rest API，你应该使用正确的工具。有下列几种：CURL,PostMan等 具体请看 (5) curl安装 进入官网 具体请看 (6) the type** is not accessible​ 用eclipse build path导入classpath or module path存在，但通过以Maven形式导入，不存在这种问题 深层封装问题，未解决。 (7) 实参和形参的区别请看DeleteLinkedNodeFromTO（packet Algorithm） 参考 (8) Could not instantiate TestExecutionListenerSpecify custom listener classes or make the default listener classes (and their required dependencies) available. Offending class: [javax/servlet/ServletContext]原因没有提供存在该包lib，如果没有使用web一些包，可以不需要管这个问题，这是默认的springTest实例的一些类具体解决方案请看 (9) java.lang.ClassNotFoundException: javax.xml.bind.JAXBException原因未发现这个javax.xml.bind/..包在发布web应用里面由于java9module配置移除了java ee包含的java/xml/bind/解决方案发布的web应用下面lib库中添加有关联的包具体解决方案 (10) 严重: Invalid message recieved with signature 18245 原因 这个提示是由于我用HTTP方式访问了8009端口，而8009端口是通过AJP访问的 (11) 关于mysql Access denied for user root@localhos问题解答 原因 首次登录mysql密码未设置是遇到拒绝访问，权限检查不予许 解决方案 如果未关闭MYSQL服务，关闭MYSQL服务 例：command line:net stop mysql; 进入安装目录 $/my.ini配置文件，在[mysqld]条目下添加–skip-grant-tables，过着cmd命令 $mysqld-nt –skip-grant-tables，启动mysql，忽略权限检查 在mysql命令行中，mysqladmin -u root flush-privileges password “newpassword” 重设root密码 net start mysql 重新登录 (12) 关于phpmydmin管理界面不存在添加用户权限的原因解答原因首次登录未设置密码权限不够导致.通过上面的解决方案，可以解决这个问题 (13) C语言中标准输入的结束符 windows CTRL+z，linux是Ctrl+d(14) An invalid character [32] was present in the Cookie valueWEB16 lastAccessTimeServlet SimpleDateFormat format = new SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”);原因an invalid character [32] was present in the Cookie value 中32对应的编码是空格Stack Overflow上的回答：This is due to Tomcat&#39;s cookie processing being changed to a RFC 6265 compliant implementation by default in 8.5, which does not allow space (character 32), among others. 我的tomcat版本是9.0，发现WEB16 lastAccessTimeServlet SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)这行代码yyyy-MM-dd hh:mm:ss存在空格。 解决方案去除空格，问题解决具体解决思路 (15) android:can’t resolve R原因可能R文件无意删除或者其他因素解决方法build-&gt;rebuild(重新生成R文件) (16) github There isn’t a GitHub Pages site here.github page 绑定域名以后，在浏览器输入域名但是出现上面错误。原因域名已经成功解析到远程主机（github page），但是因为github page绑定域名需要一个特定文件CNAME（包含域名）才能定向到github，因为我并没有创建。解决方法创建一个特定的CNAME文件，在里面加入自己的域名` (17) java.net.UnknownHostException: Unable to resolve host “guolin.tech”: No address associated with hostname在做第一行代码天气项目遇到问题原因安卓浏览器hostname不能够resolved，如果domain name没有附上的 具体原因解决方法$ ping guolin.tech,替换host域名为ip地址，例子ip为：47.90.126.26 (18) 未能解决plugin with id ‘com.android.application’ not found$待解决不是步骤 new--&gt;import project而是步骤 new--&gt;import module]]></content>
      <categories>
        <category>extension</category>
      </categories>
      <tags>
        <tag>problem</tag>
        <tag>solve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用命令]]></title>
    <url>%2F%2F2018%2F07%2Fextension-MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[MySQL常用命令查询表user所有字段信息SELECT 字段 FROM 表； eg :SELECT * FROM user; 选择db_test数据库USE 数据库; eg :USE db_test; 在表user插入一列名为name，类型为varchar，且不为NULL字段ALTER TABLE 表 ADD 字段名 类型 xx; eg :ALTER TABLE user ADD name varchar(40) NOT NULL; 删除表user中字段为id的一列ALTER TABLE 表 DROP 字段名; eg :ALTER TABLE user DROP id; 在表user中七个字段（Filed）插入一行数据INSERT INTO 表 VALUES(Field,Field,Field,Field); eg :INSERT INTO user(username,password,uid,name,email,sex,birthday) VALUES(&quot;ghu2&quot;,&quot;12312&quot;,&quot;1e0d8987-7c8d-4f9b-8cd4-2adba575b464&quot;,&quot;gy&quot;,&quot;twg&quot;,&quot;tfy&quot;,&quot;wf&quot;);]]></content>
      <categories>
        <category>extension</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F%2F2018%2F07%2Falgorithm-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[快速排序什么是快速排序？快速排序Quicksort又称划分交换排序partition-exchange sort.。是对冒泡排序的一种改进；是一种不稳定排序^1。 基本思想通过一趟快速排序。排序的数据分割成独立的两部分，选定一个基准provit，一般选择数组首元素。通过排序，基准值被交换到这样一个数组位置。其中一部分的所有数据都比基准小，另外一部分的所有数据都比基准大。这样就可以看作已经排序好基准^3。然后再按此方法对两部分在进行快速排序，整个过程可以递归进行，以此达到整个数据成为有序序列 阈值问题^2：递归基 left&gt;=right 一趟快速排序分割数据长度相对于数组至少两个元素。 详情 C版本原地排序 非原地排序详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void quickSort(int sour[],int left,int right);void swap(int *x,int *y);void main()&#123; int i; int a[]=&#123;1,3,2,4,5,6,7,8&#125;; quickSort(a,0,7); for(i=0;i&lt;8;i++) printf("%d",a[i]); getchar();&#125;void quickSort(int sour[],int left,int right)&#123; int i=left; int j=right-1; int provit=sour[right]; if(left&gt;=right) return; while(i&lt;j) &#123; while(sour[i]&lt;provit&amp;&amp;i&lt;j) &#123; ++i; &#125; while(sour[j]&gt;=provit&amp;&amp;i&lt;j) &#123; --j; &#125; swap(&amp;sour[i],&amp;sour[j]); &#125; if(sour[i]&gt;=provit) //为什么写&amp;provit不行？写&amp;sour[right]可以 //忘了&amp;provit不再数组之中，交换没用 &#123; swap(&amp;sour[i],&amp;sour[right]); &#125; else i++; //当需排序的数组已经是有序的时候，会出现i==right-1，且sour[i]&lt;provit,此时provit为中间值 if(i) //i==左边界（第一躺排序为i==0）时可以不再需要递归排序左边 &#123; quickSort(sour,left,i-1); &#125; quickSort(sour,i+1,right);&#125;void swap(int *x,int *y)&#123; int tem=*x; *x=*y; *y=tem;&#125; java版本原地排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package other.extention.algorithm;import algorithm.extention.util.SortUtil;/** * * @author 13612 * @time 2018年7月4日 * @version V1.0 * （1）未设置递归基，导致递归无限循环 * （2）未真正在一趟把排序的数据分割成独立的两部分，即为达到i&lt;j */ public class QuickSort &#123; public QuickSort() &#123; // TODO Auto-generated constructor stub &#125; /** * * @param source 需要排序的int类型数组 * @param left 数组左边界 * @param right 数组右边界 */ public static void sort(int[] source, int left,int right) &#123; if(left&gt;=right) &#123; return; &#125; int i=left; int j=right; int key=source[left]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;key&lt;=source[j]) &#123; --j; &#125; source[i]=source[j]; while(i&lt;j&amp;&amp;key&gt;=source[i]) &#123; ++i; &#125; source[j]=source[i]; &#125; source[i]=key; sort(source,left,i-1); sort(source,i+1,right); &#125; /** * * @param targetArr 实现Comparable接口的泛型数组 * @param start 泛型数组左边界 * @param end 泛型数组右边界 * @return */ public &lt;T extends Comparable&lt;? super T&gt;&gt; T[] quickSort(T[] targetArr, int start, int end) &#123; int i = start + 1, j = end; T key = targetArr[start]; SortUtil&lt;T&gt; sUtil = new SortUtil&lt;T&gt;(); if (start &gt;= end) return (targetArr); /* * 从i++和j--两个方向搜索不满足条件的值并交换 * * 条件为：i++方向小于key，j--方向大于key */ while (true) &#123; while (targetArr[j].compareTo(key) &gt; 0) j--; while (targetArr[i].compareTo(key) &lt; 0 &amp;&amp; i &lt; j) i++; if (i &gt;= j) break; sUtil.swap(targetArr, i, j); // 维持在两边正好等于key时能够进行下一次增长比较 if (targetArr[i] == key) &#123; j--; &#125; else &#123; i++; &#125; &#125; /* 关键数据放到‘中间’ */ sUtil.swap(targetArr, start, j); if (start &lt; i - 1) &#123; this.quickSort(targetArr, start, i - 1); &#125; if (j + 1 &lt; end) &#123; this.quickSort(targetArr, j + 1, end); &#125; return targetArr; &#125; public static void main(String[] args) &#123; Integer[] sour= &#123;2,7,8,9,4,10,4,6&#125;; QuickSort qs=new QuickSort(); qs.quickSort(sour, 0, sour.length-1); for(int i=0;i&lt;sour.length;i++) &#123; System.out.println(sour[i]); &#125; &#125; &#125; 时间复杂度常规计算我们不难观察到分区运算，数组的元素都会在每次循环中走访一次，使用的时间。 在最好的情况下，每次我们运行一次分区，我们会把一个数列分为两个几近相等的分段。这个意思就是每次递归处理一般大小的数列。因此，在到达大小为一的数列前，我们只要做 次嵌套的调用。但是在同一层次结构的两个程序调用中，不会处理原来数列的相同部分。因此，调用每一层结构总共需要 的时间。结果是这个算法仅需要 的时间。 递归计算设立 递归关系式^4 在最好的情况下，因为一个单独的快速排序调用牵涉O(n)的工作，加上对n/2大小数列的两个数列的递归调用，这个关系是： 解决这种关系式类型的标准数学归纳法技巧告诉我们 。 在最坏的情况是，两子数列拥有大各为O 和O，且调用树（call tree）变成为一个个嵌套（nested）调用的线性连串（chain）。第 次调用作了 的工作量，且递归关系式为： 平均复杂度 是分区所使用的比较次数。因为基准值是相当均匀地落在排列好的数列次序之任何地方概率相同，总和就是所有可能分区的平均。 空间复杂度详情 参考引用： https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842? https://zh.wikipedia.org/wiki/快速排序]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>quickSort</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSLCertificateVerification）]]></title>
    <url>%2F%2F2018%2F07%2Fextension-SSLCertificateVerification-%E8%AF%81%E4%B9%A6.html</url>
    <content type="text"><![CDATA[SSL Certificate Verification_证书SSLSSL是的旧的名字，现在他被叫做TLS 原生SSL如果libcurl是用Schannel或者Secure Transport构造的（原生SSL库包含在Windows和Mac OS x)，那么这个不能适用你。向下滑获得OS-native-engines如何处理SSL证书。如果你是不确定，那么run“curl -V”和阅读结果 。如果版本字符串包含”WinSSL“，那么这个是使用hannel support 是关于可信这个系统是关于可信的。在你的当地CA证书存储区，你有来自可信赖CA证书机构证书这个你能够使用来验证这个你看起来是有效的证书。他们是被签署通过你信赖的某一个CAs证书机构。 你信赖这个CAs？你能够决定信赖一个相同的公司组这个你操作系统信赖的，或者一个组某一个知名浏览器信赖的。这些都基于你的信任。你应该意识到这个现代操作系统和浏览器是被启动信任上百个公司和最近几年several such CAS已经被发现时不可信的。 证书验证libcurl默认执行peer对等SSL证书验证。这个是被做通过使用能够被SSL库使用来确认对等服务器证书时有效的CA证书存储区。 Note:If you communicate with HTTPS, FTPS or other TLS-using servers using certificates that are signed by CAs present in the store, you can be sure that the remote server really is the one it claims to be. 忽略证书验证如果远程服务器使用一个自签名证书，如果你没有安装CA证书存储区，如果服务器使用一个被并没有包含在你使用存储区CA证书签署，或者这个远程主机是一个imposer冒名顶替者impersonting扮演你喜爱的站点，但是你想从这个服务器传输文件，做下面的一种： 1: 告诉libcurl不要验证对等。使用libcurl禁用curl_easy_setopt(curl,CURLOPT_SSL_VERIFYPEER,FALSE)2: 使用curl command line tool禁用这个使用-k/--insecure3: 得到一个能够验证远程服务器CA 证书和当连接的时候使用恰当的选择来指定这个CA证书来证。 对于libcurl hacker curl_easy_setopt(curl,CURLOPT_CAPATH,capath) curl command line tool --cacert [file]4: 为你服务器添加CA证书到已经存在默认的CA 证书存储区。默认的CA证书存储区能够在compile时间改变,即通过下面的配置选择： --with-ca-bundle=FILE Note:use the specified file as CA certificate store. CA certificates need to be concatenated in PEM format into this file --with-ca-path=PATH Note:use the specified path as CA certificate store. CA certificates need to be stored as individual PEM files in this directory. You may need to run c_rehash after adding files there. If neither of the two options is specified, configure will try to auto-detect a setting. It’s alsopossible to explicitly not hardcode any default store but rely on the built in default the crypto library may provide instead. You can achieve that by passing both –without-ca-bundle and –without-ca-pathto the configure script. If you use Internet Explorer, this is one way to get extract the CA cert for a particular server: &lt;1&gt; View the certificate by double-clicking the padlock(挂锁) &lt;2&gt; Find out where the CA certificate is kept (Certificate&gt; Authority Information Access&gt;URL) &lt;3&gt; Get a copy of the crt file using curl &lt;4&gt; Convert it from crt to PEM using the openssl tool: openssl x509 -inform DES -in yourdownloaded.crt -out outcert.pem -text &lt;5&gt; Add the &apos;outcert.pem&apos; to the CA certificate store or use it stand-alone as described below. If you use the &apos;openssl&apos; tool, this is one way to get extract the CA cert for a particular server: 1:openssl s_client -connect xxxxx.com:443 |tee logfile 2:type &quot;QUIT&quot;, followed by the &quot;ENTER&quot; key 3:The certificate will have &quot;BEGIN CERTIFICATE&quot; and &quot;END CERTIFICATE&quot; markers. If you want to see the data in the certificate, you can do: &quot;openssl x509 -inform PEM -in certfile -text -out certdata&quot; where certfile is the cert you extracted from logfile. Look in certdata. If you want to trust the certificate, you can add it to your CA certificate store or use it stand-alone as described. Just remember that the security is no better than the way you obtained the certificate.If you&apos;re using the curl command line tool, you can specify your own CA cert path by setting the environment variable CURL_CA_BUNDLE to the path of your choice. If you’re using the curl command line tool on Windows, curl will search for a CA cert file named “curl-ca-bundle.crt” in these directories and in this order: application’s directory current working directory Windows System directory (e.g. C:\windows\system32) Windows Directory (e.g. C:\windows) all directories along %PATH% Get a better/different/newer CA cert bundle! One option is to extract the one a recent Firefox browser uses by running ‘make ca-bundle’ in the curl build tree root, or possibly download a version that was generated this way for you: CA ExtractCertificate Verification with NSSCertificate Verification with Schannel and Secure Transport 如果libcurl是使用Schannel(Microsoft native TLS engine:验证得出本机目前使用这个built的)built或者苹果（省略）支持，那么libcurl将会任然执行对等验证，但是如果代替使用CAcertificate bundle，它将会使用这个built在OS里证书.这些相同证书出现在internet Options controls panel(under windows),任何用于证书的自定义安全规则都将得到遵守 除非对等验证被禁用，否则Schannel将对证书运行CRL检查 HTTPS proxy SSL certificate problem: unable to get local issuer certificate意味着cUrl不信任 Verisign证书机构 Note:VeriSign 的数字信任服务通过VeriSign的域名登记、数字认证和网上支付三大核心业务，在全球范围内建立起了一个可信的虚拟环境，使任何人在任何地点都能放心地进行数字交易和沟通。而数字证书业务是其起家的核心业务.VeriSign数字证书产品是目前市场上最完整的支持最多应用和最多设备的数字证书产品，主要包括： SSL 证书和代码签名证书。]]></content>
      <categories>
        <category>extension</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>extenstion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令（更新）]]></title>
    <url>%2F%2F2018%2F07%2Fdeploy-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89.html</url>
    <content type="text"><![CDATA[提交代码时候，来确认谁提交的代码Note:所有命令在git bash命令行输入 123eg:$ git config --global user.name "Nautilus-Nemo"$ git config --global user.name "13612262974@163.com" 确认上面的配置是否成功： 123eg:$ git config --global user.name$ git config --global user.name 创建代码仓库 仓库repository是用于保存版本管理所需信息的地方，所有本地提交的代码都会保存在代码仓库中， 如果有需要还可以推送到远程仓库中 进入所需要创建代码仓库的项目的目录 $ cd [your project directory] $ git init Note:仓库建立以后，项目的根目录会生成一个隐藏的`.git`文件夹,这个文件就是来记录本地 所有的`git`操作。如果要删除本地仓库的话，只需要删除这个文件夹 查看所有本地的git操作1$ ls al 提交本地代码 添加一个文件 $ git add (your file) 添加一个目录 $ git add (your directory) 添加某项目下的所有文件 $ git add . 添加完所需要的文件后，提交 $ git commit -m &quot;First commit.&quot; Note:我们一般通过-m参数来加上提交的文件信息 发布至远程仓库1$ git push origin master 其中origin部分指定的是远程版本库的Git地址，master部分指定的是同步到哪一个分支上 远程版本库上的修改同步到本地 Git提供了两种命令来完成此功能，分别是fetch和pull,fetch的语法规则和push差不多 1$ git fetch origin master 执行了这个命令后，就会将远程版本库上的代码同步到本地，不过同步下来的代码并不会合并到任何分支上，而是会存放到origin/master分支。 我们可以通过diff命令来查看远程版本库到底修改了那些东西: 1$ git diff origin/master 调用merge命令将origin/master分支上的修改合并到主分支上 1$ git merge origin/master pull命令则是将fetch和merge这两个命令放在一起执行。他可以从远程版本库上获取最新的代码并且合并到本地上1git pull origin master 复制Github中已有的开源库 复制这个开源库的url：即右上角蓝色clone or download按钮 打开git bash,cd至你要复制的项目目录，使用命令 1$ git clone (url) Note:可能需要把所有clone的文件复制到上一层，因为上一层才是项目的根目录，要注意把隐藏文件.git复制过去 分支的用法1$ git branch 查看有那些分支1$ git branch version1.0 创建了一个名为version1.0的分支 1git checkout master 切换到master分支 1git merge -D version1.0 使用merge命令来完成合并操作 1git branch -D version1.0 删除分支1$ git push --repo=https://github.com/Nautilus-Nemo/coolweather 提交到具体的库 1$ git checkout master 确定提交的库 [详情] (file:///C:/software/Git/mingw64/share/doc/git-doc/git-push.html#URLS）]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>deploy</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始使用GitHub]]></title>
    <url>%2F%2F2018%2F06%2Fdeploy-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8GitHub.html</url>
    <content type="text"><![CDATA[开始使用GitHub什么是GitHub？GitHub是一个用于版本控制和合并代码托管平台。它让你和你的工作伙伴工作在同一个项目不管你们两者是否相隔天涯海角。创造一个Respository一个respository是通常用来组织一个项目。Respository能够包含文件夹和文件，图像，视频，电子表格，和数据集等任何东西你的项目需要的。我们建议包括一个README，或者一个文件包含你的项目信息。Github使它容易去增加一个在相同时间你去创造一个新的Respository（GitHub可以在创建新存储库的同时轻松添加一个）。它也提供其他常用的选择。例：license file 在右上角，在你的头像（avatar）或身份证（identicon)旁边,点击+和选择NEW repository 给你的repository取个名字。例：Hello_world 写一个简短的描述 选择初始化这个repository with a README. 创造一个BranchBranching 是一种方式工作在同一时间同一个库中不同的版本。默认的你的repository有一个branch被叫做master.我们经常使用branches来在committing他们到master以前实验和编辑。什么时候你创造一个branch从master branch,你是制造一个copy，或者快照(snapshot).他人在master分支上工作时对分支进行了更改,你能获得这些更新。你曾经存储过不同的文件版本？像这样 story.txt story-joe-edit.txt story-joe-edit-reviewed.txt Branches在Github repository完成相同的目标 先去到你新创建的repository 点击文件清单上面叫Branch:master下拉项。 在新的分支文本框打上一个分支名字 选择蓝色Create Branch框或者点击”Enter”在你的键盘。 对文件做修改和push他们到GitHub as commits在Github,存储改变是被叫做commits.每个commit有一个相关联的来描述解释变化commit信息。Commit信息能够抓住历史中的变化，所以其他的contributor能够理解你做了什么和为什么这样做具体操作步骤 打开和merge一个pull requestPull Request 是的在Github合并的核心.什么时候你打开了一个pull request,你是正在提出你的改变和请求其他人review和pull in你的contribution（并要求有人审查并提交你的贡献）和融合他们到他们的分支。pull 请求展示两个分支的diffs，或者不同。Gihub@mention system你能询问反馈从指定人们或者队伍。具体操作步骤 融合一个分支到主分支具体操作步骤 To learn more about the power of Pull Requests, we recommend reading the GitHub Flow Guide`https://guides.github.com/introduction/flow/`. You might also visit GitHub Explore`https://github.com/explore` and get involved in an Open Source project Connecting to GiHub with SSH使用SSH协议，你能连接和认证远程服务器和服务。使用SSH keys,你能连接Github不需要提供你的用户名和密码在每一次登陆网站当您设置SSH时，您将生成一个SSH密钥并将其添加到ssh-agent，然后将密钥添加到您的 GitHub帐户。将SSH密钥添加到ssh-agent.可确保您的SSH密钥通过使用密码短语具有额外 的安全层。有关更多信息，请参阅“ 使用SSH密钥密码”。要将SSH密钥与使用SAML单点登录 的组织拥有的存储库一起使用，您需要先对其进行授权。有关更多信息，请参阅“ 授权SSH密 钥以用于SAML单一登录组织。” 我们建议您定期查看您的SSH密钥列表并撤销任何无效或已被入侵的密钥。 具体生成SSH或者其他步骤]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>deploy</tag>
        <tag>tool</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android天气项目设计文档（第一行代码）]]></title>
    <url>%2F%2F2018%2F06%2Fandroid-Android-%E5%A4%A9%E6%B0%94%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3.html</url>
    <content type="text"><![CDATA[1. 设计目的为了让广大Android手机用户能够在第一时间获取最新天气预报消息，以便提前预防，方便出行。同时，把气象翟海早餐的瞬时降到最低，也可以提高公共服务质量，更好的发挥气象事业对经济社会发展的现实作用，有很强的实用价值。虽然该技术在Android平台早已比较成熟，但是通过本次软件的设计开发仍然能帮助我更好的认识Android系统的工作原理。 2.开发环境 android studio jdk sdk 3.需求分析 提供用户查看特定地区天气信息和生活建议 采用灵活方式实现用户获取到的数据是实时的 设计良好用户界面，提高用户体验 4.设计（1）数据库设计 采用开源Android数据库框架LitePal,它采用对象关系映射(ORM)的模式，并将我们平时最常用到的一些数据库功能进行了封装。使得不用编写SQL语句就可以完成各种建表和增删改查的操作。 Province数据表 属性 数据类型 说明 id integer 自增主键 provinceName text 省份名称 provinceCode integer 省份代号 City数据表 属性 数据类型 说明 id integer 自增主键 cityName text 城市名称 cityCode integer 城市代号 provinceId integer 当前市属省的id值 County数据表 属性 数据类型 说明 id integer 自增主键 countyName text 县名称 countyCode integer 县代号 cityId integer 当前县属市的id值 （2）功能模块从功能需求分析可以看出，整个应用程序应该分为4个模块。分别是用户界面，数据获取模块和数据库适配器和网络请求模块。各模块之间的关系如图： 1234567891011B --&gt;|startService 启动服务| I(后台服务)I --&gt;|八小时更新|HB[用户界面]--&gt;|设置相关信息| G(&lt;/Br&gt;数据获取模块)G--&gt;|天气信息| BG--&gt;D[数据库获取模块]D--&gt;GD--&gt;E[Litepal数据库框架]E--&gt;DH[okhttp3封装Http请求]--&gt;|解析返回天气数据信息|GH--&gt;EF[和风天气预报服务]--&gt;H 从模块结构图中不难看出，数据获取模块是整个应用程序的核心。主要是由sharePreferencr构成。获取数据信息从okhttp3网络请求模块中获取数据和服务每八小时网络请求模块获取一次数据。用户设置相关信息获取信息，一种从数据获取模块中寻找数据，第二种直接通过okhttp3网络请求模块请求获取数据并存储在数据获取模块中，在从数据获取模块中获取数据，能保证天气数据实时，且能保证网络阻塞情况下，能从数据获取模块获得数据。startService保证长时间未更新数据情况下，采用上述第二种方式从数据获取模块获得实时数据。数据获取模块是一种较良好方式从Http请求中获得实时数据的一种存储方式。数据库适配器使用Litepal数据库框架映射数据库。存储地区信息等比较固定的信息，避免频繁从网络请求模块中获取数据。 5.项目功能描述（1）系统主要功能 点击特定省份，城市和县来查看特定地区实时天气信息和服务信息 下拉刷新获取实时的天气信息和服务信息 后台服务，八小时自动跟新实时天气和服务信息 数据库存储地区信息，消除频繁去服务区获取数据 sharePreference存储天气信息，获取实时天气信息 获取每日一图，每日更换天气界面背景，获得好的用户体验 （2）系统各模块具体实现工程源代码的结构如图 源代码文件的名称以及说明： 包名称 文件名 说明 com.example.a13612.weather.db City.java 数据库表City映射模型 com.example.a13612.weather.db County.java 数据库表County映射模型 com.example.a13612.weather.db Province.java 数据库表Province映射模型 com.example.a13612.weather.gson AQI.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Basic.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Forecast.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Now.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Suggestion.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Weather.java 天气数据json数据格式解析模型 对应的json数据格式，采用gson解析 123456789101112&#123; "HeWeather": [ &#123; "status":"ok", //响应码 "basic":&#123;&#125;, //地区信息 "aqi":&#123;&#125;, //空气质量 "now":&#123;&#125;, //今天天气预报 "suggestion": &#123;&#125; //生活建议 "daily_forecast":[] //未来几天天气预报 &#125; ]&#125; 包名称 文件名 说明 com.example.a13612.weather.service AutoUpdateService.java 后台服务类，每八小时更新数据信息 com.example.a13612.weather.utils HttpUtil.java 服务器交互工具类，采用okhttp3网络通信库 com.example.a13612.weather.utils Utility.java 解析和处理从服务器返回json数据工具类 com.example.a13612.weather.ChooseAreaFragment ChooseAreaFragment.java 选择地区，来确定需要哪个地区天气信息 com.example.a13612.weather.WeatherActivity WeatherActivity.java 设置显示天气信息，加载天气界面 com.example.a13612.weather.MainActivity MainActivity.java 主活动，通过查看sharePreference是否存在数据来加载具体类,布局 Android的资源文件保存在/res的子目录中。其中,/res/layout/保存布局，/res/drawable/保存图片等信息 资源目录 文件 说明 layout activity_main.xml 复用碎片ChooseAreaFragment layout activity_weather.xml 天气界面，inlucde多个布局文件，引入下拉，opendraw layout aqi.xml 空气质量布局 layout choose_area.xml 选择地区布局 layout forecast.xml 多个天气预报布局 layout forecast_item.xml 单个天气预报item layout now.xml 当前天气预报布局 layout suggestion.xml 生活建议不 layout title.xml 标题框布局 drawable ic_back.png 返回上一级地区按钮图片 drawable ic_home.png 实现在天气界面打开侧框选择地区界面 配置文件 &lt;1&gt;项目所需的各种依赖库声明，具体配置文件app/build.gradle 123456deplencies&#123; implementation 'org.litepal.android:core:1.4.1' implementation 'com.squareup.okhttp3:okhttp:3.4.1' implementation 'com.google.code.gson:gson:2.7' implementation 'com.github.bumptech.glide:glide:3.7.0' &#125; 作用：LitePal用于对数据库操作，OkHttp用于进行网络请求，GSON用于解析JSON数据，Glide用于加载图片和展示图片 &lt;2&gt;LitePal配置文件，用于匹配映射数据库模型类，位于assets/litepal.xml 123456789 &lt;litepal&gt; &lt;dbname value="weather" /&gt; &lt;version value="1" /&gt; &lt;list&gt; &lt;mapping class="com.example.a13612.weather.db.Province" /&gt; &lt;mapping class="com.example.a13612.weather.db.City" /&gt; &lt;mapping class="com.example.a13612.weather.db.County" /&gt; &lt;/list&gt;&lt;/litepal&gt; 作用：建立数据库：weather，创建数据库表Province,City,County &lt;3&gt;AndroidManifest.xml,进行权限声明，活动,服务注册，LitePal声明 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.a13612.weather"&gt; &lt;!--访问网络权限--&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;application &lt;!--LitePal声明--&gt; android:name="org.litepal.LitePalApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" &lt;!--设置主题为自己定义AppTheme主题，具体配置AppTheme请看res/values/styles.xml--&gt; android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;!-- 指定当前活动能够响应的action和category --&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".WeatherActivity"&gt;&lt;/activity&gt; &lt;service android:name=".service.AutoUpdateService" android:enabled="true" android:exported="true"&gt;&lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; 6.数据提供者&lt;1&gt; 地区信息提供url接口： http://guolin.tech/api/china 提供所有省份信息 http://guolin.tech/api/china/&quot;+provinceCode 根据省份信息查找特定城市信息 http://guolin.tech/api/china/&quot;+provinceCode+&quot;/&quot;+cityCode 根据省份信息和特定城市信息查找特定地区信息 &lt;2&gt;和风天气数据信息提供urL接口： &quot;http://47.90.126.26/api/weather?cityid=&quot;+weatherId+&quot;&amp;key=de25d114b80e43ed907cc1db97335395&quot; weatherId：具体特定地区信息提供 key:http://guolin.tech/api/weather/register注册获取key &lt;3&gt;每日一图提供url接口： http://guolin.tech/api/bing_pc 7.系统界面​ ​]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%2F2018%2F06%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
