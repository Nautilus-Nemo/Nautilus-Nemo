<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[matlab函数记录]]></title>
    <url>%2F%2F2018%2F11%2Fextension-Linux%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[Centos6.7Linux命令 Note: linux有两种用户，一种管理员root，另外一种普通用户xx. root用户登陆到linux默认所在的目录是 /root/ 其他用户xx登陆到linux默认所在的目录是 /home/xx/ 查询目前所在目录1# pwd 获取本地IP地址1# ifconfig 在当前目录下创建一个文件1# touch xiao.txt # 在当前目录创建一个 xiao.txt 文件 清除屏幕1# clear # 清除屏幕 查看进程12# ps -ef # ps -ef | grep -i crond 查看系统中crond的进程信息 查看本机上所有已经安装成功的软件和特定软件12# rpm -qa # rpm -qa | grep java #只查看和java相关的 删除软件123rpm -e --nodeps &lt;软件包&gt; #eg:# rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686 # 查看本机开放的端口号1# /etc/init.d/iptables status 防火墙打开特定端口1234eg:8080端口# /sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT# /etc/rc.d/init.d/iptables save #存储设置 查询特定服务运行状态12eg:# service mysql status #查询mysql服务运行状态 加入系统服务并自动启动123# chkconfig --add mysql #加入系统服务# chkconfig mysql on #自动启动# chkconfig #查询列表 磁盘管理list命令 - 查看目录结构 ls list 功能： 列出目录内容 1格式: ls [参数] [文件或者目录] 【参数】 12-a 或 #all 列出所有的文件或者目录。包括隐藏文件，特殊目录-l 使用详细格式列表 常用 1# ls -l 1# ls -al 1# ls /bin 列出根目录下bin目录下的文件信息 更多内容，参考入门文档 Note: 在文件前缀符. 意味着这是隐藏文件 :artificial_satellite: cd命令 - 切换目录命令 cd change directory 语法 cd [目录] 常用 12345# cd ~ 当前用户目录# cd / 根目录# cd - 上一次访问的目录# cd .. 上一级目录# cd 缺省当前用户目录 pwd命令 - 显示当前目录print working directory 1# pwd mkdir - 创建目录make directory -p 父目录不存在的情况下先生成父目录 【parent】 -v 显示命令执行过程中的详细信息 1# mkdir -pv ./xiao/ming 文件管理 - 文件浏览cat命令 - 显示文本文件内容catenate 12# cd 回到根目录# cat install.log 显示根目录下的日志文件内容 Note: cat不适合文件内容太多的情况，应该选择more命令 more命令 - 分页显示文件内容，还支持直接跳转行等功能1234567###### more file #语法enter #向下n行，需要定义，默认一行空格键 #向下滚动一屏或ctrl + FB #返回上一屏 或 ctrl + Bq #退出moreeg:###### more /root/install.log Note: 按 tab 键有自动补齐功能 less命令 - 分页显示文件内容，操作更详细12345678910less [参数] 文件 #语法-m #显示类似more命令的百分比-n #显示每行的行号操作： #覆盖了more的所有操作/字符串 #向下搜索字符串?字符串 #向上搜索字符串u # 后退半页d # 前进半页y # 后退一行 tail命令 - 用于显示指定文件末尾的内容123tail [必要参数][选择参数][文件] #语法-n #显示行数 #必要参数tail -f 循环读取 #选择参数 文件管理 - 文件操作cp命令 - 复制文件或目录123456789101112Syntax: cp [参数] [源文件或目录] [目标文件或目录]-r 或 #recursive 递归处理。将指定目录下的文件与子目录一并处理Note:#复制目录cp ./abc ./xxx #无法复制目录cp -r ./abc ./xxx #复制目录必须使用-r参数eg:#复制文件cd /root/cp install.log install01.log #复制文件install.log到当前目录下的install01.logcp -b install.log 01.log # -b参数当复制时如果在当前目录存在01.log，备份这个文件为01.log~cp ./install.log ../install.log #将当前目录的install.log复制到父目录的install.log mv命令 - 移动或更名现有文件或目录12345Syntax: mv [源文件或目录][目标文件或目录]-f或--force 若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录eg:#既可以做剪切又可以做重命名mv ./a.txt ./b/b.txt rm命令 - 删除文件或目录remove 12345678910Syntax: rm [-dfirv][--help][--version][文件或目录]-f或--force 强制删除文件或目录-r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理eg:#删除文件rm -f install01.log #-f 强制删除rm install01.log #提示#删除目录rm -f ./a #强制删除目录,不可行rm -rf ./a #强制删除目录，需要加上-r参数 find命令 - 查找文件或目录1234Syntax find [目录 ...][参数]-name 指定字符串作为寻找文件或目录的范本样式eg:find /root/ -name &apos;in*&apos; #在根目录下寻找名称中包含in而且是以in开头的文件或者目录 vi或vim命令vim基本概念 基本上vi可以分为三种状态。分别是命令行模式command mode,插入模式insert mode和底行模式last line mde 命令行模式 控制屏幕光标的移动，字符，字或者行的删除，移动复制某区段及进入insert mode下，或者到last line mode。 插入模式 只有在插入模式下，才可以做文字输入。按Esc键可以回到命令行模式 底行模式 将文件保存或退出vi，也可以设置编辑环境。如寻找字符串，列出行号 [x] 输入syntax: vim 文件名进入一般模式 [x] 按下i从一般模式进入插入模式 [x] 按下esc从插入模式退出到一般模式 [x] 在一般模式下，输入:wq，退出编辑 系统命令grep命令 - 全局正则表达式Global Regular Expression Print 12345Usage: 用于过滤/搜素特定字符Syntax: grep [option] pattern [file]-i 或 --ignore-case #忽略字符大小写的差别egg:grep -i mysql /root/install.log kill功能 - 删除执行中的程序或工作123456Syntax: kill [参数][程序]-l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称kill -9 #表示强制终止eg:ps ef #列出所有进程kill -9 4199 #表示强制终止UID为4199的进程 ping命令12345Usage: 测试与目标主机的连通性Syntax：ping 主机名或ip地址eg:ping 127.0.0.1 测试本机连通性% 按ctrl+c退出ping tar命令 - 压缩解压缩123456789101112Syntax: 文件备份压缩语法: tar命令-c `create` 建立一个压缩文件的参数指令 --压缩-x `extract` 解开一个压缩文件的参数指令 --解压-z 是否需要用gzip压缩-v `verbose`压缩过程中显示文件-f `file`使用档名,在f之后要立即接档名常用参数组合解压缩 zxvf压缩 zcvfeg:tar zxvf ./xxx.tar #解压当前目录下的./xxx.tar 关机重启123456Linux centos重启命令eg:rebootLinux centos关机命令eg:halt 文件权限chmod命令123456789101112131415161718192021Usage: 变更文件或目录的权限Syntax: chmod [参数] [&lt;权限范围&gt;&lt;符号&gt;&lt;权限代号&gt;]权限范围表示法：u `User`文件或目录的拥有者g `Group`文件或目录的所属群组o `Other`除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围a `All` 即全部的用户，包含拥有者，所属群组以及其他用户符号：+ 添加权限- 取消权限有关权限代号部分：r 读取权限，数字代号为4w 写入权限，数字代号为2x 执行或切换权限，数字代号为1- 不具任何权限，数字代号为0eg:mkdir xxxll | grep xxxchmod u-rwx xxx #取消xxx目录，用户&quot;读写执行&quot;权限chmod g-rwx xxx #取消xxx目录，组&quot;读写执行&quot;权限chmod 777 xxx #给xxx目录添加所有权限 Linux权限格式 &lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt; -rwxrw-r– 第一位： 【文件类型 d：目录，-：普通文件，|：链接文件】 第二至四位 【所属用户权限，用u(user)表示】 第五至七位 【所属组权限，用g(group)表示】 第八至十位 【其他用户权限，用o(other)表示】 第二至十位 【表示所有权限，用a(all)表示】 帮助文档查看各个命令的参数Linux命令 内部命令：Linux系统核心命令，等价于windows dir等命令 外部命令：后来加入的命令，等价于windows java等命令 查看内部命令帮助文档方式 help + 命令 查看外部命令帮助文档方式 man + 命令 KaLiTCP端口扫描工具Namp12eg:# nmap 192.168.41.136 #查看目标主机开放Tcp端口 打开SSH服务点我]]></content>
      <categories>
        <category>extension</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F%2F2018%2F10%2Falgorithm-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[快速排序什么是快速排序？快速排序Quicksort又称划分交换排序partition-exchange sort.。是对冒泡排序的一种改进；是一种不稳定排序^1。 基本思想通过一趟快速排序。排序的数据分割成独立的两部分，选定一个基准provit，一般选择数组首元素。通过排序，基准值被交换到这样一个数组位置。其中一部分的所有数据都比基准小，另外一部分的所有数据都比基准大。这样就可以看作已经排序好基准^3。然后再按此方法对两部分在进行快速排序，整个过程可以递归进行，以此达到整个数据成为有序序列 阈值问题^2：递归基 left&gt;=right 一趟快速排序分割数据长度相对于数组至少两个元素。 详情 C版本原地排序 非原地排序详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void quickSort(int sour[],int left,int right);void swap(int *x,int *y);void main()&#123; int i; int a[]=&#123;1,3,2,4,5,6,7,8&#125;; quickSort(a,0,7); for(i=0;i&lt;8;i++) printf("%d",a[i]); getchar();&#125;void quickSort(int sour[],int left,int right)&#123; int i=left; int j=right-1; int provit=sour[right]; if(left&gt;=right) return; while(i&lt;j) &#123; while(sour[i]&lt;provit&amp;&amp;i&lt;j) &#123; ++i; &#125; while(sour[j]&gt;=provit&amp;&amp;i&lt;j) &#123; --j; &#125; swap(&amp;sour[i],&amp;sour[j]); &#125; if(sour[i]&gt;=provit) //为什么写&amp;provit不行？写&amp;sour[right]可以 //忘了&amp;provit不再数组之中，交换没用 &#123; swap(&amp;sour[i],&amp;sour[right]); &#125; else i++; //当需排序的数组已经是有序的时候，会出现i==right-1，且sour[i]&lt;provit,此时provit为中间值 if(i) //i==左边界（第一躺排序为i==0）时可以不再需要递归排序左边 &#123; quickSort(sour,left,i-1); &#125; quickSort(sour,i+1,right);&#125;void swap(int *x,int *y)&#123; int tem=*x; *x=*y; *y=tem;&#125; java版本原地排序 详情 algorithm-&gt; AlgorithmquickSort 时间复杂度常规计算我们不难观察到分区运算，数组的元素都会在每次循环中走访一次，使用的时间。 在最好的情况下，每次我们运行一次分区，我们会把一个数列分为两个几近相等的分段。这个意思就是每次递归处理一般大小的数列。因此，在到达大小为一的数列前，我们只要做 次嵌套的调用。但是在同一层次结构的两个程序调用中，不会处理原来数列的相同部分。因此，调用每一层结构总共需要 的时间。结果是这个算法仅需要 的时间。 递归计算设立 递归关系式^4 在最好的情况下，因为一个单独的快速排序调用牵涉O(n)的工作，加上对n/2大小数列的两个数列的递归调用，这个关系是： 解决这种关系式类型的标准数学归纳法技巧告诉我们 。 在最坏的情况是，两子数列拥有大各为O 和O，且调用树（call tree）变成为一个个嵌套（nested）调用的线性连串（chain）。第 次调用作了 的工作量，且递归关系式为： 平均复杂度 是分区所使用的比较次数。因为基准值是相当均匀地落在排列好的数列次序之任何地方概率相同，总和就是所有可能分区的平均。 空间复杂度详情 参考引用： https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842? https://zh.wikipedia.org/wiki/快速排序]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>quickSort</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab函数记录]]></title>
    <url>%2F%2F2018%2F10%2Fextension-Matlab%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[Matlab函数功能记录intDefinite and indefinite integrals 有限和无限积分 Syntax int(expr,var) int(expr,var,a,b) int(_,Name,Value) Description int(expr,var) -compute the indefinite integral of expr with respect to the symbolic scalar variable var. int(expr,var) -计算使用期待符号标量变量var的expr的无限积分 int(expr,var,a,b) -computes the definite integral of expr with respect to var from a to b. If you do not specific it, int use the default variable determined by symvar. If expr is a constant, then the default variable is x. int(expr,var,a,b) -计算使用期待从a到b的var的expr有限的积分 int(_,Name,Value) Input Arguments expr - Integrand 积分 symbolic expression | symbolic function | symbolic vector | symbolic matrix | symbolic number var Integration variable 积分变量 symbolic variable a - Lower bound number | symbolic number | symbolic variable | symbolic expression | symbolic function b - Upper bound number | symbolic number | symbolic variable | symbolic expression | symbolic function Name-Value Pair Arguments plotfit Syntax plotfit(net,inputs,targets) plotfit(targets1,inouts1,’name’,…) Description plotfit(net,input,targets)画贯穿范围inputs inputs和画target targets和关联inputs的值的output data point的神经网络输出函数。Error bar将会展示介于outputs和targets不同 The plot 出现仅是在神经网络用于第一次input 如果神经网络有超过一次的输出，仅是第一次output/targets 出现plotfit(targets1,inputs1,&#39;name1&#39;,...) displays a series of plots. lsqcurvefit解决非线性曲线拟合问题使用最小二乘法 fzero求解非线性函数根 查找线性函数求解根或者其他相关函数，请在命令行输入 help fzero Description x = fzero(fun,x0)tries to find a point x where fun(x) = 0. This solution is where fun(x) changes sign—fzero cannot find a root of a function such as x^2.尝试发现一个fun(x)=0的x值.解决方案是通过fun(x)在两点x值不同符号慢慢逼近fun(x)=0，所以不能发现像x^2这样函数的根 x = fzero(fun,x0,options)uses options to modify the solution process. x = fzero(problem)solves a root-finding problem specified by problem. [x,fval,exitflag,output] = fzero(___)returns fun(x) in the fval output, exitflag encoding the reason fzero stopped, and an output structure containing information on the solution process. 输入参数说明：fun :函数句柄例：’sin’​ @myFunction​ @(x)(x-a)^5x0:1：区间（这个包含根的x的区间，即输入区间端点的x值必须fun(x)值符号不同）2：实数 较接近根的值例：3例：[2,17] randn*【未看】2：randn - Normally distributed pseudorandom numbers(正态分布伪随机数) 这个函数返回一个被标准正态分布绘制的伪随机标量​ r = randn(n)​ r = randn(sz1,…,szN)​ r = randn(sz)​ r = randn(classname)​ r = randn(n,classname)​ r = randn(sz1,…,szN,classname)​ r = randn(sz,classname)​ r = randn(‘like’,p)​ r = randn(n,’like’,p)​ r = randn(sz1,…,szN,’like’,p)​ r = randn(sz,’like’,p) orth - Orthonormal basis for range of matrix（矩阵值域的正交基） Q = orth(A) 这个函数返回A矩阵的值域正交基 注释：矩阵与其本身的转置矩阵乘积为E logspace - Generate logarithmically spaced vertors 生成对数间隔向量​ y = logspace(a,b)​ y = logspace(a,b,n)​ y = logspace(a,pi) 这个函数生成介于10^a和10^b的50个对数间隔点行向量 y。 diag -Get diagonal elements or create diagonal matrix 获取对角线元素或创建对角矩阵 这个函数返回矢量v元素在main(k=0)对角的对角矩阵方阵 inv Matrix inverse(逆矩阵)​ Y = inv(x)​ 一般极少使用，一个不恰当的使用是求线性方程Ax=b,一种解决方案是x=inv(A)*b,从执行时间和数值精确点，应该使用矩阵除法操作符 x=A\b dsolve -Ordinary differential equation and system solver​ 解常微分方程和系统求解器​ S = dsolve(eqn)​ S = dsolve(eqn,cond)​ S = dsolve(eqn,cond,Name,Value)​ [y1,…,yN] = dsolve(___)​ note: Character vector inputs will be removed in a future release. Instead, use syms to declare variables and​ replace inputs such as dsolve(‘Dy = y’) with syms y(t); dsolve(diff(y,t) == y). plot - 2-D line plotplot(X,Y)plot(X,Y,LineSpec)plot(X1,Y1,…,Xn,Yn)plot(X1,Y1,LineSpec1,…,Xn,Yn,LineSpecn)plot(Y)plot(Y,LineSpec)plot(,Name,Value)plot(ax,)h = plot(___) plot(X,Y)creates a 2-D line plot of the data in Y versus the corresponding values in X.使用数据Y相对符合值X创造一个2-D线性图 X Data Types: single | double | int8 | int16 | int32 | int64 | uint8 | uint16 | uint32 | uint64 | categorical | datetime | duration Y Data Types: single | double | int8 | int16 | int32 | int64 | uint8 | uint16 | uint32 | uint64 | categorical | datetime | duration plot(X,Y,LineSpec)plot(X,Y,LineSpec) sets the line style, marker symbol, and color.画plot(X,Y,LineSpec)设置线风格，标记符号和原色 LineSpec — Line style, marker, and color character vector | string plot(___,Name,Value)specified line properties using one or more name,value pair arguments.For a list of properties,see Line Properties(https://ww2.mathworks.cn/help/matlab/ref/matlab.graphics.chart.primitive.line-properties.html?lang=en).Use this option with any of the input argument combinations in the previous syntaxes.Name-valuepair apply to all the lines plotted.使用一个或者多个name,value对属性来指定line properties.使用这些选项可以和在上面语法中任意输入参数结合.Name-Value对应用于所有画线。 plot(ax,___)creates the line in the axes specified by ax instead of in the current axes(gca).The option ax can precede andy of the input argument combinations inthe previous syntaxes在AX指定的轴中创建行，而不是在当前轴（GCA）中创建。选项AX可以先于前一个语法中的任何输入参数组合。 magic - Magic square This MATLAB function returns an n-by-n matrix construced from the integers 1 through n^2with row and column sums.这个函数将会返回一个从整数1至n^2的行和列的和都相等的n阶矩阵 fplotPlot expression or function画函数或者表达式区别于plot Syntax fplot(f) 默认的函数范围为[-5 5]fplot(f,xinterval)fplot(funx,funy)fplot(funx,funy,tinterval)fplot(,LineSpec)fplot(,Name,Value)fplot(ax,)fp = fplot()[x,y] = fplot(） Input Argutments f – Function to plotfunction handle 函数句柄函数将要画的，以命名的或者匿名的函数句柄来指定指定函数的组成 y = f(x).这个函数期待一个矢量输入参数和返回一个相同的大小的矢量输出参数。使用数组操作符代替矩阵操作符。例如，使用.(times) 代替(mtimes) compan - Companion Matrix 伴随矩阵 Syntax - 语法 A = compan(u) Description - 描述 A = compan(u) returns the corresponding matrixs these first row is -u(2:n)/u(1),where u is a vector of ploynomial coefficients.The eigenvalues of compan(u)are the roots of the ploynomial A = compan(u) 返回第一行是 -u(2:n)/u(1)的符合矩阵，其中u是一个多项式系数矢量。eig( compan(u) )特征值是多项式的根 surf - 3-D 影表面画图 -未看 description 这个函数功能根据z矩阵【m,n】=size(z)，使用x = 1:n和y = 1:m创造一个 three-dimensional shaded surface Syntax ​ surf(Z)​ surf(Z,C)​ surf(X,Y,Z)​ surf(X,Y,Z,C)​ surf(…,’PropertyName’,PropertyValue)​ surf(axes_handles,…)​ h = surf(…) Example 12345x = (1:0.3:5)'; % ’属于转置y = x';V = cos(x) * sin(y);n = length(x);surf(1:n,1:n,V) % surf(X,Y,Z) ppval - 计算分段多项式 Syntax v = ppval(pp,xq) Describle v = ppval(pp,xq) 在查询点 xq 处计算分段多项式 pp。 example 1234567breaks = [0 4 10 15]; %断点 区间分别为 [0,4] [4,10] [10,15]coefs = [0 1 -1 1 1; 0 0 1 -2 53; -1 6 1 4 77]; %对应多项式系数 5列:代表最高次数为5 pp = mkpp(breaks,coefs); %创建分段多项式xq = 0:0.01:15;plot(xq,ppval(pp,xq)) %计算多项式值和画函数line([4 4],ylim,'LineStyle','--','Color','k')line([10 10],ylim,'LineStyle','--','Color','k') diff - 微分符号函数或者函数 Syntax - Describle diff(F)微分F被symvar(F,1)决定的期待变量 diff(F,var) 微分F通过求导var变量 diff(F,n) 计算n次导通过对symvar决定的变量 diff(F,var,n) diff(F,var1,...,varN) Input Argument F –表达式或者函数将要被微分的 symbolic expression | symbolic function | symbolic vector | symbolic matrix Example 12345678function [ res ] = Test_Interpolation( )%Describe Find the derivative of the function sin(x^2).%Syntax diff(F)syms f(x); %定义一个函数变量f(x) = sin(x^2); %symbolic function%res = diff('sin(x^2)',x); symbolic expressionres = diff(f,x);end 12345678function [ res ] = Test_Interpolation( )%Describe Differentiation with Respect to Particular Variable%Syntax diff(F,var)sym x t;%symvar(t,1) %默认变量为x,你可以通过这个函数决定默认变量%也可以通过设置varres = diff(sin(x * t^2),t); %符号函数end 1234567function [ res ] = Test_Interpolation( )%Describe Higher-Order Derivatives of Univariate(单一的) Expression%高阶求导%Syntax diff(F,n)syms t;res = diff(t^6,4);end 123456function [ res ] = Test_Interpolation( )%Describe Mixed Derivatives%Syntax diff(F,var1,...,varN) syms x y;res = diff(x * sin(x * y),x,y); %先对x求导在对y求导end symvar - 在符号输入中发现符号变量 Find symbolic variables of symbolic input Syntax symvar(s) 它通过矢量方式返回在s中的符号变量。变量是以按字母顺序返回并且大写字母优于小写字母返回 symvar(s,n) 它选择按字母顺序最接近x的在s中的n个符号变量和返回它们以字母顺序。如果s是符号函数，symvar(s,n)返回s中的输入参数在s中的其他变量之前。 Input arguments s – input number | vector | matrix | array | symbolic number | symbolic variable | symbolic array | symbolic function | symbolic expression n – Number of variables integer Example 1234567function fout = Test(a,b,c)%Describe Find symbolic variables in expression%Syntax symvar(s) syms wa wb ya ybsum = wa +wb + ya + yb;symvar(sum) %按字母顺序返回变量 wa wb ya ybend 1234567function fout = Test(a,b,c)%Describe Find Default variable of expression%Syntax symvar(s,n) syms v zg = v + z;symvar(g,1) %发现默认自变量 zend subs - 符号代替Syntax subs(s,old,new) 返回一个s的复制，代替所有的old的出现为new，和计算s subs(s,new) 返回一个s的复制，代替在s中所有的默认变量出现为new，和计算s。默认变量是定义通过symvar. sub(s) 反回一个s的复制，代替在s中所有的符号变量。这些符号变量的值来自调用函数和MatLab工作空间，和计算s。没有赋值的值将会保持作为变量 Input Arguments s – Input symbolic variable | symbolic expression | symbolic equation | symbolic function | symbolic array | symbolic matrix old – Element to substitute symbolic variable | symbolic expression | symbolic array new – New element number | symbolic number | symbolic variable | symbolic expression | symbolic array | structure Example 123456function fout = Test(a,b,c)%Describe Single Substitution%Syntax subs(s,old,new)syms a bsubs(a + b,a,4) %代替a为4并计算end 1234567function fout = Test(a,b,c)%Describe default Substitution variable%Syntax subs(s,new)syms x y asymvar(x + y,1); %按字母顺序 xsubs(x + y,a) %根据上面默认变量，替换x为aend 1234567%Describe update Expression with new value%Syntax subs(s)syms a y(t)y = dsolve(diff(y) == -a*y)a = 980;C2 = 3;subs(y) solve - 方程和系统求解器Syntax S = solve(eqn,var) 解方程变量通过方程 eqn，如果你并没有指定 var, symvar函数决定解变量。 S = solve(eqn,var,Name,Value) solve(eqn,var,Name,Value) 使用一个或者多个Name,Vakue对参数指定额外的选择 Y = solve(eqns,vars) 解指定变量 vars 通过系统方程 eqns和返回一个包含解的结构体。如果你并没有指定 vars,solve使用symvar来找到解变量。在这个案例中，symvar发现的变量数量等于方程 eqns的数量 [y1,…,yN] = solve(eqns,vars) 解指定变量 vars 通过系统方程 eqns和这个解将会被赋值给变量y1,y2,y3…yN,solve使用symvar来找到解变量。在这个案例中，symvar发现的变量数量等于方程 eqns的数量 [y1,…,yN,parameters,conditions] = solve(eqns,vars,’ReturnConditions’,true) 返回额外的参数自变量和指定解和此解的条件的参数 其他未写:busts_in_silhouette: Input Arguments eqn – Equation to solve symbolic expression | symbolic equation var – Variable for which you solve equation symbolic variable Example 1234567function fout = Test(a,b,c)%Describe Solve an equation%Syntax solve(eqn,var)syms xeqn = sin(x) == 1;solx = solve(eqn,x) %pi/2，solve并不会返回一个无限集合，可以使用name value 设置，2014a不存在这个参数end 12345678function fout = Test(a,b,c)%Describe Return real solutions%Syntax solve(eqn,var,Name,Value)syms xeqn = x^5 == 3125;solve(eqn,x); %返回实数根和负数根solve(eqn,x,'Real',true) %只返回实数根end 1234567891011function S = Test(a,b,c)%Describe Solve Multivariate Equations and Assign Outputs to Structure%Syntax solve(eqns,vars)syms u veqns = [2*u + v == 0,u - v == 1];S = solve(eqns,u,v); %以结构体返回expr1 = u^2;subs(expr1, S) %替换u通过已知值expr2 = 3*v+u;subs(expr2, S) %替换v通过已知值end Other 图解法和slove和fsolve的比较 点击]]></content>
      <categories>
        <category>extension</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>functions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[token简单介绍]]></title>
    <url>%2F%2F2018%2F09%2Fextension-%E4%BB%80%E4%B9%88%E6%98%AFtoken.html</url>
    <content type="text"><![CDATA[什么是tokentoken的意思是”令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。 当用户登陆后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token并将此token返回给客户端，无需再次带上用户名和密码。 简单的token的组成：uid^1 time^2 sign^3 身份认证概述HTTP是一种没有状态的协议，他并不知道是谁访问了我们的应用 解决方案 session/cookie token 客户端使用用户名和密码请求登陆。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。客户端收到token后把它存储起来，可以放在cookie或者Local Storage。客户端每次向服务端发送请求的时候都需要带上服务端发给的token。如果验证成功，就像客户端返回请求的数据。 Token登陆认证几个方式 用设备mac地址作为token 用sessionid作为token Token的存储token可以存到数据库中，但是有可能查询token的时间会过长导致token丢失 为了避免查询时间过长，可以将token放到内存中。这样的查询速度绝对不是问题，也不担心占据内存，就算token是一个32位的字符串，应用的用户量在百万级或者千万级，也是占不了多少内存的。 Token的加密token是很容易泄露的，如果不进行加密处理，很容易被恶意拷贝并用来登陆 在存储的时候把token进行对称加密存储，用到的时候再解密。文章最开始提到的签名sign：将请求URL、时间戳time、token三者合并，通过算法进行加密处理。]]></content>
      <categories>
        <category>extension</category>
      </categories>
      <tags>
        <tag>understand</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题解决]]></title>
    <url>%2F%2F2018%2F09%2Fextension-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[问题解决(1) 导入.jar文件可执行文件与eclipse需要重写遇到did not contain the main type的原因导入后实际为普通文件形式，不属于src文件，不能运行，*.jar里面的库重新build path导入，其它.java复制进去 其他可能造成的原因请看 (2) 未在jdk中找到javax.xml.blind（classnotFoundException)jdk9.0.1已经抛弃javax.xml.blind包，从maven导入找到要导入的包及依赖库描述，建立一个maven项目artifact，在pom.xml中加入依赖dependency具体参考 (3) WARNING: An illegal reflective access operation has occurredWARNING: Illegal reflective access by com.sun.xml.bind.v2.runtime.reflect.opt.Injector (file:/C:/Users/13612/.m2/repository/com/sun/xml/bind/jaxb-impl/2.3.0/jaxb-impl-2.3.0.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int) WARNING: Please consider reporting this to the maintainercom.sun.xml.bind.v2.runtime.reflect.opt.Injector WARNING: Use –illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release原因：jdk9加入的安全解决方案 123456789101: public static void main(String[] args) &#123; //屏蔽掉非法反射访问，JDK9 StudentMessagHandler.disableWarning();//主要这个语句 StudentMessagHandler smh=new StudentMessagHandler( "C:\\data\\（含预警1.0）大一、大二、大三通讯录\\" + "（含预警）大一、大二、大三通讯录\\学生通讯录\\16级\\160801.xlsx"); for(String str:smh.randomMacth(5)) &#123; System.out.println(str); &#125; &#125; 2: StackOverflow查找问题解决方案 (4) 405 method not allowed原因 在尝试访问endpoint使用浏览器工具，然而，什么嘛时候打印资源URL在浏览器框，是正在执行request请求，这和是默认的因此，浏览器不能给你灵活的测试REST API，你只能执行GET请求。 解决方案 为了测试rest API，你应该使用正确的工具。有下列几种：CURL,PostMan等 具体请看 (5) curl安装 进入官网 具体请看 (6) the type** is not accessible​ 用eclipse build path导入classpath or module path存在，但通过以Maven形式导入，不存在这种问题 深层封装问题，未解决。 (7) 实参和形参的区别请看DeleteLinkedNodeFromTO（packet Algorithm） 参考 (8) Could not instantiate TestExecutionListenerSpecify custom listener classes or make the default listener classes (and their required dependencies) available. Offending class: [javax/servlet/ServletContext]原因没有提供存在该包lib，如果没有使用web一些包，可以不需要管这个问题，这是默认的springTest实例的一些类具体解决方案请看 (9) java.lang.ClassNotFoundException: javax.xml.bind.JAXBException原因未发现这个javax.xml.bind/..包在发布web应用里面由于java9module配置移除了java ee包含的java/xml/bind/解决方案发布的web应用下面lib库中添加有关联的包具体解决方案 (10) 严重: Invalid message recieved with signature 18245 原因 这个提示是由于我用HTTP方式访问了8009端口，而8009端口是通过AJP访问的 (11) 关于mysql Access denied for user root@localhos问题解答 原因 首次登录mysql密码未设置是遇到拒绝访问，权限检查不予许 解决方案 如果未关闭MYSQL服务，关闭MYSQL服务 例：command line:net stop mysql; 进入安装目录 $/my.ini配置文件，在[mysqld]条目下添加–skip-grant-tables，过着cmd命令 $mysqld-nt –skip-grant-tables，启动mysql，忽略权限检查 在mysql命令行中，mysqladmin -u root flush-privileges password “newpassword” 重设root密码 net start mysql 重新登录 (12) 关于phpmydmin管理界面不存在添加用户权限的原因解答原因首次登录未设置密码权限不够导致.通过上面的解决方案，可以解决这个问题 (13) C语言中标准输入的结束符 windows CTRL+z，linux是Ctrl+d(14) An invalid character [32] was present in the Cookie valueWEB16 lastAccessTimeServlet SimpleDateFormat format = new SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”);原因an invalid character [32] was present in the Cookie value 中32对应的编码是空格Stack Overflow上的回答：This is due to Tomcat&#39;s cookie processing being changed to a RFC 6265 compliant implementation by default in 8.5, which does not allow space (character 32), among others. 我的tomcat版本是9.0，发现WEB16 lastAccessTimeServlet SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)这行代码yyyy-MM-dd hh:mm:ss存在空格。 解决方案去除空格，问题解决具体解决思路 (15) android:can’t resolve R原因可能R文件无意删除或者其他因素解决方法build-&gt;rebuild(重新生成R文件) (16) github There isn’t a GitHub Pages site here.github page 绑定域名以后，在浏览器输入域名但是出现上面错误。原因域名已经成功解析到远程主机（github page），但是因为github page绑定域名需要一个特定文件CNAME（包含域名）才能定向到github，因为我并没有创建。解决方法创建一个特定的CNAME文件，在里面加入自己的域名` (17) java.net.UnknownHostException: Unable to resolve host “guolin.tech”: No address associated with hostname在做第一行代码天气项目遇到问题原因安卓浏览器hostname不能够resolved，如果domain name没有附上的 具体原因解决方法$ ping guolin.tech,替换host域名为ip地址，例子ip为：47.90.126.26 (18) 未能解决plugin with id ‘com.android.application’ not found$待解决不是步骤 new--&gt;import project而是步骤 new--&gt;import module (19)插入数据库类型Date值错误 第一种情况:Unknown column ‘2018-02-29’ in ‘field list’1INSERT INTO product(pid,pname,market_price,shop_price,pimage,pdate,is_hot,pdesc,pflag,cid) VALUES(&quot;ghu2&quot;,&quot;12312&quot;,123.2,23.2,&quot;img/1.jpg&quot;,`2018-02-29`,0,&quot;des&quot;,0,&quot;www&quot;); 原因 1`2018-02-29`应该使用&apos;2018-02-29&apos;,错误使用符号 第二种情况 Incorrect date value: ‘2018-02-29’ for column ‘pdate’ at row 1 1INSERT INTO product(pid,pname,market_price,shop_price,pimage,pdate,is_hot,pdesc,pflag,cid) VALUES(&quot;ghu2&quot;,&quot;12312&quot;,123.2,23.2,&quot;img/1.jpg&quot;,&apos;2018-02-29&apos;,0,&quot;des&quot;,0,&quot;www&quot;); 原因 1&apos;2018-02-29&apos; 2018年时平年，不存在29日... 正确答案 1INSERT INTO product(pid,pname,market_price,shop_price,pimage,pdate,is_hot,pdesc,pflag,cid) VALUES(&quot;ghu2&quot;,&quot;12312&quot;,123.2,23.2,&quot;img/1.jpg&quot;,&apos;1999-01-23&apos;,0,&quot;des&quot;,0,&quot;www&quot;); (20) ClassNotFoundException异常 未导入特定jar包，可通过查看具体那个类的未导入声明来决定应该导入那个包 egg 即可以看出是属于javax/activation/DataSource类，然后通过Maven配置文件或者导入jar文件来解决 Maven 包已经导入，但是还是出现异常，可能情况查看自己是否是JAVA WEB应用，如果是的话，查看是否此包正确导入到lib库中 (21) MYSQL:WARN: Establishing SSL connection without server’s identity verification is not recommended.问题解决 (22)]]></content>
      <categories>
        <category>extension</category>
      </categories>
      <tags>
        <tag>problem</tag>
        <tag>solve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式匹配]]></title>
    <url>%2F%2F2018%2F09%2Falgorithm-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html</url>
    <content type="text"><![CDATA[模式匹配给定两个字符串S=$$”s_1,s_2,…s_n”$$和T =”$$t_1,t_2…t_n$$”，在主串S种寻找子串T的过程称为模式匹配pattern matching，T称为模式pattern。如果匹配成功，返回T在S中的位置；如果匹配失败，返回0。 BF算法基本思想：从主串S的第一个字符开始和模式T的第一个字符进行比较，若相等，则继续比较二者的后续字符；否则，从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直至S或T中所有字符比较完毕。若T中的字符全部比较完毕，则匹配成功，返回本地匹配的开始位置；否则匹配失败，返回0。 BF算法的伪代码描述如下 在串S和串T中设置比较的起始下标 i 和 j ; 重复下述操作，直到S或T的所有字符均比较完毕。 如果S[i] == T[j]，继续比较S和T的下一对字符 否则将下标 i 和 j 回溯，准备下一趟比较。 如果T中所有字符均比较完，则匹配成功，返回匹配的开始位置；否则匹配失败，返回0。 算法复杂度设主串的长度为n,模式T的长度为m 在最好的情况下，每趟不成功的匹配都发生在模式T的第m个字符。假设不成功的匹配次数为$$i-1$$,则比较的次数为$$(i-1)m$$,第$$i$$躺比较的次数为$$m$$次，共比较的次数为$$im$$, 所有成功匹配的位置共有$$n-m+1$$,设每次不成功的概率为$$p$$,在等概率的情况下 $$\sum\limits_{i = 1}^{n-m+1} {{\frac{1}{(n-m+1)}*(i*m)}}=m\frac{(n-m+2)}{2}$$ 一般情况下，$$m&lt;&lt;n$$，因此最坏的情况下的时间复杂度是$$O(m*n)$$ 分析=\ 为不等于 造成BF算法效率低的原因是回溯，即在某躺匹配失败后，对于主串S要回溯到本躺匹配开始字符的下一个字符，模式$$T$$要回溯到第一个字符，而这些回溯往往是不必要的。如图alrotithm-bf-matching_01所示的匹配过程，在第一躺中S[0]-S[3]和T[0]-T[3]是匹配成功的，S[4]和T[4]不匹配的，因此有了第二趟。因为在第一躺中有S[1] = T[1]，而T[0] =\ T[1]，因此有T[0] =\ S[1]，所以第二趟是不必要的，同理第3躺也是不必要的，可以直接到第4躺。进一步分析第4躺中第一对字符S[3]和T[0]的比较是多余的，因为第一趟已经比较了S[3]和T[3]，并且S[3] = T[3]，而T[0] = T[3]，因此必有S[3] = T[0]，因此第四躺比较可以从第二对字符S[4]和T[1]开始进行比较。这就是说，第一趟匹配失败后，下标i不会溯，而是将下标j回溯至第2个字符，用T[1]对准S[4]进行比较。 ​ algorithm-bf-matching_01 综上所述，希望某躺在S[i]和T[j]匹配失败后，下标i不会溯，下标j回溯至某个位置k，使得T[k]对准S[i]继续进行比较。显然，关键问题是如何确定位置k KMP算法基本思想:主串不进行回溯 KMP的由来由上分析可知，关键问题是如何确定位置k 观察部分匹配成功时的特征,某躺在S[i]和T[j]匹配失败后，下一趟比较从S[i]和T[k]开始，则有T[0]-T[k -1] = S[i - k]-S[i -1]成立，如图algorithm-bf-matching_02(b)所示；在部分匹配成功时，有T[j - k]-K[j - 1]=S[j - k]-S[i - 1]成立，如图algorithm-bf-matching_02(a)所示 由T[0]-T[k -1] = S[i - k]-S[i -1]和T[j - k]-K[j - 1]=S[j - k]-S[i - 1]，可得 ​ T[0]-T[k -1] = T[j - k]-K[j - 1] 上式说明，模式中的每一个字符T[j]都对应一个k值，这个k值仅依赖于模式本身字符系列的构成，与主串无关。用next[j]表示T[j]对应的k值(0&lt;=j&lt;m),其定义如下 $$\left{ \begin{array}{l}{\rm{-1 [round :j=0]}}\{\rm{max [round:k| 1&lt;=k&lt;j且 T[0]-T[k -1] = T[j - k]-K[j - 1]]}}\{\rm{0[round:其他情况]}}\end{array} \right.$$ KMP的伪代码 在串S和串T中分别设置比较的起始下标 i 和 j ; 重复下述操作，直到所有S或T的所有字符均比较完毕； 如果S[i]等于T[j]，继续比较S和T的下一对字符； 否则将下标 j 回溯到next[j]位置，即 j = next[j]； 如果 j 等于-1，则将下标 i 和 j 分别加1，准备下一趟比较 如果T中所有的字符均比较完毕，则返回匹配的开始位置；否则返回0； Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pattern_matching;public class KMP &#123; public static int KMPIndex(char[] S,char[] T)&#123; int m = 0,n = 0; int sLen = S.length; int tLen = T.length; int[] next = getNext(T); while (m &lt; sLen &amp;&amp; n &lt; tLen)&#123; //S[m] == T[n] //j==-1说明在之前匹配中不存在可匹配部分字符 //直接m向前偏移一位，j重新从0匹配 if(n == -1 || S[m] == T[n]) &#123; ++ m; ++ n; &#125;else&#123; n = next[n]; //n = next[m]; &#125; &#125; if (n == tLen) return m - n; else return -1; &#125; private static int[] getNext(char[] T_)&#123; int[] next_ = null; next_[0] = -1; int k = -1; int j = 0; //T_.length while(j &lt; T_.length - 1)&#123; if(k == -1 &amp;&amp; T_[k] == T_[j])&#123; ++ k; ++ j; next_[j] = k; &#125;else&#123; k = next_[k]; &#125; &#125; return next_; &#125; public static void main(String[] args) &#123; char[] S = &#123;'a','b','c','e'&#125;; char[] T = &#123;'c','d','e'&#125;; int k = BF.bfIndex(S , T); if(k == -1) System.out.println("pattern matching is failure"); else System.out.println("pattern matching is successful"); &#125;&#125; 问题分析假设模式T为“ababaab” next_[]代表存储字符数组，next[]代表存储匹配值数组 为什么不用计算next[7]? 123//代码错误片段//T_.lengthwhile(j &lt; T_.length - 1)&#123; 答：在最后一个字符匹配失败时，在前面六个字符中寻找最大匹配，此时最大匹配值放在next[6]里面，所以并不存在计算next[7] 为什么用next[k]=k? 12&#125;else&#123; k = next_[k]; 答： 在寻找next[6]匹配时，此时k=3,j=5。因为next_[5]!=next_[3]的，所以next[6]不是next[5]的简单加1，即next[6]=next[5]+1。 我们知道next_[0]next_[1]next_[2]=next_[2]next_[3]next_[4]，如图alrotithm_bf_matching_04所示。next[6]在失配时最大的值为next[6]=3,即next_[0]next_[1]next_[2]=next_[4]next_[5]next_[6]情况，这样要满足什么情况下呢？ **显然，一定要存在，next_[0]next_[1]=next_[4]next_[5]，又因为next_[1]next_[2]=next_[4]next_[5]。即满足next_[0]next_[1]=next_[1]next_[2]。可知，这即是next[k]=next[3]所代表的值；然后只需在判断next_[2]是否等于next_[6]，由k=next_[k]下一次循环判断若相等，既可判断next_[0]next_[1]next_[2] =next_[4]next_[5]next_[6]相等。同理，next[6]在失配时次大，次次大的值为2,1也可以通过这样判断。 综上所述，我们可以通过判断k=next[k]的值，可知在next[6]失配时，即next_[5]!=next_[3]情况下，存在的next[6]最大值。 任意情况下可通过上面方法判断 算法复杂度(文本字符串不回溯)文本串的长度为n,模式串长度为m，匹配过程时间复杂度为o(n),算上计算next数组的o(m)时间，KMP的整体时x间复杂度为o(m+n) 扩展算法BM算法BM算法定义了两个规则： 坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们成文本串中的这个失配字符为坏字符，此时模式串需要 向右移动。（移动的位数=坏字符在模式串中的位置-坏字符在模式串中最有出现的位置）此时，如果‘坏字符’不包含在模式串之中，则最有出现位置为-1。 好后缀规则：当字符失配时，后移位置=（最大）好后缀在模式串中的位置-好后缀在模式串上一次出现的位置，且如果好后缀在模式串 中没有出现，则为-1 时间复杂度在最坏的情况下能够保持o(n) Sunday算法Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似，不过Sunday算法时从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符 如果该字符没有在模式串中出现则直接跳过，即移动位数=匹配串长度+1 否则，其移动位数=模式串中最右端的该字符到末尾的距离+1]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F%2F2018%2F09%2Fapi-StringStringBufferStringBuilder%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[String StringBuffer StringBuilder区别 String使不可变的^1 ；String用final修饰，不可继承；String本质上是一个final的char[]数组，所以char[]数组的内存地址不会被修改，而且String也没有暴露修改char[]数组的方法；不可变性可以保证线程安全以及字符串常量池的实现；频繁的增删操作是不建议使用String的 StringBuffer是线程安全的，多线程建议使用这个 StringBuffer是非线程安全的，单线程使用这个更快 String StringBuffer StringBuilder最终底层存储于操作的都是char数组.但是String里面的char数组是final的，而StringBuffer StringBuilder不是，也就是说String是不可变的，想要新的字符串智能重新生成String。而StringBuffer StringBuilder只需要修改底层的char数组就行。相对来说，开销要小很多。 String的大多数方法都是重新new一个新String对象返回，频繁重新生成容易生成很多垃圾 StringBuffer是线程安全的，StringBuffer是非线程安全的，因为StringBuffer的方法是加了synchronized锁起来的，而StringBuilder没有 [参考引用] 你知道String、StringBuffer和StringBuilder之间的区别吗？ -https://mp.weixin.qq.com/s/6mNH4re2wDrp49gTPVMMtw]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F%2F2018%2F09%2Fdeploy-Redis.html</url>
    <content type="text"><![CDATA[Redis控制五种数据类型 string list hash set sorted-set 添加数据123Syntax:set &lt;key&gt; &lt;value&gt;eg:set name xiao 删除数据123Syntax:del &lt;key&gt; eg:del name 获取数据123Syntax:get &lt;key&gt;eg:get name 查看有多少个元素12eg:keys * 选择仓库123Syntax:select &lt;数字&gt;eg:select 1 #选择一号仓库，默认为0号仓库，总共为16个仓库 移动键值对到另外仓库123Syntax:move &lt;key&gt; &lt;数字&gt;eg:move name 1 测试测试连接是否存活1234eg:ping #如果响应为PONG，则说明连接存活egecho zhangsan #在命令行打印一些东西 返回当前数据库中key的数目12eg:dbsize 删除当前选择数据库中的所有key12eg:flushdb 删除所有数据库中的所有key12eg:flushall]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本组件]]></title>
    <url>%2F%2F2018%2F09%2Fapi-JTextComponent.html</url>
    <content type="text"><![CDATA[JTextComponentdescendants 子孙,后代 JTextComponent类是Swing位文本模块基础。这个类为它的所有子孙后代提供下述习惯化特征 model，也叫做document，管理组件内容 view，在屏幕上展示组件 controller，也叫做editor kit，阅读和写文本和实现actions编辑兼容 插件式光标caret和支持光标改变监听器和导航过滤器 关于Documents文本组件是Model和View分离，可以查看Using Models参考 文本组件Model是被叫做document和实现了Document接口的实例。一个document为文本组件提供下述服务。 document在Element对象储存文本内容。 通过remove和insertString方法提供编辑文本支持 通知文本监听器和撤销编辑监听器关于文本的改变 管理追踪在文本中即使被修改了的特殊的位置的Position对象 承诺你获得文本信息 Swing包含Document子接口eg:StyledDocumentd等。一般JTextComponent子类默认请求StyledDocument 详情请看document类继承关系 如果你使用setPage方法来加载文本到editor板或者text板，document实例被pane使用可能会改变。请看How to Use Editor Panes and Text Panes 你能通过安装一个document filter或者代替文本组件的document来实现你自己习惯化的事物。eg:使用document filter来改变如何文本组件数据被设置 查看简单的Implementing a Document Filter代码片段 关于Editor Kits文本组件使用EditorKit来绑定不同片段的文本组件。EditorKit提供view factory,document,caret,actions。一个editor kit也阅读和写特殊格式的document。所有的文本组件使用editor kit，Editor panes和text panes提供getEditorKit方法获得目前Editor kit和setEditorKit方法来改变它。 JTextComponent类提供API帮助你直接调用或者习惯化一些Editor kit能力。例如，JTextComponent提供调用editor kit的read和write的read和write的方法；也是提供返回所有被该组件支持的actions通过getActions. Swing文本包提供下述的editor kits DefaultEditorKit StyledEditorKit HtmlEditorKit 每一个editor kit列举在上面的已经被JEditorPane注册和联系kit阅读,写和编辑的文本格式。当一个文件被加载到EditorPane，这个板依靠注册kit检查文件格式。如果注册kit是发现支持这个文件格式，pane使用这个kit来阅读文件，展示和编辑它。那么，editor pane有效率的转换它自己到符合文本格式的editor。 你能够继承JEditorPane来支持你自己文本格式通过为它创造一个editor kit，和使用JEditorPane‘s registerEditorKitForContentType 来联系你的文本格式的kit TextComponentDemo联系文本组件例子扩展的知识点 Associating Text Actions with menus and Buttons所有的文本组件支持标准得编辑命令，例如 Cut,Paste,Insert字符命令。每个编辑命令是通过Action对象表示和实现。学习更多关于Actions。Actions承诺联系命令和GUI组件，例如菜单项和按钮。 上述Action的名字来自于DefaultEditorKit。这个kit提供基础的文本编辑和是所有被Swing提供的文本编辑kit eg:StyledEditorKit 提供styled text的编辑命令的父类 。所以它是被所有的文本组件兼容的，除非那些是为了习惯化重载了的。 为了效率，文本组件分享Action。这个分享的特性characteristic有两个重要的衍生ramifications 你不需要修改Action对象你从Editor Kits。如果你做了，这个将影响在你项目中的所有文本组件 Action能够运行在其他文本组件。如果你不想分享，实例化Action对象 Associating Text Actions With Key Strokes使用文本组件的Input Map联系Key Stroke的Action。了解更多的Input Binding信息 下述代码添加Ctrl-B键绑定TextPane。 123InputMap inputMap = textPane.getInputMap();KeyStroke key = KeyStroke.getKeyStoke(KeyEvent.VK_B,Event.CTRL_MASK);inputMap.put(key,DefaultEditorKit.backwardAction); 首先，这个代码获得了文本组件的Input Map。然后，它发现表示Ctrl-B键对的一个KeyStroke对象。最后，这个代码绑定这个Key Stroke到光标后退的Action Implementing Undo and Redo实现撤销和重做有两部分 记住撤销的编辑文本 为了支持撤销和重做，文本组件必须记住每次编辑文本的发生，编辑的顺序和在每次需要撤销的编辑中什么是需要的。UndoManager类可以管理这些撤销的编辑的表单。 step1:实例化一个UndoManager step2:在document中添加UndoListener,为UndoMana获取上次编辑的内容 查看更多的关于撤销编辑监听器undoable edit listener和撤销编辑事件，请看How to Write an Undoable Edit Listener 实现撤销和重做命令和为它们提供使用者接口 step1:添加实现undo和redo的Action放在需要添加Action的组件 step2:实现undo和redo的abstractAction Implementing a Document Filterstep1:创造一个DocumentFilter的子类 step2:使用一个定义在AbstractDocument的setDocumentFilter方法附着它到document : Note 默认Swing文本组件使用AbstractDocument子类作为它们的document Listening for changes on a Document你能够在document注册两种不同的监听器 document listener and undoable edit listeners 查看更多undoable edit listener 使用document listener来加入发生插入和删除或者文本风格改变时候的反应 step1:创造一个实现了DocumentListener的子类 step2:在doc的addDocumentListener添加上述类 监听器实现三个不同的文档事件insertion,removal,stylechanges 关于更多的文档监听器信息和文档事件，查看How to Write a Document Listener 警告你可能想在文档监听器修改文档文本，但是，这个是不允许在文档监听器修改的。因为这样可能导致项目死锁问题。你可以使用格式化的文本字段field或者提供一个document过滤器达到修改的目的 Listening for Caret and Selection ChangesTextComponentDemo项目使用caret监听器展示caret目前的位置。如果文本是被选择，那么扩展选择 step1:创造一个实现了CaretListener的类 step2:在文本组件addCaretListener类中添加上述的类 step3:必须实现的方法 caretUpdate 更多的信息关于caret监听器和caret事件，请看How to Write Caret Listener 如果你想要改变Caret或者Selection，使用navigation filter或者习惯化的caret 实现navigation filter 写一个NavigationFilter的子类 通过setNavigationFilter方法添加子类的实现到文本组件 实现习惯化的caret 实现Caret接口，或者扩展DefaultCarets类 通过setCaret方法添加子类的实现到文本组件 文本组件API这些API列举在这个部分包括下述的目录 设置属性JTextComponent类 编辑,组件之间边距等 操控选择部分 传递介于Model和View的Position 文本编辑命令 cut,copy 表示Document的类和接口 工作在Document 操控Carets and Selection Highlighters 阅读和写文本]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[j按键事件]]></title>
    <url>%2F%2F2018%2F09%2Fapi-JKeyEvent.html</url>
    <content type="text"><![CDATA[JKeyEvent一个指示keystroke在组件发生的事件。 按键在被按压，释放或者敲得时候low-level event较低层级事件被组件对象生成例如：tetx field。这些事件是被传递到已经通过组件addKeyListener注册的KeyListener或者KeyAdapter对象来接受这些事件。KeyAdapter Objects实现KeyListener接口。当事件发生的时候，每一个监听器得到这个事件 Key typed event是higher level高层级的和不依赖平台或者键盘布局的。当Unicode字符是被键入，它们是被生成的和以一种最完美的方式找到字符输入。 getKeyChar方法总是返回一个有效的Unicode字符或者CHAR_UNDEFINED。字符输入是报道通过KEY_TYPED事件 对于键按压和键释放事件，getKeyCode方法返回事件keyCode Key Pressed和Key Released事件依赖平台和键盘布局。是唯一的方式发现键这个并没有字符输入action keys,modifier keys等 按压和释放一个在键盘中的键造成下述键事件的合成 KEY_PRESSED KEY_TYPED KEY_RELEASED]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[键盘绑定]]></title>
    <url>%2F%2F2018%2F09%2Fapi-JKeyBinding.html</url>
    <content type="text"><![CDATA[JKeyBindingJComponent类支持键绑定作为一种方式响应用户的键敲入。 通常不需要直接地使用键绑定。在使用这些键绑定的时候应该先考虑使用助记键mnemonics[被所有的按钮支持和索引式窗格tabbed panes和JLabel]和加速键[被菜单项支持]。你能够发现通用的助记键和加速键在Enabling Keyboard Operation部分 How Key Binding Work键绑定支持由JComponent提供的，依赖于InputMap和ActionMap类。input map绑定key strokes到action names，和action map指定action符合每个action名字。 每一个JComponent有一个Action map和三个Input map。这些input map符合下述聚焦情况： JComponent.WHEN_FOCUSED 组件有键盘聚焦 JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT 组件包含[继承]或者是已经聚焦的组件。这个Input Map是通常在组合组件中使用 JComponent.WHEN_IN_FOCUSED_WINDOW 组件窗口已经聚焦或者包含已经聚焦的组件 当用户敲了一个键，JComponent键事件处理代码寻找一个或多个Input Map来为键找到有效的绑定。当它发现绑定，它寻找在action map符合中action。如果这个action是enabled,这个绑定是有效的和这个action是执行的。如果是disabled，寻找有效的绑定是继续的 如果单个键存在多个绑定，只有第一个发现且有效的是被执行的。Input maps是以这种顺序被检查的。 聚焦的组件的JComponent.WHEN_FOCUSED的input map 聚焦的组件的JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT的input map 聚焦的组件的父亲JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT的input map，然后父亲的父亲，按照继承顺序。:arrow_down_small:组件禁止input map是被略过的 所有的enabled组件在聚焦窗口的JComponent.WHEN_IN_FOCUSED_WINDOW的input map是被搜索的 How to Make and Remove Key Bindings12345//特定字符串"doSomething"绑定一个key Stroke component.getInputMap().put(KeyStroke.getKeyStroke("F2"),"doSomething");//特定字符串"doSimething"绑定一个特定的actioncomponent.getActionMap().put("doSomething",anAction);//where anAction is a javax.swing.Action 你能发现关于创造Action例子在How to Use Actions 为了让组件忽视通常响应的键，你能使用指定Action name,即[none]。例如，下述代码让组件忽视F2键。 1component.getInputMap().put(KeyStroke.getKeyStroke("F2"),"none"); :heavy_plus_sign:Note:在先前的代码不能WHEN_ANCESTOR_OF_FOCUSED_COMPONENT and WHEN_IN_FOCUSED_WINDOW input map搜索F2键的绑定。为了阻止这种搜索，能够使用有效的action代替[none]。例 1234567Action doNothing =new AbstractAction() &#123; public void = new actionPerformed(ActionEvent e)&#123; //do nothing &#125;&#125;;component.getInputMap().put(KeyStroke.getKeyStroke("F2"),"doNothing");component.getActionMap().put("doNothing",doNoting); The Key Binding API 创造和使用InputMaps 创造和使用ActionMaps]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java日志]]></title>
    <url>%2F%2F2018%2F09%2Fapi-Java%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F-Logger.html</url>
    <content type="text"><![CDATA[Java日志系统 - LoggerLogger类是用来记录某个级别的日志信息 级别 SEVERE WARNING INFO FINE FINER FINEST 级别按从上至下逐级剃减 另外还有级别OFF，可以用来关闭日志；使用]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awt和swing简易性质]]></title>
    <url>%2F%2F2018%2F09%2Fapi-Java-Awt%E5%8C%85%E5%92%8Cjava-Swing%E7%9A%84%E7%AE%80%E6%98%93%E6%80%A7%E8%B4%A8%E5%92%8C%E8%B5%B7%E6%BA%90.html</url>
    <content type="text"><![CDATA[Java SE 9 Java.Awt包和java.Swing的简易性质和起源起源GUI图形用户界面为程序提供界面。最初的目的为程序员构建一个通用的GUI，使其能够在所有平台运行。但java1.0中的基础类AWT抽象窗口箱并不能够实现这个目的，所以Swing出现了 简易性质 相互存在性 Swing是AWT的增强组件，但是它并不能完全替代AWT组件 平台无关性 Swing属于”轻量级组件”，完全由Java编写，而Java不依赖操作系统；AWT属于”重量级组件”，依赖本地平台的窗口来决定组件的功能，外观和风格 JTextArea 容量capabilities java.awt.TextArea &lt; JTextArea &lt;JTextPane/JEditorPane 滚动scrolling 内部处理滚动，实现Scrollable接口。如果想要滚动操作，可以放置在JScrollPane，否则直接使用 行包装Line wrap 实现换行通过设置属性，默认为false，不包装 行和列row column 设置喜欢的大小 文本倾听器TextListener 123DocumentListener myListener = ??JTextArea myArea = ??myArea.getDocument().addDocumentListener(myListener);]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAction]]></title>
    <url>%2F%2F2018%2F09%2Fapi-JAction-API-Interface.html</url>
    <content type="text"><![CDATA[JAction - API - InterfaceAll SuperInterface ActionListener EventListener Action接口提供一个对ActionListener接口有用的扩展当相同功能可能被多个控件访问的时候 Swing组件支持Action许多Swing组件有Action属性。当Action是在组件被设置，下述的事情将发生 Action被添加作为ActionListener到组件 组件配置一些属于他的属性来匹配Action 组件在Action安装中PropertyChangeListener，所以组件能改变他的属性来更改在Action中的属性改变。 下述表描述被Swing组件使用的支持Actions的属性 eg: Component Property Components Action Key Notes toolTipText All SHORT_DESCRIPTION 表示在所有的Swing组件都可以通过putValue方法的ActionKey键”SHORT_DESCRIPTION”设置的提示信息文本。 12//where is Action classputValue(SHORT_DESCRIPTION, desc); //desc为描述提示停息的文本字符串 注意：其他属性请通过标题名字链接查询 How to Use Action具体可以查询demo在Intellij Datastructlecturedesignation-&gt;test-&gt;ActionDemo|引自Oracle tutorial 一个Action能够被用来从一个组件分离功能和状态。例如，如果你有两个或者更多组件执行相同的功能，考虑使用一个Action对象来实现功能。一个Action对象是一个Action Listener这个提供不仅Action-Event处理，也中心化处理action-event-firing组件状态。 你典型地附着一个action到组件使用setAction方法。在这里列举当setAction是在组件中被调用会发生什么 组件状态被更新来匹配Action的状态。例如，如果Action的文本和图标被设置。组件文本和图标也被设置成这些值。 这个Action对象是被注册作为一个在组建的Action Listener 如果Action的状态被改变，组建状态是被更新来匹配Action。例如，如果你改变在Action中Enabled状态，它附着的所有组件将会改变他们的来匹配这个Action。 The Action API 支持set/getAction的组件 创造和使用一个AbsttracAction Action属性 定义了能在一个Action设置的属性。组件自动使用这个属性[在附在menu item中的Action设置ACCELERATOR_KEY，意味着这个JMenuItem.setAccelerator(KeyStroke)是自动被调用]]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插值]]></title>
    <url>%2F%2F2018%2F09%2Falgorithm-Interpolation-%E6%8F%92%E5%80%BC.html</url>
    <content type="text"><![CDATA[###Interpolation - 插值 In the mathematical field of numerical analysis, interpolation is a method of constructing new data points within the range of a discrete set of known data points. ^8 Piecewise constant interpolation - 分段常量插值Further information: Nearest-neighbor interpolation The simplest interpolation method is to locate the nearest data value, and assign the same value. ^9 Linear interpolation - 线性插值One of the simplest method is linear interpolation.^10 Generally,linear interpolation takes two data points,say$$(x_a,y_a)$$,and the interpolation is given by: $$y = y_a + (y_b -y_a) \frac{x-x_a}{x_b - x_a}$$ at the point $$(x,y)$$ Then the linear interpolation error is Polynomial interpolation - 多项式插值Polynomial interpolation is generalization of linear interpolation.^11Note that the linear interpolation is a linear function. ^12We replace this interpolation with polynominal of higher degree. ^13 Calculating the interpolating polynomial is computationally expensive (see computational complexity) compared to linear interpolation. [^14]Furthermore, polynomial interpolation may exhibit oscillatory artifacts, especially at the end points (see Runge’s phenomenon). [^15] Spline interpolatio - 样条插值Remember that linear interpolation uses a linear function for each of intervals [$$x_k,x_{k+1}$$] .[^16]Spline interpolation uses low-degree polynominals in each of the intervals,and choose the polynominal piece such that fit smoothly together.[^17]The resulting function is called a spline. [^18] However, the global nature of the basis functions leads to ill-conditioning. This is completely mitigated 减弱 by using splines of compact support, such as are implemented in Boost.Math and discussed in Kress Via Gaussian processes - 使用高斯处理Gaussian process is a powerful non-linear interpolation tool. Many popular interpolation tools are actually equivalent to particular Gaussian processes.[^19] Other forms - 其他解决插值方法组合Other forms of interpolation can be constructed by picking a different class of interpolations.[^20] In higher dimensions - 高纬度插值使用Multivariate interpolation is the interpolation of functions of more than one variable. [^21] Related concepts - 相关概念The term extrapolation is used to find data points outside the range of known data points. 插值与曲线拟合不同 In curve fitting problems, the constraint that the interpolant has to go exactly through the data points is relaxed. Approximation theory studies how to find the best approximation to a given function by another function from some predetermined class, and how good this approximation is. This clearly yields a bound on how well the interpolant can approximate the unknown function. Extension - 拓展rational functionsrational [‘ræʃ(ə)nəl]n adj: 理性,有理数 In mathmatics, a rational function is any function which can be defined by a rational fraction.^1i.e. an algebraic fraction such that the numerator and the denominator are polynominals.^2The coefficients of the polynominals need not be rational numbers;^3They can be taken in any field K.^4In this case, one speaks of a rational function and a rational function over K.[^5]The values of the variables may be taken in any field L containing K.^6Then the function is the set of the value of the variables for which the denominator is not zero and the codomain is L.^7 MatLab实现插值griddedInterpolant函数 Description 使用griddedInterpolant来执行1-D,2-D,3-D,or N-D 栅格数据集插值。griddedInterpolant返回插值F从被给予的数据集.能够在查询点集合测量F 使用scatteredInterpolant来执行对于离散数据scattered data的插值 Syntax F = griddedInterpolant F = griddedInterpolant(x,v) 创造一个1-D插值通过样本点集矢量vertorx和符合值v. F = griddedInterpolant(X1,X2,...,Xn,V) ， F = griddedInterpolant(V) 使用默认网格创造插值。当你在使用这个语法时候griddedInterpolant定义在第ith 维空间是1和范围是[1,size(V,i)]网格作为一个点集合。使用这个语法在你不需要关注内存和点之间绝对距离 F = griddedInterpolant(gridVecs,V) 指定包含n个grid vectors[^gird_vec]的描述n维样本网格cell数组gridvecs。使用这个语法当你需要使用指定的网格和关心内存 F = griddedInterpolant(___,Method) F = griddedInterpolant(___,Method,ExtrapolationMethod) 指定 both the interpolation and extrapolation methods. griddedInterpolant uses ExtrapolationMethod to estimate the value when your query points fall outside the domain of your sample point example 123456789101112131415function [ F ] = Test_Interpolation( )%TEST 任何需要测试的例子% 1-D Interpolation，使用默认‘linear’插值% Syntax F = griddedInterpolant(x,v) x = sort(20 * rand(100,1)); %介于0-20的100个随机数v = besselj(0,x); %一个函数F = griddedInterpolant(x,v); %创造一个网格插值对象，默认使用'linear' 插值方法xq = linspace(0,20,500); %插入500个统一距离的介于0-20的值vq = F(xq);plot(x,v,'ro')hold on %当需要多次使用plot且图像需要叠加时plot(xq,vq,'.')legend('Sample points','Interpolated Values')hold off %终止接下来的需要plot图像叠加,则下一次plot在另外一个窗口打开end 123456789101112131415function [ F ] = Test_Interpolation( )%TEST 任何需要测试的例子%Describe Using Full Grid %Syntax F = griddedInterpolant(gridVecs,V)%Vq = F(Xq1,Xq2,...,Xqn,V) 相对于F(&#123;xgq1,xgq2,...,xgqn&#125;,V)x = (1:0.3:5)'; %行向量转置y = x';V = cos(x) * sin(y);n = length(x);%surf(1:n,1:n,V) %未插值，画3-D表面，一一对应(x,y,z)F = griddedInterpolant(V);[xq,yq] = ndgrid(1:0.2:n); %当存储无较大关系Vq = F(xq,yq);surf(xq',yq',Vq)end Input Argument x — Sample points vector Data Types: single | double v — Sample values vector Data Types: single | double X1, X2, Xn — Sample points in full grid form arrays Data Types: single | double gridVecs — Sample points in grid vector form cell array of grid vectors 当你网格是非常大的时候，使用这个形式作为一个和完整网格交替的形式 Vq = F({xgq1,xgq2,...,xgqn}) specifies the query points as grid vectors. Use this syntax to conserve memory when you want to query a large grid of points. Vq = F(Xq1,Xq2,...,Xqn) specifies the query points using the n-dimensional arrays Xq1,Xq2,...,Xqn, which define a full grid of points. Data Types: single | double V — Sample values array Data Types: single | double Method — Interpolation method &#39;linear&#39; (default) | &#39;nearest&#39; | &#39;next&#39; | &#39;previous&#39; | &#39;pchip&#39; | &#39;cubic&#39; | &#39;spline&#39; | &#39;makima&#39; ExtrapolationMethod — Extrapolation method &#39;linear&#39; (default) | &#39;nearest&#39; | &#39;next&#39; | &#39;previous&#39; | &#39;pchip&#39; | &#39;cubic&#39; | &#39;spline&#39; | &#39;makima&#39; | &#39;none&#39; 具体method代表意义，请参考手册， Properties类似于成员变量GridVectors — Grid vectors cell array ​ Values — Function values at sample points array ​ Method — Interpolation method &#39;linear&#39; (default) | &#39;nearest&#39; | &#39;next&#39; | &#39;previous&#39; | &#39;pchip&#39; | &#39;cubic&#39; | &#39;spline&#39; | &#39;makima&#39; ​ ExtrapolationMethod — Extrapolation method &#39;linear&#39; | &#39;nearest&#39; | &#39;next&#39; | &#39;previous&#39; | &#39;pchip&#39; | &#39;cubic&#39; | &#39;spline&#39; | &#39;makima&#39; | &#39;none&#39; interp1函数参考 这个函数能够通过插值生成具体函数表达式 参考 pp = interp1(x,v,method,’pp’) 描述 [^14]: 计算插值多项式是计算昂贵的【计算复杂度 】computational complexity 相比线性插值[^15]: 更多的是，多项式插值可能会展现oscillatory[震荡] artifacts，特别在末尾的点 see Runge’s phenomenon[^16]: 记住线性插值在每个$$[x_k,x_{k+1}]$$使用线性函数[^17]: 样条插值在每一个区间内使用低次多项式，和使用能够光滑的拟合在一起多项式段[^18]: 这个结果函数被叫做样条[^19]: 高斯处理是一个强大的非线性插值工具。许多普遍化插值工具实际上是类似于特殊的高斯处理[^20]: 其他的插值格式能够被构造通过选择不同的插值类[^21]: Multivariate interpolation是超过一个变量的插值函数 参考引用： https://en.wikipedia.org/wiki/Interpolation [^gird_vec]: 一个服务作为表示(compact representation)ndgrid格式的网格矢量集合。 例如:[X,Y] = ndgrid(xg,yg)返回一个完整的网格矩阵X和Y.能够通过使用网格矢量xg和yg表示相同网格。意义是后者能比前者节省内存.]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定结点求距离K其它结点]]></title>
    <url>%2F%2F2018%2F09%2Falgorithm-kTree.html</url>
    <content type="text"><![CDATA[863. All Nodes Distance K in Binary Tree描述我们将会给予一个二叉树^1，一个target结点，和一个整数值K。 返回距离target结点为K路径长度的所有结点的值的集合。答案能够返回以任何顺序。 We are given a binary tree (with root node root), a target node, and an integer value K.Return a list of the values of all nodes that have a distance K from the target node. The answer can be returned in any order. 是否能够解决不能，通过查看此题的solution和discuss的大神操作，查看解题思路和代码snippet，摘录以下： 方案一步骤： 先遍历结点，采用中序遍历递归 如果发现target结点，遍历子结点添加距离target路径为K的结点的值,采用中序遍历递归的回溯作用查找距离target路径为K的结点的值 如果没有发现target结点，递归直至结点为null 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public List&lt;T&gt; distanceK(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, int K) &#123; if (root == null || target == null) return null; list = new ArrayList&lt;T&gt;(); preOrder(root, target, list, K); return list; &#125;private int preOrder(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, List&lt;T&gt; list, int K) &#123; if (root == null) return -1; if (root.val.equals(target.val)) &#123; //k == 0 的情况 //当K为0时，只存在它本身，没必要在遍历 if (K == 0) &#123; list.add(root.val); return 1; &#125; getNodesFromChildren(root.left, list, K - 1); getNodesFromChildren(root.right, list, K - 1); return 1; &#125; else &#123; //回溯作用，能够回溯到祖先和祖先的右孩子 //在找到target结点后，此时ret返回值大于0，所以开始进行上述回溯操作 int ret = preOrder(root.left, target, list, K); if (ret &gt;= 0) &#123; //K大于等于1的情况 if (ret == K) &#123; list.add(root.val); return ret + 1; &#125; getNodesFromChildren(root.right, list, K - (ret + 1)); return ret + 1; &#125; //回溯作用，能够回溯到祖先和祖先的右孩子 ret = preOrder(root.left, target, list, K); if (ret &gt;= 0) &#123; if (ret == K) &#123; list.add(root.val); return ret + 1; &#125; getNodesFromChildren(root.left, list, K - (ret + 1)); return ret + 1; &#125; &#125; return -1;&#125;/** * @param root（1）满足root.val==target.val （2）祖先结点 K=K-向上回溯祖先的数目 * @param list 添加满足值 * @param K 距离K的路径 * 实现根据以树根节点root进行中序遍历查找距离K路径的结点，并把满足的结点的值添加进list */private void getNodesFromChildren(TreeNode&lt;T&gt; root, List&lt;T&gt; list, int K) &#123; if (root == null) return; if (K == 0) &#123; list.add(root.val); return; &#125; getNodesFromChildren(root.left, list, K - 1); getNodesFromChildren(root.right, list, K - 1);&#125; 方案二Annotate ParentIntuition If we know the parent of every node x, we know all nodes that are distance 1 from x. We can then perform a breadth first search from the target node to find the answer. Algorithm We first do a depth first search where we annotate every node with information about it’s parent. After, we do a breadth first search to find all nodes a distance K from the target. 步骤： 深度搜索注释所有子结点的父亲结点，根节点的父亲结点为null 以target结点为首层，递增路径，每次队列存放的结点只满足递增路径深度为相同列^2 直至递增路径等于k路径长度，此时队列中的存放的结点即为满足元素 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 public List&lt;T&gt; distanceK1(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, int K) &#123; parents = new HashMap(); //dfs(root, parents); dfs(root, null); List&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.add(null); queue.add(target); //防止回溯到已经遍历过的结点 Set&lt;TreeNode&lt;T&gt;&gt; seen = new HashSet(); seen.add(null); seen.add(target); int dist = 0; while (!queue.isEmpty()) &#123; //移除队列的首元素（first） TreeNode&lt;T&gt; node = ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll(); //每次出队元素为null而且此时dist长度不等于k时，路径进1 if (node == null) &#123; if (dist == K) &#123; List&lt;T&gt; ans = new ArrayList&lt;&gt;(); for (TreeNode&lt;T&gt; t : queue) ans.add(t.val); return ans; &#125; ++dist; ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(null); &#125; else &#123; if (!seen.contains(node.left)) &#123; seen.add(node.left); //添加元素到尾(tails) ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.left); &#125; if (!seen.contains(node.right)) &#123; seen.add(node.right); ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.right); &#125; TreeNode&lt;T&gt; parent = parents.get(node); if (!seen.contains(parent)) &#123; seen.add(parent); ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(parent); &#125; &#125; &#125; return new ArrayList&lt;&gt;();&#125; 完整测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363package leetcode;import jdk.nashorn.api.tree.Tree;import java.util.*;/** * 任何实现equals类且都可以进行深度为K路径长度的检索 * * @param &lt;T&gt; 泛型类 */public class BTAllNodeDistanceK&lt;T&gt; &#123; private T dist[]; private static int controlDiVa = 0; List&lt;T&gt; list; //错误使用 Map&lt;TreeNode&lt;T&gt; node,TreeNode&lt;T&gt; parents&gt; parents; Map&lt;TreeNode&lt;T&gt;, TreeNode&lt;T&gt;&gt; parents; //Definition for a binary tree node. public static class TreeNode&lt;T&gt; &#123; T val; TreeNode&lt;T&gt; left; TreeNode&lt;T&gt; right; TreeNode(T x) &#123; val = x; &#125; public TreeNode() &#123; &#125; &#125; public BTAllNodeDistanceK(T sour[]) &#123; // TODO Auto-generat d constructor stub this.dist = sour; &#125; public List&lt;T&gt; distanceK(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, int K) &#123; if (root == null || target == null) return null; list = new ArrayList&lt;T&gt;(); preOrder(root, target, list, K); return list; &#125; private int preOrder(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, List&lt;T&gt; list, int K) &#123; if (root == null) return -1; if (root.val.equals(target.val)) &#123; if (K == 0) &#123; list.add(root.val); return 1; &#125; getNodesFromChildren(root.left, list, K - 1); getNodesFromChildren(root.right, list, K - 1); return 1; &#125; else &#123; //回溯作用，能够回溯到祖先和祖先的右孩子 int ret = preOrder(root.left, target, list, K); if (ret &gt;= 0) &#123; if (ret == K) &#123; list.add(root.val); return ret + 1; &#125; getNodesFromChildren(root.right, list, K - (ret + 1)); return ret + 1; &#125; //回溯作用，能够回溯到祖先和祖先的右孩子 ret = preOrder(root.left, target, list, K); if (ret &gt;= 0) &#123; if (ret == K) &#123; list.add(root.val); return ret + 1; &#125; getNodesFromChildren(root.left, list, K - (ret + 1)); return ret + 1; &#125; &#125; return -1; &#125; /** * @param root（1）满足root.val==target.val （2）祖先结点 K=K-向上回溯祖先的数目 * @param list 添加满足值 * @param K 距离K的路径 * 实现根据以树根节点root进行中序遍历查找距离K路径的结点，并把满足的结点的值添加进list */ private void getNodesFromChildren(TreeNode&lt;T&gt; root, List&lt;T&gt; list, int K) &#123; if (root == null) return; if (K == 0) &#123; list.add(root.val); return; &#125; getNodesFromChildren(root.left, list, K - 1); getNodesFromChildren(root.right, list, K - 1); &#125; /** * 创造一颗二叉树 * * @param tN * @return tN指向引用和调用函数root值引用不同，所以需要返回值使调用函数的root引用地址保持和tN引用地址一样 */ public TreeNode&lt;T&gt; createTree(TreeNode&lt;T&gt; tN) &#123; T tem = dist[controlDiVa]; controlDiVa++; if (tem == null) &#123; return tN = null; &#125; else &#123; tN = new TreeNode&lt;T&gt;(); tN.val = tem; tN.left = createTree(tN.left); tN.right = createTree(tN.right); &#125; return tN; &#125; /** * 实现中序排序 * * @param root 根结点 */ public void inOrder(TreeNode&lt;T&gt; root) &#123; if (root == null) &#123; return; &#125; inOrder(root.left); System.out.print(root.val + " "); inOrder(root.right); &#125; public static void main(String[] args) &#123; /****************************第一种方法查找******************************** * int k=2; //必须满足上述条件的数组才能使用createTree方法建立一颗二叉树 Integer[] sour= &#123;1,2,3,null,null,null,134,5,null,null,6,null,null&#125;; ** * 1 * ////////\\\\\\\\ * 2 134 * ////\\\\ ////\\\\ * 3 null 5 6 * //\\ //\\ //\\ * null null null null null null * TreeNode&lt;Integer&gt; root=new TreeNode&lt;Integer&gt;(); TreeNode&lt;Integer&gt; target=new TreeNode&lt;Integer&gt;(); target.val=2; target.left=null; target.right=null; BTAllNodeDistanceK&lt;Integer&gt; a=new BTAllNodeDistanceK&lt;Integer&gt;(sour); root=a.createTree(root); a.distanceK(root,target,k); Iterator&lt;Integer&gt; ite=a.list.iterator(); System.out.println("距离路径为"+k+"的值为："); while(ite.hasNext()) &#123; System.out.println(ite.next()); &#125; ******************************************************************/ //必须满足上述条件的数组才能使用createTree1方法建立一颗二叉树 Integer[] sour = &#123;3, 5, 1, 6, 2, 0, 8, null, null, 7, 4&#125;; /* 必须满足的树的结构 3 //////// \\\\\\\\ 5 1 //// \\\\ //// \\\\ 6 2 0 8 // \\ // \\ null null 7 4 */ TreeNode&lt;Integer&gt; root; TreeNode&lt;Integer&gt; target; BTAllNodeDistanceK&lt;Integer&gt; a = new BTAllNodeDistanceK&lt;&gt;(sour); root = a.createTree1(); System.out.println("1.测试是否能够生成二叉树："); a.inOrder(root); System.out.println(); System.out.println("2.测试是否能够查找到在指定树中指定树结点值的结点："); target = a.dfsForTarget(root, 5); System.out.println("target.val:" + target.val); if (target.left != null) System.out.println("if target.left != null target.left.val: "+target.left.val); if (target.right != null) System.out.println("if target.right != null target.left.val: "+target.right.val); a.list=a.distanceK1(root,target,2); Iterator&lt;Integer&gt; ite=a.list.iterator(); System.out.println("距离路径为"+2+"的值为："); while(ite.hasNext()) &#123; System.out.println(ite.next()); &#125; &#125; public List&lt;T&gt; distanceK1(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; target, int K) &#123; parents = new HashMap(); //dfs(root, parents); dfs(root, null); List&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.add(null); queue.add(target); //防止回溯到已经遍历过的结点 Set&lt;TreeNode&lt;T&gt;&gt; seen = new HashSet(); seen.add(null); seen.add(target); int dist = 0; while (!queue.isEmpty()) &#123; //移除队列的首元素（first） TreeNode&lt;T&gt; node = ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll(); //每次null路径进1 if (node == null) &#123; if (dist == K) &#123; List&lt;T&gt; ans = new ArrayList&lt;&gt;(); for (TreeNode&lt;T&gt; t : queue) ans.add(t.val); return ans; &#125; ++dist; ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(null); &#125; else &#123; if (!seen.contains(node.left)) &#123; seen.add(node.left); //添加元素到尾(tails) ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.left); &#125; if (!seen.contains(node.right)) &#123; seen.add(node.right); ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(node.right); &#125; TreeNode&lt;T&gt; parent = parents.get(node); if (!seen.contains(parent)) &#123; seen.add(parent); ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(parent); &#125; &#125; &#125; return new ArrayList&lt;&gt;(); &#125; /** * 创造一颗二叉树,存储值的数组需要满足特定结构 * * @return root */ public TreeNode&lt;T&gt; createTree1() &#123; int j = dist.length; int i = 1; if (j == 0) &#123; return null; &#125; TreeNode&lt;T&gt; tN = new TreeNode&lt;&gt;(); tN.val = dist[0]; List&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.add(tN); //申明在作用域的上一层 TreeNode&lt;T&gt; parent; TreeNode&lt;T&gt; tem; while ((2 * i - 1) &lt; j) &#123;/***********************错误代码************************************* * parent不可能为null，因为每次可进入队列的元素必然new TreeNode&lt;T&gt;一次 *******************************************************************/// parent=((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll();// if(parent==null)// throw new NullPointerException("不存在parent为null的结点");// tem = new TreeNode&lt;&gt;();// tem.val = dist[2 * i - 1];// parent.left = tem;// ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(tem);/***********************正确代码************************************* * 添加数组元素是否为null的判定 *******************************************************************/ parent = ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).poll(); if (parent == null) throw new NullPointerException("不存在父亲为null的结点"); if (dist[2 * i - 1] == null) ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(null); else &#123; tem = new TreeNode&lt;&gt;(); tem.val = dist[2 * i - 1]; parent.left = tem; ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(tem); &#125; if (2 * i &lt; j) &#123; if (dist[2 * i] == null) ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(null); else &#123; tem = new TreeNode&lt;&gt;(); tem.val = dist[2 * i]; parent.right = tem; ((LinkedList&lt;TreeNode&lt;T&gt;&gt;) queue).offer(tem); &#125; &#125; i++; &#125; return tN; &#125; /** * :leetcode提供解决方案 * 把所有结点的父结点标记 * * @param node 孩子结点 * @param parent 父亲结点 */ private void dfs(TreeNode&lt;T&gt; node, TreeNode&lt;T&gt; parent) &#123; if (node != null) &#123; parents.put(node, parent); dfs(node.left, node); dfs(node.right, node); &#125; &#125; /** * :自己模仿写的 * 把所有结点的父结点标记 * * @param root_ 父结点 * @param parents_ 以孩子结点为key,父亲结点为value的标记集合 */ private void dfs1(TreeNode&lt;T&gt; root_, Map parents_) &#123; //排除第一次进入时出现root_为null的情况 if (root_ == null) return; //递归基 if (root_.left != null) &#123; parents_.put(root_.left, root_); dfs1(root_.left, parents_); &#125; if (root_.right != null) &#123; parents_.put(root_.right, root_); dfs1(root_.right, parents_); &#125; return; &#125; public TreeNode&lt;T&gt; dfsForTarget(TreeNode&lt;T&gt; root, T val) &#123; TreeNode&lt;T&gt; tem; if (root != null) &#123; if (root.val.equals(val)) &#123; return root; &#125; tem = dfsForTarget(root.left, val); if (tem != null) &#123; return tem; &#125; tem = dfsForTarget(root.right, val); if (tem != null) return tem; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>quickSort</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用命令]]></title>
    <url>%2F%2F2018%2F07%2Fextension-MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[MySQL常用命令查询表user所有字段信息SELECT 字段 FROM 表； eg :SELECT * FROM user; 选择db_test数据库USE 数据库; eg :USE db_test; 在表user插入一列名为name，类型为varchar，且不为NULL字段ALTER TABLE 表 ADD 字段名 类型 xx; eg :ALTER TABLE user ADD name varchar(40) NOT NULL; 删除表user中字段为id的一列ALTER TABLE 表 DROP 字段名; eg :ALTER TABLE user DROP id; 在表user中七个字段（Filed）插入一行数据INSERT INTO 表 VALUES(Field,Field,Field,Field); eg :INSERT INTO user(username,password,uid,name,email,sex,birthday) VALUES(&quot;ghu2&quot;,&quot;12312&quot;,&quot;1e0d8987-7c8d-4f9b-8cd4-2adba575b464&quot;,&quot;gy&quot;,&quot;twg&quot;,&quot;tfy&quot;,&quot;wf&quot;);]]></content>
      <categories>
        <category>extension</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSLCertificateVerification）]]></title>
    <url>%2F%2F2018%2F07%2Fextension-SSLCertificateVerification-%E8%AF%81%E4%B9%A6.html</url>
    <content type="text"><![CDATA[SSL Certificate Verification_证书SSLSSL是的旧的名字，现在他被叫做TLS 原生SSL如果libcurl是用Schannel或者Secure Transport构造的（原生SSL库包含在Windows和Mac OS x)，那么这个不能适用你。向下滑获得OS-native-engines如何处理SSL证书。如果你是不确定，那么run“curl -V”和阅读结果 。如果版本字符串包含”WinSSL“，那么这个是使用hannel support 是关于可信这个系统是关于可信的。在你的当地CA证书存储区，你有来自可信赖CA证书机构证书这个你能够使用来验证这个你看起来是有效的证书。他们是被签署通过你信赖的某一个CAs证书机构。 你信赖这个CAs？你能够决定信赖一个相同的公司组这个你操作系统信赖的，或者一个组某一个知名浏览器信赖的。这些都基于你的信任。你应该意识到这个现代操作系统和浏览器是被启动信任上百个公司和最近几年several such CAS已经被发现时不可信的。 证书验证libcurl默认执行peer对等SSL证书验证。这个是被做通过使用能够被SSL库使用来确认对等服务器证书时有效的CA证书存储区。 Note:If you communicate with HTTPS, FTPS or other TLS-using servers using certificates that are signed by CAs present in the store, you can be sure that the remote server really is the one it claims to be. 忽略证书验证如果远程服务器使用一个自签名证书，如果你没有安装CA证书存储区，如果服务器使用一个被并没有包含在你使用存储区CA证书签署，或者这个远程主机是一个imposer冒名顶替者impersonting扮演你喜爱的站点，但是你想从这个服务器传输文件，做下面的一种： 1: 告诉libcurl不要验证对等。使用libcurl禁用curl_easy_setopt(curl,CURLOPT_SSL_VERIFYPEER,FALSE)2: 使用curl command line tool禁用这个使用-k/--insecure3: 得到一个能够验证远程服务器CA 证书和当连接的时候使用恰当的选择来指定这个CA证书来证。 对于libcurl hacker curl_easy_setopt(curl,CURLOPT_CAPATH,capath) curl command line tool --cacert [file]4: 为你服务器添加CA证书到已经存在默认的CA 证书存储区。默认的CA证书存储区能够在compile时间改变,即通过下面的配置选择： --with-ca-bundle=FILE Note:use the specified file as CA certificate store. CA certificates need to be concatenated in PEM format into this file --with-ca-path=PATH Note:use the specified path as CA certificate store. CA certificates need to be stored as individual PEM files in this directory. You may need to run c_rehash after adding files there. If neither of the two options is specified, configure will try to auto-detect a setting. It’s alsopossible to explicitly not hardcode any default store but rely on the built in default the crypto library may provide instead. You can achieve that by passing both –without-ca-bundle and –without-ca-pathto the configure script. If you use Internet Explorer, this is one way to get extract the CA cert for a particular server: &lt;1&gt; View the certificate by double-clicking the padlock(挂锁) &lt;2&gt; Find out where the CA certificate is kept (Certificate&gt; Authority Information Access&gt;URL) &lt;3&gt; Get a copy of the crt file using curl &lt;4&gt; Convert it from crt to PEM using the openssl tool: openssl x509 -inform DES -in yourdownloaded.crt -out outcert.pem -text &lt;5&gt; Add the &apos;outcert.pem&apos; to the CA certificate store or use it stand-alone as described below. If you use the &apos;openssl&apos; tool, this is one way to get extract the CA cert for a particular server: 1:openssl s_client -connect xxxxx.com:443 |tee logfile 2:type &quot;QUIT&quot;, followed by the &quot;ENTER&quot; key 3:The certificate will have &quot;BEGIN CERTIFICATE&quot; and &quot;END CERTIFICATE&quot; markers. If you want to see the data in the certificate, you can do: &quot;openssl x509 -inform PEM -in certfile -text -out certdata&quot; where certfile is the cert you extracted from logfile. Look in certdata. If you want to trust the certificate, you can add it to your CA certificate store or use it stand-alone as described. Just remember that the security is no better than the way you obtained the certificate.If you&apos;re using the curl command line tool, you can specify your own CA cert path by setting the environment variable CURL_CA_BUNDLE to the path of your choice. If you’re using the curl command line tool on Windows, curl will search for a CA cert file named “curl-ca-bundle.crt” in these directories and in this order: application’s directory current working directory Windows System directory (e.g. C:\windows\system32) Windows Directory (e.g. C:\windows) all directories along %PATH% Get a better/different/newer CA cert bundle! One option is to extract the one a recent Firefox browser uses by running ‘make ca-bundle’ in the curl build tree root, or possibly download a version that was generated this way for you: CA ExtractCertificate Verification with NSSCertificate Verification with Schannel and Secure Transport 如果libcurl是使用Schannel(Microsoft native TLS engine:验证得出本机目前使用这个built的)built或者苹果（省略）支持，那么libcurl将会任然执行对等验证，但是如果代替使用CAcertificate bundle，它将会使用这个built在OS里证书.这些相同证书出现在internet Options controls panel(under windows),任何用于证书的自定义安全规则都将得到遵守 除非对等验证被禁用，否则Schannel将对证书运行CRL检查 HTTPS proxy SSL certificate problem: unable to get local issuer certificate意味着cUrl不信任 Verisign证书机构 Note:VeriSign 的数字信任服务通过VeriSign的域名登记、数字认证和网上支付三大核心业务，在全球范围内建立起了一个可信的虚拟环境，使任何人在任何地点都能放心地进行数字交易和沟通。而数字证书业务是其起家的核心业务.VeriSign数字证书产品是目前市场上最完整的支持最多应用和最多设备的数字证书产品，主要包括： SSL 证书和代码签名证书。]]></content>
      <categories>
        <category>extension</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>extenstion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令（更新）]]></title>
    <url>%2F%2F2018%2F07%2Fdeploy-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89.html</url>
    <content type="text"><![CDATA[提交代码时候，来确认谁提交的代码Note:所有命令在git bash命令行输入 123eg:$ git config --global user.name "Nautilus-Nemo"$ git config --global user.name "13612262974@163.com" 确认上面的配置是否成功： 123eg:$ git config --global user.name$ git config --global user.name 创建代码仓库 仓库repository是用于保存版本管理所需信息的地方，所有本地提交的代码都会保存在代码仓库中， 如果有需要还可以推送到远程仓库中 进入所需要创建代码仓库的项目的目录 $ cd [your project directory] $ git init Note:仓库建立以后，项目的根目录会生成一个隐藏的`.git`文件夹,这个文件就是来记录本地 所有的`git`操作。如果要删除本地仓库的话，只需要删除这个文件夹 查看所有本地的git操作1$ ls al 提交本地代码 添加一个文件 $ git add (your file) 添加一个目录 $ git add (your directory) 添加某项目下的所有文件 $ git add . 添加完所需要的文件后，提交 $ git commit -m &quot;First commit.&quot; Note:我们一般通过-m参数来加上提交的文件信息 发布至远程仓库1$ git push origin master 其中origin部分指定的是远程版本库的Git地址，master部分指定的是同步到哪一个分支上 远程版本库上的修改同步到本地 Git提供了两种命令来完成此功能，分别是fetch和pull,fetch的语法规则和push差不多 1$ git fetch origin master 执行了这个命令后，就会将远程版本库上的代码同步到本地，不过同步下来的代码并不会合并到任何分支上，而是会存放到origin/master分支。 我们可以通过diff命令来查看远程版本库到底修改了那些东西: 1$ git diff origin/master 调用merge命令将origin/master分支上的修改合并到主分支上 1$ git merge origin/master pull命令则是将fetch和merge这两个命令放在一起执行。他可以从远程版本库上获取最新的代码并且合并到本地上1git pull origin master 复制Github中已有的开源库 复制这个开源库的url：即右上角蓝色clone or download按钮 打开git bash,cd至你要复制的项目目录，使用命令 1$ git clone (url) Note:可能需要把所有clone的文件复制到上一层，因为上一层才是项目的根目录，要注意把隐藏文件.git复制过去 分支的用法1$ git branch 查看有那些分支1$ git branch version1.0 创建了一个名为version1.0的分支 1git checkout master 切换到master分支 1git merge -D version1.0 使用merge命令来完成合并操作 1git branch -D version1.0 删除分支1$ git push --repo=https://github.com/Nautilus-Nemo/coolweather 提交到具体的库 1$ git checkout master 确定提交的库 [详情] (file:///C:/software/Git/mingw64/share/doc/git-doc/git-push.html#URLS）]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>deploy</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始使用GitHub]]></title>
    <url>%2F%2F2018%2F06%2Fdeploy-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8GitHub.html</url>
    <content type="text"><![CDATA[开始使用GitHub什么是GitHub？GitHub是一个用于版本控制和合并代码托管平台。它让你和你的工作伙伴工作在同一个项目不管你们两者是否相隔天涯海角。创造一个Respository一个respository是通常用来组织一个项目。Respository能够包含文件夹和文件，图像，视频，电子表格，和数据集等任何东西你的项目需要的。我们建议包括一个README，或者一个文件包含你的项目信息。Github使它容易去增加一个在相同时间你去创造一个新的Respository（GitHub可以在创建新存储库的同时轻松添加一个）。它也提供其他常用的选择。例：license file 在右上角，在你的头像（avatar）或身份证（identicon)旁边,点击+和选择NEW repository 给你的repository取个名字。例：Hello_world 写一个简短的描述 选择初始化这个repository with a README. 创造一个BranchBranching 是一种方式工作在同一时间同一个库中不同的版本。默认的你的repository有一个branch被叫做master.我们经常使用branches来在committing他们到master以前实验和编辑。什么时候你创造一个branch从master branch,你是制造一个copy，或者快照(snapshot).他人在master分支上工作时对分支进行了更改,你能获得这些更新。你曾经存储过不同的文件版本？像这样 story.txt story-joe-edit.txt story-joe-edit-reviewed.txt Branches在Github repository完成相同的目标 先去到你新创建的repository 点击文件清单上面叫Branch:master下拉项。 在新的分支文本框打上一个分支名字 选择蓝色Create Branch框或者点击”Enter”在你的键盘。 对文件做修改和push他们到GitHub as commits在Github,存储改变是被叫做commits.每个commit有一个相关联的来描述解释变化commit信息。Commit信息能够抓住历史中的变化，所以其他的contributor能够理解你做了什么和为什么这样做具体操作步骤 打开和merge一个pull requestPull Request 是的在Github合并的核心.什么时候你打开了一个pull request,你是正在提出你的改变和请求其他人review和pull in你的contribution（并要求有人审查并提交你的贡献）和融合他们到他们的分支。pull 请求展示两个分支的diffs，或者不同。Gihub@mention system你能询问反馈从指定人们或者队伍。具体操作步骤 融合一个分支到主分支具体操作步骤 To learn more about the power of Pull Requests, we recommend reading the GitHub Flow Guide`https://guides.github.com/introduction/flow/`. You might also visit GitHub Explore`https://github.com/explore` and get involved in an Open Source project Connecting to GiHub with SSH使用SSH协议，你能连接和认证远程服务器和服务。使用SSH keys,你能连接Github不需要提供你的用户名和密码在每一次登陆网站当您设置SSH时，您将生成一个SSH密钥并将其添加到ssh-agent，然后将密钥添加到您的 GitHub帐户。将SSH密钥添加到ssh-agent.可确保您的SSH密钥通过使用密码短语具有额外 的安全层。有关更多信息，请参阅“ 使用SSH密钥密码”。要将SSH密钥与使用SAML单点登录 的组织拥有的存储库一起使用，您需要先对其进行授权。有关更多信息，请参阅“ 授权SSH密 钥以用于SAML单一登录组织。” 我们建议您定期查看您的SSH密钥列表并撤销任何无效或已被入侵的密钥。 具体生成SSH或者其他步骤]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>deploy</tag>
        <tag>tool</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android天气项目设计文档（第一行代码）]]></title>
    <url>%2F%2F2018%2F06%2Fandroid-Android-%E5%A4%A9%E6%B0%94%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3.html</url>
    <content type="text"><![CDATA[1. 设计目的为了让广大Android手机用户能够在第一时间获取最新天气预报消息，以便提前预防，方便出行。同时，把气象翟海早餐的瞬时降到最低，也可以提高公共服务质量，更好的发挥气象事业对经济社会发展的现实作用，有很强的实用价值。虽然该技术在Android平台早已比较成熟，但是通过本次软件的设计开发仍然能帮助我更好的认识Android系统的工作原理。 2.开发环境 android studio jdk sdk 3.需求分析 提供用户查看特定地区天气信息和生活建议 采用灵活方式实现用户获取到的数据是实时的 设计良好用户界面，提高用户体验 4.设计（1）数据库设计 采用开源Android数据库框架LitePal,它采用对象关系映射(ORM)的模式，并将我们平时最常用到的一些数据库功能进行了封装。使得不用编写SQL语句就可以完成各种建表和增删改查的操作。 Province数据表 属性 数据类型 说明 id integer 自增主键 provinceName text 省份名称 provinceCode integer 省份代号 City数据表 属性 数据类型 说明 id integer 自增主键 cityName text 城市名称 cityCode integer 城市代号 provinceId integer 当前市属省的id值 County数据表 属性 数据类型 说明 id integer 自增主键 countyName text 县名称 countyCode integer 县代号 cityId integer 当前县属市的id值 （2）功能模块从功能需求分析可以看出，整个应用程序应该分为4个模块。分别是用户界面，数据获取模块和数据库适配器和网络请求模块。各模块之间的关系如图： 1234567891011B --&gt;|startService 启动服务| I(后台服务)I --&gt;|八小时更新|HB[用户界面]--&gt;|设置相关信息| G(&lt;/Br&gt;数据获取模块)G--&gt;|天气信息| BG--&gt;D[数据库获取模块]D--&gt;GD--&gt;E[Litepal数据库框架]E--&gt;DH[okhttp3封装Http请求]--&gt;|解析返回天气数据信息|GH--&gt;EF[和风天气预报服务]--&gt;H 从模块结构图中不难看出，数据获取模块是整个应用程序的核心。主要是由sharePreferencr构成。获取数据信息从okhttp3网络请求模块中获取数据和服务每八小时网络请求模块获取一次数据。用户设置相关信息获取信息，一种从数据获取模块中寻找数据，第二种直接通过okhttp3网络请求模块请求获取数据并存储在数据获取模块中，在从数据获取模块中获取数据，能保证天气数据实时，且能保证网络阻塞情况下，能从数据获取模块获得数据。startService保证长时间未更新数据情况下，采用上述第二种方式从数据获取模块获得实时数据。数据获取模块是一种较良好方式从Http请求中获得实时数据的一种存储方式。数据库适配器使用Litepal数据库框架映射数据库。存储地区信息等比较固定的信息，避免频繁从网络请求模块中获取数据。 5.项目功能描述（1）系统主要功能 点击特定省份，城市和县来查看特定地区实时天气信息和服务信息 下拉刷新获取实时的天气信息和服务信息 后台服务，八小时自动跟新实时天气和服务信息 数据库存储地区信息，消除频繁去服务区获取数据 sharePreference存储天气信息，获取实时天气信息 获取每日一图，每日更换天气界面背景，获得好的用户体验 （2）系统各模块具体实现工程源代码的结构如图 源代码文件的名称以及说明： 包名称 文件名 说明 com.example.a13612.weather.db City.java 数据库表City映射模型 com.example.a13612.weather.db County.java 数据库表County映射模型 com.example.a13612.weather.db Province.java 数据库表Province映射模型 com.example.a13612.weather.gson AQI.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Basic.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Forecast.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Now.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Suggestion.java 天气数据json数据格式解析模型 com.example.a13612.weather.gson Weather.java 天气数据json数据格式解析模型 对应的json数据格式，采用gson解析 123456789101112&#123; "HeWeather": [ &#123; "status":"ok", //响应码 "basic":&#123;&#125;, //地区信息 "aqi":&#123;&#125;, //空气质量 "now":&#123;&#125;, //今天天气预报 "suggestion": &#123;&#125; //生活建议 "daily_forecast":[] //未来几天天气预报 &#125; ]&#125; 包名称 文件名 说明 com.example.a13612.weather.service AutoUpdateService.java 后台服务类，每八小时更新数据信息 com.example.a13612.weather.utils HttpUtil.java 服务器交互工具类，采用okhttp3网络通信库 com.example.a13612.weather.utils Utility.java 解析和处理从服务器返回json数据工具类 com.example.a13612.weather.ChooseAreaFragment ChooseAreaFragment.java 选择地区，来确定需要哪个地区天气信息 com.example.a13612.weather.WeatherActivity WeatherActivity.java 设置显示天气信息，加载天气界面 com.example.a13612.weather.MainActivity MainActivity.java 主活动，通过查看sharePreference是否存在数据来加载具体类,布局 Android的资源文件保存在/res的子目录中。其中,/res/layout/保存布局，/res/drawable/保存图片等信息 资源目录 文件 说明 layout activity_main.xml 复用碎片ChooseAreaFragment layout activity_weather.xml 天气界面，inlucde多个布局文件，引入下拉，opendraw layout aqi.xml 空气质量布局 layout choose_area.xml 选择地区布局 layout forecast.xml 多个天气预报布局 layout forecast_item.xml 单个天气预报item layout now.xml 当前天气预报布局 layout suggestion.xml 生活建议不 layout title.xml 标题框布局 drawable ic_back.png 返回上一级地区按钮图片 drawable ic_home.png 实现在天气界面打开侧框选择地区界面 配置文件 &lt;1&gt;项目所需的各种依赖库声明，具体配置文件app/build.gradle 123456deplencies&#123; implementation 'org.litepal.android:core:1.4.1' implementation 'com.squareup.okhttp3:okhttp:3.4.1' implementation 'com.google.code.gson:gson:2.7' implementation 'com.github.bumptech.glide:glide:3.7.0' &#125; 作用：LitePal用于对数据库操作，OkHttp用于进行网络请求，GSON用于解析JSON数据，Glide用于加载图片和展示图片 &lt;2&gt;LitePal配置文件，用于匹配映射数据库模型类，位于assets/litepal.xml 123456789 &lt;litepal&gt; &lt;dbname value="weather" /&gt; &lt;version value="1" /&gt; &lt;list&gt; &lt;mapping class="com.example.a13612.weather.db.Province" /&gt; &lt;mapping class="com.example.a13612.weather.db.City" /&gt; &lt;mapping class="com.example.a13612.weather.db.County" /&gt; &lt;/list&gt;&lt;/litepal&gt; 作用：建立数据库：weather，创建数据库表Province,City,County &lt;3&gt;AndroidManifest.xml,进行权限声明，活动,服务注册，LitePal声明 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.a13612.weather"&gt; &lt;!--访问网络权限--&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;application &lt;!--LitePal声明--&gt; android:name="org.litepal.LitePalApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" &lt;!--设置主题为自己定义AppTheme主题，具体配置AppTheme请看res/values/styles.xml--&gt; android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;!-- 指定当前活动能够响应的action和category --&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".WeatherActivity"&gt;&lt;/activity&gt; &lt;service android:name=".service.AutoUpdateService" android:enabled="true" android:exported="true"&gt;&lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; 6.数据提供者&lt;1&gt; 地区信息提供url接口： http://guolin.tech/api/china 提供所有省份信息 http://guolin.tech/api/china/&quot;+provinceCode 根据省份信息查找特定城市信息 http://guolin.tech/api/china/&quot;+provinceCode+&quot;/&quot;+cityCode 根据省份信息和特定城市信息查找特定地区信息 &lt;2&gt;和风天气数据信息提供urL接口： &quot;http://47.90.126.26/api/weather?cityid=&quot;+weatherId+&quot;&amp;key=de25d114b80e43ed907cc1db97335395&quot; weatherId：具体特定地区信息提供 key:http://guolin.tech/api/weather/register注册获取key &lt;3&gt;每日一图提供url接口： http://guolin.tech/api/bing_pc 7.系统界面​ ​]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%2F2018%2F06%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
